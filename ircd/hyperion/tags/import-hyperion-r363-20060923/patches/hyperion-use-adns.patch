Index: configure
===================================================================
--- configure	(revision 183)
+++ configure	(working copy)
@@ -319,7 +319,7 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CPP EGREP DOCUMENTATION_TRUE DOCUMENTATION_FALSE LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE RANLIB ac_ct_RANLIB CPP EGREP DOCUMENTATION_TRUE DOCUMENTATION_FALSE LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -2996,7 +2996,87 @@
 fi
 
 
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
 
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  echo "$as_me:$LINENO: result: $RANLIB" >&5
+echo "${ECHO_T}$RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_RANLIB" && ac_cv_prog_ac_ct_RANLIB=":"
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+echo "${ECHO_T}$ac_ct_RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  RANLIB=$ac_ct_RANLIB
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+
 echo "$as_me:$LINENO: checking for library containing strerror" >&5
 echo $ECHO_N "checking for library containing strerror... $ECHO_C" >&6
 if test "${ac_cv_search_strerror+set}" = set; then
@@ -7917,7 +7997,7 @@
 fi
 
 
-                                                                                                                                            ac_config_files="$ac_config_files Makefile autoconf/Makefile build-misc/Makefile doc/Makefile doc/sgml/Makefile doc/sgml/dancer-oper-guide/Makefile doc/sgml/dancer-user-guide/Makefile include/Makefile lib/Dancer/Makefile lib/Dancer/Proxy/Makefile lib/Makefile src/Makefile tools/Makefile patches/Makefile"
+                                                                                                                                                      ac_config_files="$ac_config_files Makefile adns/Makefile autoconf/Makefile build-misc/Makefile doc/Makefile doc/sgml/Makefile doc/sgml/dancer-oper-guide/Makefile doc/sgml/dancer-user-guide/Makefile include/Makefile lib/Dancer/Makefile lib/Dancer/Proxy/Makefile lib/Makefile src/Makefile tools/Makefile patches/Makefile"
 
 
 cat >confcache <<\_ACEOF
@@ -8484,6 +8564,7 @@
   case "$ac_config_target" in
   # Handling of arguments.
   "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+  "adns/Makefile" ) CONFIG_FILES="$CONFIG_FILES adns/Makefile" ;;
   "autoconf/Makefile" ) CONFIG_FILES="$CONFIG_FILES autoconf/Makefile" ;;
   "build-misc/Makefile" ) CONFIG_FILES="$CONFIG_FILES build-misc/Makefile" ;;
   "doc/Makefile" ) CONFIG_FILES="$CONFIG_FILES doc/Makefile" ;;
@@ -8633,6 +8714,8 @@
 s,@CCDEPMODE@,$CCDEPMODE,;t t
 s,@am__fastdepCC_TRUE@,$am__fastdepCC_TRUE,;t t
 s,@am__fastdepCC_FALSE@,$am__fastdepCC_FALSE,;t t
+s,@RANLIB@,$RANLIB,;t t
+s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
 s,@CPP@,$CPP,;t t
 s,@EGREP@,$EGREP,;t t
 s,@DOCUMENTATION_TRUE@,$DOCUMENTATION_TRUE,;t t
Index: Makefile.in
===================================================================
--- Makefile.in	(revision 183)
+++ Makefile.in	(working copy)
@@ -116,11 +116,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
@@ -162,7 +164,7 @@
 pkgdocdir = $(datadir)/doc/$(PACKAGE)
 AUTOMAKE_OPTIONS = foreign
 DISTCHECK_CONFIGURE_FLAGS = --with-config=dist
-SUBDIRS = autoconf build-misc include src lib tools doc patches
+SUBDIRS = adns autoconf build-misc include src lib tools doc patches
 EXTRA_DIST = AUTHORS NEWS README
 all: all-recursive
 
Index: include/Makefile.in
===================================================================
--- include/Makefile.in	(revision 183)
+++ include/Makefile.in	(working copy)
@@ -99,11 +99,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
Index: include/s_bsd.h
===================================================================
--- include/s_bsd.h	(revision 183)
+++ include/s_bsd.h	(working copy)
@@ -43,7 +43,7 @@
 extern int   check_client(struct Client*, char *,char **);
 extern void  close_connection(struct Client*);
 extern void  close_all_connections(void);
-extern int   connect_server(struct ConfItem*, struct Client*, struct DNSReply*);
+extern int   connect_server(struct ConfItem*, struct Client*, struct DNSQuery*);
 extern void  get_my_name(struct Client *, char *, int);
 extern void  init_netio(void);
 extern int   read_message (time_t, int);
Index: include/res.h
===================================================================
--- include/res.h	(revision 183)
+++ include/res.h	(working copy)
@@ -1,54 +1,37 @@
 /*
- * include/res.h (C)opyright 1992 Darren Reed.
- *
- * 
+ * $Id: res.h,v 1.19 2003/05/05 02:39:06 db Exp $ 
+ * New res.h
+ * Aaron Sethman <androsyn@ratbox.org>
  */
-#ifndef INCLUDED_res_h
-#define INCLUDED_res_h
 
-#ifndef INCLUDED_sys_types_h
-#include <sys/types.h>       /* time_t */
-#define INCLUDED_sys_types_h
-#endif
+#ifndef _RES_H_INCLUDED
+#define _RES_H_INCLUDED 1
 
-struct Client;
-struct hostent;
+#include "config.h"
+#include "ircd_defs.h"
+/* I hate this *blah* db */
+#include "fileio.h"
+#include "../adns/adns.h"
 
-struct DNSReply {
-  struct hostent* hp;        /* hostent struct  */
-  int             ref_count; /* reference count */
-};
+#define DNS_BLOCK_SIZE 64
 
 struct DNSQuery {
-  void* vptr;               /* pointer used by callback to identify request */
-  void (*callback)(void* vptr, struct DNSReply* reply); /* callback to call */
+	void *ptr;
+	adns_query query;
+	adns_answer answer;
+	void (*callback)(void* vptr, adns_answer *reply);
 };
 
-extern int ResolverFileDescriptor;  /* GLOBAL - file descriptor (s_bsd.c) */
+void init_resolver(void);
+void restart_resolver(void);
+void timeout_adns (void);
+void dns_writeable (int fd , void *ptr );
+void dns_readable (int fd , void *ptr );
+void dns_do_callbacks(void);
+void dns_select (void);
+int adns_gethost (const char *name, struct DNSQuery *req);
+int adns_getaddr (struct in_addr *addr , struct DNSQuery *req);
+void delete_adns_queries(struct DNSQuery *q);
+void do_adns_io(void);
 
-extern void get_res(void);
-extern struct DNSReply* gethost_byname(const char* name, 
-                                       const struct DNSQuery* req);
-extern struct DNSReply* gethost_byname_type(const char* name,
-                                       const struct DNSQuery* req,
-                                       int type);
-extern struct DNSReply* gethost_byaddr(const char* name, 
-                                       const struct DNSQuery* req);
-extern int             init_resolver(void);
-extern void            restart_resolver(void);
-extern time_t          timeout_resolver(time_t now);
-extern void            delete_resolver_queries(const void* vptr);
-extern unsigned long   cres_mem(struct Client* cptr);
-
-/*
- * add_local_domain - append local domain suffix to hostnames that 
- * don't contain a dot '.'
- * name - string to append to
- * len  - total length of the buffer
- * name is modified only if there is enough space in the buffer to hold
- * the suffix
- */
-extern void add_local_domain(char* name, size_t len);
-
-#endif /* INCLUDED_res_h */
-
+#endif
Index: include/s_conf.h
===================================================================
--- include/s_conf.h	(revision 183)
+++ include/s_conf.h	(working copy)
@@ -191,7 +191,7 @@
 
 extern int              read_conf_files(int cold);
 
-extern struct DNSReply* conf_dns_lookup(struct ConfItem* aconf);
+extern void             conf_dns_lookup(struct ConfItem* aconf);
 extern int              attach_conf(struct Client*, struct ConfItem *);
 extern int              attach_confs(struct Client* client, 
                                      const char* name, int statmask);
Index: include/client.h
===================================================================
--- include/client.h	(revision 183)
+++ include/client.h	(working copy)
@@ -265,7 +265,7 @@
   struct Listener*  listener;   /* listener accepted from */
   struct SLink*     confs;      /* Configuration record associated */
   unsigned short    port;       /* and the remote port# too :-) */
-  struct DNSReply*  dns_reply;  /* result returned from resolver query */
+  struct DNSQuery*  dns_query;  /* result returned from resolver query */
 #ifdef ANTI_NICK_FLOOD
   time_t            last_nick_change;
   int               number_of_nick_changes;
Index: include/msg.h
===================================================================
--- include/msg.h	(revision 183)
+++ include/msg.h	(working copy)
@@ -256,7 +256,6 @@
   { MSG_UNKLINE, m_unkline,  0, MAXPARA, 1, 0, 0, 0, 0L },
   { MSG_DLINE,   m_dline,    0, MAXPARA, 1, 0, 0, 0, 0L },
   { MSG_HASH,    m_hash,     0, MAXPARA, 1, 0, 0, 0, 0L },
-  { MSG_DNS,     m_dns,      0, MAXPARA, 1, 0, 0, 0, 0L },
   { MSG_REHASH,  m_rehash,   0, MAXPARA, 1, 0, 1, 0, 0L },
   { MSG_RESTART, m_restart,  0, MAXPARA, 1, 0, 0, 0, 0L },
   { MSG_DIE, m_die,          0, MAXPARA, 1, 0, 0, 0, 0L },
Index: adns/setup.c
===================================================================
--- adns/setup.c	(revision 0)
+++ adns/setup.c	(revision 0)
@@ -0,0 +1,673 @@
+/*
+ * setup.c: $Id: setup.c,v 1.10 2002/02/04 16:25:02 androsyn Exp $
+ *  
+ */
+/*
+ * setup.c
+ * - configuration file parsing
+ * - management of global state
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-1999 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ */
+
+#include <stdlib.h>
+#include <errno.h>
+#include <limits.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <netdb.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include "internal.h"
+
+#ifndef INADDR_LOOPBACK
+#define INADDR_LOOPBACK 0x7f000001
+#endif 
+static void readconfig(adns_state ads, const char *filename, int warnmissing);
+
+static void addserver(adns_state ads, struct in_addr addr) {
+  int i;
+  struct server *ss;
+  
+  if(addr.s_addr == 0)
+  	addr.s_addr = htonl(INADDR_LOOPBACK);	
+  
+  for (i=0; i<ads->nservers; i++) {
+    if (ads->servers[i].addr.s_addr == addr.s_addr) {
+      adns__debug(ads,-1,0,"duplicate nameserver %s ignored",inetntoa((const char *)&addr));
+      return;
+    }
+  }
+  
+  if (ads->nservers>=MAXSERVERS) {
+    adns__diag(ads,-1,0,"too many nameservers, ignoring %s",inetntoa((const char *)&addr));
+    return;
+  }
+
+  ss= ads->servers+ads->nservers;
+  ss->addr= addr;
+  ads->nservers++;
+}
+
+static void freesearchlist(adns_state ads) {
+  if (ads->nsearchlist) MyFree(*ads->searchlist);
+  MyFree(ads->searchlist);
+}
+
+static void saveerr(adns_state ads, int en) {
+  if (!ads->configerrno) ads->configerrno= en;
+}
+
+static void configparseerr(adns_state ads, const char *fn, int lno,
+			   const char *fmt, ...) {
+  va_list al;
+
+  saveerr(ads,EINVAL);
+  if (!ads->diagfile || (ads->iflags & adns_if_noerrprint)) return;
+
+  if (lno==-1) fprintf(ads->diagfile,"adns: %s: ",fn);
+  else fprintf(ads->diagfile,"adns: %s:%d: ",fn,lno);
+  va_start(al,fmt);
+  vfprintf(ads->diagfile,fmt,al);
+  va_end(al);
+  fputc('\n',ads->diagfile);
+}
+
+static int nextword(const char **bufp_io, const char **word_r, int *l_r) {
+  const char *p, *q;
+
+  p= *bufp_io;
+  while (ctype_whitespace(*p)) p++;
+  if (!*p) return 0;
+
+  q= p;
+  while (*q && !ctype_whitespace(*q)) q++;
+
+  *l_r= q-p;
+  *word_r= p;
+  *bufp_io= q;
+
+  return 1;
+}
+
+static void ccf_nameserver(adns_state ads, const char *fn, int lno, const char *buf) {
+  struct in_addr ia;
+  
+  if (!inet_aton(buf,&ia)) {
+    configparseerr(ads,fn,lno,"invalid nameserver address `%s'",buf);
+    return;
+  }
+  adns__debug(ads,-1,0,"using nameserver %s",inetntoa((const char *)&ia));
+  addserver(ads,ia);
+}
+
+static void ccf_search(adns_state ads, const char *fn, int lno, const char *buf) {
+  const char *bufp, *word;
+  char *newchars, **newptrs, **pp;
+  int count, tl, l;
+
+  if (!buf) return;
+
+  bufp= buf;
+  count= 0;
+  tl= 0;
+  while (nextword(&bufp,&word,&l)) { count++; tl += l+1; }
+
+  newptrs= MyMalloc(sizeof(char*)*count);  if (!newptrs) { saveerr(ads,errno); return; }
+  newchars= MyMalloc(tl);  if (!newchars) { saveerr(ads,errno); MyFree(newptrs); return; }
+
+  bufp= buf;
+  pp= newptrs;
+  while (nextword(&bufp,&word,&l)) {
+    *pp++= newchars;
+    memcpy(newchars,word,l);
+    newchars += l;
+    *newchars++ = 0;
+  }
+
+  freesearchlist(ads);
+  ads->nsearchlist= count;
+  ads->searchlist= newptrs;
+}
+
+static void ccf_sortlist(adns_state ads, const char *fn, int lno, const char *buf) {
+  const char *word;
+  char tbuf[200], *slash, *ep;
+  struct in_addr base, mask;
+  int l;
+  unsigned long initial, baselocal;
+
+  if (!buf) return;
+  
+  ads->nsortlist= 0;
+  while (nextword(&buf,&word,&l)) {
+    if (ads->nsortlist >= MAXSORTLIST) {
+      adns__diag(ads,-1,0,"too many sortlist entries, ignoring %.*s onwards",l,word);
+      return;
+    }
+
+    if (l >= sizeof(tbuf)) {
+      configparseerr(ads,fn,lno,"sortlist entry `%.*s' too long",l,word);
+      continue;
+    }
+    
+    memcpy(tbuf,word,l); tbuf[l]= 0;
+    slash= strchr(tbuf,'/');
+    if (slash) *slash++= 0;
+    
+    if (!inet_aton(tbuf,&base)) {
+      configparseerr(ads,fn,lno,"invalid address `%s' in sortlist",tbuf);
+      continue;
+    }
+
+    if (slash) {
+      if (strchr(slash,'.')) {
+	if (!inet_aton(slash,&mask)) {
+	  configparseerr(ads,fn,lno,"invalid mask `%s' in sortlist",slash);
+	  continue;
+	}
+	if (base.s_addr & ~mask.s_addr) {
+	  configparseerr(ads,fn,lno,
+			 "mask `%s' in sortlist overlaps address `%s'",slash,tbuf);
+	  continue;
+	}
+      } else {
+	initial= strtoul(slash,&ep,10);
+	if (*ep || initial>32) {
+	  configparseerr(ads,fn,lno,"mask length `%s' invalid",slash);
+	  continue;
+	}
+	mask.s_addr= htonl((0x0ffffffffUL) << (32-initial));
+      }
+    } else {
+      baselocal= ntohl(base.s_addr);
+      if (!baselocal & 0x080000000UL) /* class A */
+	mask.s_addr= htonl(0x0ff000000UL);
+      else if ((baselocal & 0x0c0000000UL) == 0x080000000UL)
+	mask.s_addr= htonl(0x0ffff0000UL); /* class B */
+      else if ((baselocal & 0x0f0000000UL) == 0x0e0000000UL)
+	mask.s_addr= htonl(0x0ff000000UL); /* class C */
+      else {
+	configparseerr(ads,fn,lno,
+		       "network address `%s' in sortlist is not in classed ranges,"
+		       " must specify mask explicitly", tbuf);
+	continue;
+      }
+    }
+
+    ads->sortlist[ads->nsortlist].base= base;
+    ads->sortlist[ads->nsortlist].mask= mask;
+    ads->nsortlist++;
+  }
+}
+
+static void ccf_options(adns_state ads, const char *fn, int lno, const char *buf) {
+  const char *word;
+  char *ep;
+  unsigned long v;
+  int l;
+
+  if (!buf) return;
+
+  while (nextword(&buf,&word,&l)) {
+    if (l==5 && !memcmp(word,"debug",5)) {
+      ads->iflags |= adns_if_debug;
+      continue;
+    }
+    if (l>=6 && !memcmp(word,"ndots:",6)) {
+      v= strtoul(word+6,&ep,10);
+      if (l==6 || ep != word+l || v > INT_MAX) {
+	configparseerr(ads,fn,lno,"option `%.*s' malformed or has bad value",l,word);
+	continue;
+      }
+      ads->searchndots= v;
+      continue;
+    }
+    if (l>=12 && !memcmp(word,"adns_checkc:",12)) {
+      if (!strcmp(word+12,"none")) {
+	ads->iflags &= ~adns_if_checkc_freq;
+	ads->iflags |= adns_if_checkc_entex;
+      } else if (!strcmp(word+12,"entex")) {
+	ads->iflags &= ~adns_if_checkc_freq;
+	ads->iflags |= adns_if_checkc_entex;
+      } else if (!strcmp(word+12,"freq")) {
+	ads->iflags |= adns_if_checkc_freq;
+      } else {
+	configparseerr(ads,fn,lno, "option adns_checkc has bad value `%s' "
+		       "(must be none, entex or freq", word+12);
+      }
+      continue;
+    }
+    adns__diag(ads,-1,0,"%s:%d: unknown option `%.*s'", fn,lno, l,word);
+  }
+}
+
+static void ccf_clearnss(adns_state ads, const char *fn, int lno, const char *buf) {
+  ads->nservers= 0;
+}
+
+static void ccf_include(adns_state ads, const char *fn, int lno, const char *buf) {
+  if (!*buf) {
+    configparseerr(ads,fn,lno,"`include' directive with no filename");
+    return;
+  }
+  readconfig(ads,buf,1);
+}
+
+static const struct configcommandinfo {
+  const char *name;
+  void (*fn)(adns_state ads, const char *fn, int lno, const char *buf);
+} configcommandinfos[]= {
+  { "nameserver",        ccf_nameserver  },
+  { "domain",            ccf_search      },
+  { "search",            ccf_search      },
+  { "sortlist",          ccf_sortlist    },
+  { "options",           ccf_options     },
+  { "clearnameservers",  ccf_clearnss    },
+  { "include",           ccf_include     },
+  {  0                                   }
+};
+
+typedef union {
+  FILE *file;
+  const char *text;
+} getline_ctx;
+
+static int gl_file(adns_state ads, getline_ctx *src_io, const char *filename,
+		   int lno, char *buf, int buflen) {
+  FILE *file= src_io->file;
+  int c, i;
+  char *p;
+
+  p= buf;
+  buflen--;
+  i= 0;
+    
+  for (;;) { /* loop over chars */
+    if (i == buflen) {
+      adns__diag(ads,-1,0,"%s:%d: line too long, ignored",filename,lno);
+      goto x_badline;
+    }
+    c= getc(file);
+    if (!c) {
+      adns__diag(ads,-1,0,"%s:%d: line contains nul, ignored",filename,lno);
+      goto x_badline;
+    } else if (c == '\n') {
+      break;
+    } else if (c == EOF) {
+      if (ferror(file)) {
+	saveerr(ads,errno);
+	adns__diag(ads,-1,0,"%s:%d: read error: %s",filename,lno,strerror(errno));
+	return -1;
+      }
+      if (!i) return -1;
+      break;
+    } else {
+      *p++= c;
+      i++;
+    }
+  }
+
+  *p++= 0;
+  return i;
+
+ x_badline:
+  saveerr(ads,EINVAL);
+  while ((c= getc(file)) != EOF && c != '\n');
+  return -2;
+}
+
+static int gl_text(adns_state ads, getline_ctx *src_io, const char *filename,
+		   int lno, char *buf, int buflen) {
+  const char *cp= src_io->text;
+  int l;
+
+  if (!cp || !*cp) return -1;
+
+  if (*cp == ';' || *cp == '\n') cp++;
+  l= strcspn(cp,";\n");
+  src_io->text = cp+l;
+
+  if (l >= buflen) {
+    adns__diag(ads,-1,0,"%s:%d: line too long, ignored",filename,lno);
+    saveerr(ads,EINVAL);
+    return -2;
+  }
+    
+  memcpy(buf,cp,l);
+  buf[l]= 0;
+  return l;
+}
+
+static void readconfiggeneric(adns_state ads, const char *filename,
+			      int (*getline)(adns_state ads, getline_ctx*,
+					     const char *filename, int lno,
+					     char *buf, int buflen),
+			      /* Returns >=0 for success, -1 for EOF or error
+			       * (error will have been reported), or -2 for
+			       * bad line was encountered, try again.
+			       */
+			      getline_ctx gl_ctx) {
+  char linebuf[2000], *p, *q;
+  int lno, l, dirl;
+  const struct configcommandinfo *ccip;
+
+  for (lno=1;
+       (l= getline(ads,&gl_ctx, filename,lno, linebuf,sizeof(linebuf))) != -1;
+       lno++) {
+    if (l == -2) continue;
+    while (l>0 && ctype_whitespace(linebuf[l-1])) l--;
+    linebuf[l]= 0;
+    p= linebuf;
+    while (ctype_whitespace(*p)) p++;
+    if (*p == '#' || !*p) continue;
+    q= p;
+    while (*q && !ctype_whitespace(*q)) q++;
+    dirl= q-p;
+    for (ccip=configcommandinfos;
+	 ccip->name && !(strlen(ccip->name)==dirl && !memcmp(ccip->name,p,q-p));
+	 ccip++);
+    if (!ccip->name) {
+      adns__diag(ads,-1,0,"%s:%d: unknown configuration directive `%.*s'",
+		 filename,lno,q-p,p);
+      continue;
+    }
+    while (ctype_whitespace(*q)) q++;
+    ccip->fn(ads,filename,lno,q);
+  }
+}
+
+static const char *instrum_getenv(adns_state ads, const char *envvar) {
+  const char *value;
+
+  value= getenv(envvar);
+  if (!value) adns__debug(ads,-1,0,"environment variable %s not set",envvar);
+  else adns__debug(ads,-1,0,"environment variable %s set to `%s'",envvar,value);
+  return value;
+}
+
+static void readconfig(adns_state ads, const char *filename, int warnmissing) {
+  getline_ctx gl_ctx;
+  
+  gl_ctx.file= fopen(filename,"r");
+  if (!gl_ctx.file) {
+    if (errno == ENOENT) {
+      if (warnmissing)
+	adns__debug(ads,-1,0,"configuration file `%s' does not exist",filename);
+      return;
+    }
+    saveerr(ads,errno);
+    adns__diag(ads,-1,0,"cannot open configuration file `%s': %s",
+	       filename,strerror(errno));
+    return;
+  }
+
+  readconfiggeneric(ads,filename,gl_file,gl_ctx);
+  
+  fclose(gl_ctx.file);
+}
+
+static void readconfigtext(adns_state ads, const char *text, const char *showname) {
+  getline_ctx gl_ctx;
+  
+  gl_ctx.text= text;
+  readconfiggeneric(ads,showname,gl_text,gl_ctx);
+}
+  
+static void readconfigenv(adns_state ads, const char *envvar) {
+  const char *filename;
+
+  if (ads->iflags & adns_if_noenv) {
+    adns__debug(ads,-1,0,"not checking environment variable `%s'",envvar);
+    return;
+  }
+  filename= instrum_getenv(ads,envvar);
+  if (filename) readconfig(ads,filename,1);
+}
+
+static void readconfigenvtext(adns_state ads, const char *envvar) {
+  const char *textdata;
+
+  if (ads->iflags & adns_if_noenv) {
+    adns__debug(ads,-1,0,"not checking environment variable `%s'",envvar);
+    return;
+  }
+  textdata= instrum_getenv(ads,envvar);
+  if (textdata) readconfigtext(ads,textdata,envvar);
+}
+
+
+int adns__setnonblock(adns_state ads, int fd) {
+  int r;
+  
+  r= fcntl(fd,F_GETFL,0); if (r<0) return errno;
+  r |= O_NONBLOCK;
+  r= fcntl(fd,F_SETFL,r); if (r<0) return errno;
+  return 0;
+}
+
+static int init_begin(adns_state *ads_r, adns_initflags flags, FILE *diagfile) {
+  adns_state ads;
+  
+  ads= MyMalloc(sizeof(*ads)); if (!ads) return errno;
+
+  ads->iflags= flags;
+  ads->diagfile= diagfile;
+  ads->configerrno= 0;
+  DLIST_INIT(ads->udpw);
+  DLIST_INIT(ads->tcpw);
+  DLIST_INIT(ads->childw);
+  DLIST_INIT(ads->output);
+  ads->forallnext= 0;
+  ads->nextid= 0x311f;
+  ads->udpsocket= ads->tcpsocket= -1;
+  adns__vbuf_init(&ads->tcpsend);
+  adns__vbuf_init(&ads->tcprecv);
+  ads->tcprecv_skip= 0;
+  ads->nservers= ads->nsortlist= ads->nsearchlist= ads->tcpserver= 0;
+  ads->searchndots= 1;
+  ads->tcpstate= server_disconnected;
+  timerclear(&ads->tcptimeout);
+  ads->searchlist= 0;
+
+  *ads_r= ads;
+  return 0;
+}
+
+static int init_finish(adns_state ads) {
+  struct in_addr ia;
+  int r;
+  
+  if (!ads->nservers) {
+    if (ads->diagfile && ads->iflags & adns_if_debug)
+      fprintf(ads->diagfile,"adns: no nameservers, using localhost\n");
+    ia.s_addr= htonl(INADDR_LOOPBACK);
+    addserver(ads,ia);
+  }
+  ads->udpsocket= socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
+  if (ads->udpsocket<0) { r= errno; goto x_free; }
+
+  r= adns__setnonblock(ads,ads->udpsocket);
+  if (r) { r= errno; goto x_closeudp; }
+  
+  return 0;
+
+ x_closeudp:
+  close(ads->udpsocket);
+ x_free:
+  MyFree(ads);
+  return r;
+}
+
+static void init_abort(adns_state ads) {
+  if (ads->nsearchlist) {
+    MyFree(ads->searchlist[0]);
+    MyFree(ads->searchlist);
+  }
+  MyFree(ads);
+}
+
+int adns_init(adns_state *ads_r, adns_initflags flags, FILE *diagfile) {
+  adns_state ads;
+  const char *res_options, *adns_res_options;
+  int r;
+  
+  r= init_begin(&ads, flags, diagfile ? diagfile : stderr);
+  if (r) return r;
+  
+  res_options= instrum_getenv(ads,"RES_OPTIONS");
+  adns_res_options= instrum_getenv(ads,"ADNS_RES_OPTIONS");
+  ccf_options(ads,"RES_OPTIONS",-1,res_options);
+  ccf_options(ads,"ADNS_RES_OPTIONS",-1,adns_res_options);
+
+  readconfig(ads,"/etc/resolv.conf",1);
+  readconfig(ads,"/etc/resolv-adns.conf",0);
+  readconfigenv(ads,"RES_CONF");
+  readconfigenv(ads,"ADNS_RES_CONF");
+
+  readconfigenvtext(ads,"RES_CONF_TEXT");
+  readconfigenvtext(ads,"ADNS_RES_CONF_TEXT");
+
+  ccf_options(ads,"RES_OPTIONS",-1,res_options);
+  ccf_options(ads,"ADNS_RES_OPTIONS",-1,adns_res_options);
+
+  ccf_search(ads,"LOCALDOMAIN",-1,instrum_getenv(ads,"LOCALDOMAIN"));
+  ccf_search(ads,"ADNS_LOCALDOMAIN",-1,instrum_getenv(ads,"ADNS_LOCALDOMAIN"));
+
+  if (ads->configerrno && ads->configerrno != EINVAL) {
+    r= ads->configerrno;
+    init_abort(ads);
+    return r;
+  }
+
+  r= init_finish(ads);
+  if (r) return r;
+
+  adns__consistency(ads,0,cc_entex);
+  *ads_r= ads;
+  return 0;
+}
+
+int adns_init_strcfg(adns_state *ads_r, adns_initflags flags,
+		     FILE *diagfile, const char *configtext) {
+  adns_state ads;
+  int r;
+
+  r= init_begin(&ads, flags, diagfile);  if (r) return r;
+
+  readconfigtext(ads,configtext,"<supplied configuration text>");
+  if (ads->configerrno) {
+    r= ads->configerrno;
+    init_abort(ads);
+    return r;
+  }
+
+  r= init_finish(ads);  if (r) return r;
+  adns__consistency(ads,0,cc_entex);
+  *ads_r= ads;
+  return 0;
+}
+
+
+void adns_finish(adns_state ads) {
+  adns__consistency(ads,0,cc_entex);
+  for (;;) {
+    if (ads->udpw.head) adns_cancel(ads->udpw.head);
+    else if (ads->tcpw.head) adns_cancel(ads->tcpw.head);
+    else if (ads->childw.head) adns_cancel(ads->childw.head);
+    else if (ads->output.head) adns_cancel(ads->output.head);
+    else break;
+  }
+  close(ads->udpsocket);
+  if (ads->tcpsocket >= 0) close(ads->tcpsocket);
+  adns__vbuf_free(&ads->tcpsend);
+  adns__vbuf_free(&ads->tcprecv);
+  freesearchlist(ads);
+  MyFree(ads);
+}
+
+void adns_forallqueries_begin(adns_state ads) {
+  adns__consistency(ads,0,cc_entex);
+  ads->forallnext=
+    ads->udpw.head ? ads->udpw.head :
+    ads->tcpw.head ? ads->tcpw.head :
+    ads->childw.head ? ads->childw.head :
+    ads->output.head;
+}
+  
+adns_query adns_forallqueries_next(adns_state ads, void **context_r) {
+  adns_query qu, nqu;
+
+  adns__consistency(ads,0,cc_entex);
+  nqu= ads->forallnext;
+  for (;;) {
+    qu= nqu;
+    if (!qu) return 0;
+    if (qu->next) {
+      nqu= qu->next;
+    } else if (qu == ads->udpw.tail) {
+      nqu=
+	ads->tcpw.head ? ads->tcpw.head :
+	ads->childw.head ? ads->childw.head :
+	ads->output.head;
+    } else if (qu == ads->tcpw.tail) {
+      nqu=
+	ads->childw.head ? ads->childw.head :
+	ads->output.head;
+    } else if (qu == ads->childw.tail) {
+      nqu= ads->output.head;
+    } else {
+      nqu= 0;
+    }
+    if (!qu->parent) break;
+  }
+  ads->forallnext= nqu;
+  if (context_r) *context_r= qu->ctx.ext;
+  return qu;
+}
+
+int adns__rereadconfig(adns_state ads)
+{
+  struct in_addr ia;
+  adns__consistency(ads,0,cc_entex);
+  ads->nservers = 0;
+  ads->servers[0].addr.s_addr = 0;
+#ifndef VMS
+  readconfig(ads,"/etc/resolv.conf",1);
+  readconfig(ads,"/etc/resolv-adns.conf",0);
+#else
+  readconfig(ads,"[]resolv.conf",0);
+#endif
+  if (!ads->nservers)
+  {
+      ia.s_addr= htonl(INADDR_LOOPBACK);
+      addserver(ads,ia);
+  }
+  adns__consistency(ads,0,cc_entex);
+  return 0;
+}
+
+
Index: adns/transmit.c
===================================================================
--- adns/transmit.c	(revision 0)
+++ adns/transmit.c	(revision 0)
@@ -0,0 +1,270 @@
+/*
+ * transmit.c: $Id: transmit.c,v 1.6 2003/06/24 05:30:46 ievil Exp $
+ *  
+ */
+/*
+ * transmit.c
+ * - construct queries
+ * - send queries
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ */
+
+#include <errno.h>
+
+#include <sys/types.h>
+#include <sys/uio.h>
+
+#include "internal.h"
+#include "tvarith.h"
+
+#define MKQUERY_START(vb) (rqp= (vb)->buf+(vb)->used)
+#define MKQUERY_ADDB(b) *rqp++= (b)
+#define MKQUERY_ADDW(w) (MKQUERY_ADDB(((w)>>8)&0x0ff), MKQUERY_ADDB((w)&0x0ff))
+#define MKQUERY_STOP(vb) ((vb)->used= rqp-(vb)->buf)
+
+static adns_status mkquery_header(adns_state ads, vbuf *vb, int *id_r, int qdlen) {
+  int id;
+  byte *rqp;
+  
+  if (!adns__vbuf_ensure(vb,DNS_HDRSIZE+qdlen+4)) return adns_s_nomemory;
+
+  vb->used= 0;
+  MKQUERY_START(vb);
+  
+  *id_r= id= (ads->nextid++) & 0x0ffff;
+  MKQUERY_ADDW(id);
+  MKQUERY_ADDB(0x01); /* QR=Q(0), OPCODE=QUERY(0000), !AA, !TC, RD */
+  MKQUERY_ADDB(0x00); /* !RA, Z=000, RCODE=NOERROR(0000) */
+  MKQUERY_ADDW(1); /* QDCOUNT=1 */
+  MKQUERY_ADDW(0); /* ANCOUNT=0 */
+  MKQUERY_ADDW(0); /* NSCOUNT=0 */
+  MKQUERY_ADDW(0); /* ARCOUNT=0 */
+
+  MKQUERY_STOP(vb);
+  
+  return adns_s_ok;
+}
+
+static adns_status mkquery_footer(vbuf *vb, adns_rrtype type) {
+  byte *rqp;
+
+  MKQUERY_START(vb);
+  MKQUERY_ADDW(type & adns__rrt_typemask); /* QTYPE */
+  MKQUERY_ADDW(DNS_CLASS_IN); /* QCLASS=IN */
+  MKQUERY_STOP(vb);
+  assert(vb->used <= vb->avail);
+  
+  return adns_s_ok;
+}
+
+adns_status adns__mkquery(adns_state ads, vbuf *vb, int *id_r,
+			  const char *owner, int ol,
+			  const typeinfo *typei, adns_queryflags flags) {
+  int ll, c, nbytes;
+  byte label[255], *rqp;
+  const char *p, *pe;
+  adns_status st;
+
+  st= mkquery_header(ads,vb,id_r,ol+2); if (st) return st;
+  
+  MKQUERY_START(vb);
+
+  p= owner; pe= owner+ol;
+  nbytes= 0;
+  while (p!=pe) {
+    ll= 0;
+    while (p!=pe && (c= *p++)!='.') {
+      if (c=='\\') {
+	if (!(flags & adns_qf_quoteok_query)) return adns_s_querydomaininvalid;
+	if (ctype_digit(p[0])) {
+	  if (ctype_digit(p[1]) && ctype_digit(p[2])) {
+            c  = (*p - '0') * 100;
+            p++;
+            c += (*p - '0')*10;
+            p++;
+            c += (*p - '0');
+            p++;
+/*	    c= (*p++ - '0')*100 + (*p++ - '0')*10 + (*p++ - '0'); 
+ * Bad code removed and fixed
+ */
+	    if (c >= 256) return adns_s_querydomaininvalid;
+	  } else {
+	    return adns_s_querydomaininvalid;
+	  }
+	} else if (!(c= *p++)) {
+	  return adns_s_querydomaininvalid;
+	}
+      }
+      if (!(flags & adns_qf_quoteok_query)) {
+	if (c == '-') {
+	  if (!ll) return adns_s_querydomaininvalid;
+	} else if (!ctype_alpha(c) && !ctype_digit(c)) {
+	  return adns_s_querydomaininvalid;
+	}
+      }
+      if (ll == sizeof(label)) return adns_s_querydomaininvalid;
+      label[ll++]= c;
+    }
+    if (!ll) return adns_s_querydomaininvalid;
+    if (ll > DNS_MAXLABEL) return adns_s_querydomaintoolong;
+    nbytes+= ll+1;
+    if (nbytes >= DNS_MAXDOMAIN) return adns_s_querydomaintoolong;
+    MKQUERY_ADDB(ll);
+    memcpy(rqp,label,ll); rqp+= ll;
+  }
+  MKQUERY_ADDB(0);
+
+  MKQUERY_STOP(vb);
+  
+  st= mkquery_footer(vb,typei->type);
+  
+  return adns_s_ok;
+}
+
+adns_status adns__mkquery_frdgram(adns_state ads, vbuf *vb, int *id_r,
+				  const byte *qd_dgram, int qd_dglen, int qd_begin,
+				  adns_rrtype type, adns_queryflags flags) {
+  byte *rqp;
+  findlabel_state fls;
+  int lablen, labstart;
+  adns_status st;
+
+  st= mkquery_header(ads,vb,id_r,qd_dglen); if (st) return st;
+
+  MKQUERY_START(vb);
+
+  adns__findlabel_start(&fls,ads,-1,0,qd_dgram,qd_dglen,qd_dglen,qd_begin,0);
+  for (;;) {
+    st= adns__findlabel_next(&fls,&lablen,&labstart); assert(!st);
+    if (!lablen) break;
+    assert(lablen<255);
+    MKQUERY_ADDB(lablen);
+    memcpy(rqp,qd_dgram+labstart,lablen);
+    rqp+= lablen;
+  }
+  MKQUERY_ADDB(0);
+
+  MKQUERY_STOP(vb);
+  
+  st= mkquery_footer(vb,type);
+  
+  return adns_s_ok;
+}
+
+void adns__querysend_tcp(adns_query qu, struct timeval now) {
+  byte length[2];
+  struct iovec iov[2];
+  int wr, r;
+  adns_state ads;
+
+  if (qu->ads->tcpstate != server_ok) return;
+
+  assert(qu->state == query_tcpw);
+
+  length[0]= (qu->query_dglen&0x0ff00U) >>8;
+  length[1]= (qu->query_dglen&0x0ff);
+
+  ads= qu->ads;
+  if (!adns__vbuf_ensure(&ads->tcpsend,ads->tcpsend.used+qu->query_dglen+2)) return;
+
+  qu->retries++;
+
+  /* Reset idle timeout. */
+  ads->tcptimeout.tv_sec= ads->tcptimeout.tv_usec= 0;
+
+  if (ads->tcpsend.used) {
+    wr= 0;
+  } else {
+    iov[0].iov_base= length;
+    iov[0].iov_len= 2;
+    iov[1].iov_base= qu->query_dgram;
+    iov[1].iov_len= qu->query_dglen;
+    wr= writev(qu->ads->tcpsocket,iov,2);
+    if (wr < 0) {
+      if (!(errno == EAGAIN || errno == EINTR || errno == ENOSPC ||
+	    errno == ENOBUFS || errno == ENOMEM)) {
+	adns__tcp_broken(ads,"write",strerror(errno));
+	return;
+      }
+      wr= 0;
+    }
+  }
+
+  if (wr<2) {
+    r= adns__vbuf_append(&ads->tcpsend,length,2-wr); assert(r);
+    wr= 0;
+  } else {
+    wr-= 2;
+  }
+  if (wr<qu->query_dglen) {
+    r= adns__vbuf_append(&ads->tcpsend,qu->query_dgram+wr,qu->query_dglen-wr); assert(r);
+  }
+}
+
+static void query_usetcp(adns_query qu, struct timeval now) {
+  qu->state= query_tcpw;
+  qu->timeout= now;
+  timevaladd(&qu->timeout,TCPWAITMS);
+  DLIST_LINK_TAIL(qu->ads->tcpw,qu);
+  adns__querysend_tcp(qu,now);
+  adns__tcp_tryconnect(qu->ads,now);
+}
+
+void adns__query_send(adns_query qu, struct timeval now) {
+  struct sockaddr_in servaddr;
+  int serv, r;
+  adns_state ads;
+
+  assert(qu->state == query_tosend);
+#if 0
+  if ((qu->flags & adns_qf_usevc) || (qu->query_dglen > DNS_MAXUDP)) {
+    query_usetcp(qu,now);
+    return;
+  }
+#endif
+  if (qu->retries >= UDPMAXRETRIES) {
+    adns__query_fail(qu,adns_s_timeout);
+    return;
+  }
+
+  serv= qu->udpnextserver;
+  memset(&servaddr,0,sizeof(servaddr));
+
+  ads= qu->ads;
+  servaddr.sin_family= AF_INET;
+  servaddr.sin_addr= ads->servers[serv].addr;
+  servaddr.sin_port= htons(DNS_PORT);
+  
+  r= sendto(ads->udpsocket,qu->query_dgram,qu->query_dglen,0,
+	    (const struct sockaddr*)&servaddr,sizeof(servaddr));
+  if (r<0 && errno == EMSGSIZE) { qu->retries= 0; query_usetcp(qu,now); return; }
+  if (r<0 && errno != EAGAIN) adns__warn(ads,serv,0,"sendto failed: %s",strerror(errno));
+  
+  qu->timeout= now;
+  timevaladd(&qu->timeout,UDPRETRYMS);
+  qu->udpsent |= (1<<serv);
+  qu->udpnextserver= (serv+1)%ads->nservers;
+  qu->retries++;
+  DLIST_LINK_TAIL(ads->udpw,qu);
+}
Index: adns/Makefile.in
===================================================================
--- adns/Makefile.in	(revision 0)
+++ adns/Makefile.in	(revision 0)
@@ -0,0 +1,547 @@
+# Makefile.in generated by automake 1.9.5 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+# $Id$
+
+SOURCES = $(libadns_a_SOURCES)
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = adns
+DIST_COMMON = README $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	COPYING
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/autoconf/hyperion-c.m4 \
+	$(top_srcdir)/autoconf/hyperion-libc.m4 \
+	$(top_srcdir)/autoconf/hyperion-socket.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/build-misc/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/include/setup.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libadns_a_AR = $(AR) $(ARFLAGS)
+libadns_a_LIBADD =
+am_libadns_a_OBJECTS = libadns_a-check.$(OBJEXT) \
+	libadns_a-event.$(OBJEXT) libadns_a-general.$(OBJEXT) \
+	libadns_a-parse.$(OBJEXT) libadns_a-query.$(OBJEXT) \
+	libadns_a-reply.$(OBJEXT) libadns_a-poll.$(OBJEXT) \
+	libadns_a-setup.$(OBJEXT) libadns_a-transmit.$(OBJEXT) \
+	libadns_a-types.$(OBJEXT)
+libadns_a_OBJECTS = $(am_libadns_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)/include
+depcomp = $(SHELL) $(top_srcdir)/build-misc/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libadns_a_SOURCES)
+DIST_SOURCES = $(libadns_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOCUMENTATION_FALSE = @DOCUMENTATION_FALSE@
+DOCUMENTATION_TRUE = @DOCUMENTATION_TRUE@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+libadns_a_CFLAGS = -I../libircd -I.
+libadns_a_SOURCES = check.c event.c general.c parse.c query.c reply.c poll.c setup.c transmit.c types.c
+noinst_LIBRARIES = libadns.a
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  adns/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  adns/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libadns.a: $(libadns_a_OBJECTS) $(libadns_a_DEPENDENCIES) 
+	-rm -f libadns.a
+	$(libadns_a_AR) libadns.a $(libadns_a_OBJECTS) $(libadns_a_LIBADD)
+	$(RANLIB) libadns.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libadns_a-check.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libadns_a-event.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libadns_a-general.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libadns_a-parse.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libadns_a-poll.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libadns_a-query.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libadns_a-reply.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libadns_a-setup.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libadns_a-transmit.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libadns_a-types.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+libadns_a-check.o: check.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-check.o -MD -MP -MF "$(DEPDIR)/libadns_a-check.Tpo" -c -o libadns_a-check.o `test -f 'check.c' || echo '$(srcdir)/'`check.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-check.Tpo" "$(DEPDIR)/libadns_a-check.Po"; else rm -f "$(DEPDIR)/libadns_a-check.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='check.c' object='libadns_a-check.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-check.o `test -f 'check.c' || echo '$(srcdir)/'`check.c
+
+libadns_a-check.obj: check.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-check.obj -MD -MP -MF "$(DEPDIR)/libadns_a-check.Tpo" -c -o libadns_a-check.obj `if test -f 'check.c'; then $(CYGPATH_W) 'check.c'; else $(CYGPATH_W) '$(srcdir)/check.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-check.Tpo" "$(DEPDIR)/libadns_a-check.Po"; else rm -f "$(DEPDIR)/libadns_a-check.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='check.c' object='libadns_a-check.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-check.obj `if test -f 'check.c'; then $(CYGPATH_W) 'check.c'; else $(CYGPATH_W) '$(srcdir)/check.c'; fi`
+
+libadns_a-event.o: event.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-event.o -MD -MP -MF "$(DEPDIR)/libadns_a-event.Tpo" -c -o libadns_a-event.o `test -f 'event.c' || echo '$(srcdir)/'`event.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-event.Tpo" "$(DEPDIR)/libadns_a-event.Po"; else rm -f "$(DEPDIR)/libadns_a-event.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='event.c' object='libadns_a-event.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-event.o `test -f 'event.c' || echo '$(srcdir)/'`event.c
+
+libadns_a-event.obj: event.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-event.obj -MD -MP -MF "$(DEPDIR)/libadns_a-event.Tpo" -c -o libadns_a-event.obj `if test -f 'event.c'; then $(CYGPATH_W) 'event.c'; else $(CYGPATH_W) '$(srcdir)/event.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-event.Tpo" "$(DEPDIR)/libadns_a-event.Po"; else rm -f "$(DEPDIR)/libadns_a-event.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='event.c' object='libadns_a-event.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-event.obj `if test -f 'event.c'; then $(CYGPATH_W) 'event.c'; else $(CYGPATH_W) '$(srcdir)/event.c'; fi`
+
+libadns_a-general.o: general.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-general.o -MD -MP -MF "$(DEPDIR)/libadns_a-general.Tpo" -c -o libadns_a-general.o `test -f 'general.c' || echo '$(srcdir)/'`general.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-general.Tpo" "$(DEPDIR)/libadns_a-general.Po"; else rm -f "$(DEPDIR)/libadns_a-general.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='general.c' object='libadns_a-general.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-general.o `test -f 'general.c' || echo '$(srcdir)/'`general.c
+
+libadns_a-general.obj: general.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-general.obj -MD -MP -MF "$(DEPDIR)/libadns_a-general.Tpo" -c -o libadns_a-general.obj `if test -f 'general.c'; then $(CYGPATH_W) 'general.c'; else $(CYGPATH_W) '$(srcdir)/general.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-general.Tpo" "$(DEPDIR)/libadns_a-general.Po"; else rm -f "$(DEPDIR)/libadns_a-general.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='general.c' object='libadns_a-general.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-general.obj `if test -f 'general.c'; then $(CYGPATH_W) 'general.c'; else $(CYGPATH_W) '$(srcdir)/general.c'; fi`
+
+libadns_a-parse.o: parse.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-parse.o -MD -MP -MF "$(DEPDIR)/libadns_a-parse.Tpo" -c -o libadns_a-parse.o `test -f 'parse.c' || echo '$(srcdir)/'`parse.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-parse.Tpo" "$(DEPDIR)/libadns_a-parse.Po"; else rm -f "$(DEPDIR)/libadns_a-parse.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='parse.c' object='libadns_a-parse.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-parse.o `test -f 'parse.c' || echo '$(srcdir)/'`parse.c
+
+libadns_a-parse.obj: parse.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-parse.obj -MD -MP -MF "$(DEPDIR)/libadns_a-parse.Tpo" -c -o libadns_a-parse.obj `if test -f 'parse.c'; then $(CYGPATH_W) 'parse.c'; else $(CYGPATH_W) '$(srcdir)/parse.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-parse.Tpo" "$(DEPDIR)/libadns_a-parse.Po"; else rm -f "$(DEPDIR)/libadns_a-parse.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='parse.c' object='libadns_a-parse.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-parse.obj `if test -f 'parse.c'; then $(CYGPATH_W) 'parse.c'; else $(CYGPATH_W) '$(srcdir)/parse.c'; fi`
+
+libadns_a-query.o: query.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-query.o -MD -MP -MF "$(DEPDIR)/libadns_a-query.Tpo" -c -o libadns_a-query.o `test -f 'query.c' || echo '$(srcdir)/'`query.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-query.Tpo" "$(DEPDIR)/libadns_a-query.Po"; else rm -f "$(DEPDIR)/libadns_a-query.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='query.c' object='libadns_a-query.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-query.o `test -f 'query.c' || echo '$(srcdir)/'`query.c
+
+libadns_a-query.obj: query.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-query.obj -MD -MP -MF "$(DEPDIR)/libadns_a-query.Tpo" -c -o libadns_a-query.obj `if test -f 'query.c'; then $(CYGPATH_W) 'query.c'; else $(CYGPATH_W) '$(srcdir)/query.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-query.Tpo" "$(DEPDIR)/libadns_a-query.Po"; else rm -f "$(DEPDIR)/libadns_a-query.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='query.c' object='libadns_a-query.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-query.obj `if test -f 'query.c'; then $(CYGPATH_W) 'query.c'; else $(CYGPATH_W) '$(srcdir)/query.c'; fi`
+
+libadns_a-reply.o: reply.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-reply.o -MD -MP -MF "$(DEPDIR)/libadns_a-reply.Tpo" -c -o libadns_a-reply.o `test -f 'reply.c' || echo '$(srcdir)/'`reply.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-reply.Tpo" "$(DEPDIR)/libadns_a-reply.Po"; else rm -f "$(DEPDIR)/libadns_a-reply.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='reply.c' object='libadns_a-reply.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-reply.o `test -f 'reply.c' || echo '$(srcdir)/'`reply.c
+
+libadns_a-reply.obj: reply.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-reply.obj -MD -MP -MF "$(DEPDIR)/libadns_a-reply.Tpo" -c -o libadns_a-reply.obj `if test -f 'reply.c'; then $(CYGPATH_W) 'reply.c'; else $(CYGPATH_W) '$(srcdir)/reply.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-reply.Tpo" "$(DEPDIR)/libadns_a-reply.Po"; else rm -f "$(DEPDIR)/libadns_a-reply.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='reply.c' object='libadns_a-reply.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-reply.obj `if test -f 'reply.c'; then $(CYGPATH_W) 'reply.c'; else $(CYGPATH_W) '$(srcdir)/reply.c'; fi`
+
+libadns_a-poll.o: poll.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-poll.o -MD -MP -MF "$(DEPDIR)/libadns_a-poll.Tpo" -c -o libadns_a-poll.o `test -f 'poll.c' || echo '$(srcdir)/'`poll.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-poll.Tpo" "$(DEPDIR)/libadns_a-poll.Po"; else rm -f "$(DEPDIR)/libadns_a-poll.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='poll.c' object='libadns_a-poll.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-poll.o `test -f 'poll.c' || echo '$(srcdir)/'`poll.c
+
+libadns_a-poll.obj: poll.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-poll.obj -MD -MP -MF "$(DEPDIR)/libadns_a-poll.Tpo" -c -o libadns_a-poll.obj `if test -f 'poll.c'; then $(CYGPATH_W) 'poll.c'; else $(CYGPATH_W) '$(srcdir)/poll.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-poll.Tpo" "$(DEPDIR)/libadns_a-poll.Po"; else rm -f "$(DEPDIR)/libadns_a-poll.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='poll.c' object='libadns_a-poll.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-poll.obj `if test -f 'poll.c'; then $(CYGPATH_W) 'poll.c'; else $(CYGPATH_W) '$(srcdir)/poll.c'; fi`
+
+libadns_a-setup.o: setup.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-setup.o -MD -MP -MF "$(DEPDIR)/libadns_a-setup.Tpo" -c -o libadns_a-setup.o `test -f 'setup.c' || echo '$(srcdir)/'`setup.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-setup.Tpo" "$(DEPDIR)/libadns_a-setup.Po"; else rm -f "$(DEPDIR)/libadns_a-setup.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='setup.c' object='libadns_a-setup.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-setup.o `test -f 'setup.c' || echo '$(srcdir)/'`setup.c
+
+libadns_a-setup.obj: setup.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-setup.obj -MD -MP -MF "$(DEPDIR)/libadns_a-setup.Tpo" -c -o libadns_a-setup.obj `if test -f 'setup.c'; then $(CYGPATH_W) 'setup.c'; else $(CYGPATH_W) '$(srcdir)/setup.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-setup.Tpo" "$(DEPDIR)/libadns_a-setup.Po"; else rm -f "$(DEPDIR)/libadns_a-setup.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='setup.c' object='libadns_a-setup.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-setup.obj `if test -f 'setup.c'; then $(CYGPATH_W) 'setup.c'; else $(CYGPATH_W) '$(srcdir)/setup.c'; fi`
+
+libadns_a-transmit.o: transmit.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-transmit.o -MD -MP -MF "$(DEPDIR)/libadns_a-transmit.Tpo" -c -o libadns_a-transmit.o `test -f 'transmit.c' || echo '$(srcdir)/'`transmit.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-transmit.Tpo" "$(DEPDIR)/libadns_a-transmit.Po"; else rm -f "$(DEPDIR)/libadns_a-transmit.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='transmit.c' object='libadns_a-transmit.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-transmit.o `test -f 'transmit.c' || echo '$(srcdir)/'`transmit.c
+
+libadns_a-transmit.obj: transmit.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-transmit.obj -MD -MP -MF "$(DEPDIR)/libadns_a-transmit.Tpo" -c -o libadns_a-transmit.obj `if test -f 'transmit.c'; then $(CYGPATH_W) 'transmit.c'; else $(CYGPATH_W) '$(srcdir)/transmit.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-transmit.Tpo" "$(DEPDIR)/libadns_a-transmit.Po"; else rm -f "$(DEPDIR)/libadns_a-transmit.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='transmit.c' object='libadns_a-transmit.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-transmit.obj `if test -f 'transmit.c'; then $(CYGPATH_W) 'transmit.c'; else $(CYGPATH_W) '$(srcdir)/transmit.c'; fi`
+
+libadns_a-types.o: types.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-types.o -MD -MP -MF "$(DEPDIR)/libadns_a-types.Tpo" -c -o libadns_a-types.o `test -f 'types.c' || echo '$(srcdir)/'`types.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-types.Tpo" "$(DEPDIR)/libadns_a-types.Po"; else rm -f "$(DEPDIR)/libadns_a-types.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='types.c' object='libadns_a-types.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-types.o `test -f 'types.c' || echo '$(srcdir)/'`types.c
+
+libadns_a-types.obj: types.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -MT libadns_a-types.obj -MD -MP -MF "$(DEPDIR)/libadns_a-types.Tpo" -c -o libadns_a-types.obj `if test -f 'types.c'; then $(CYGPATH_W) 'types.c'; else $(CYGPATH_W) '$(srcdir)/types.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libadns_a-types.Tpo" "$(DEPDIR)/libadns_a-types.Po"; else rm -f "$(DEPDIR)/libadns_a-types.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='types.c' object='libadns_a-types.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libadns_a_CFLAGS) $(CFLAGS) -c -o libadns_a-types.obj `if test -f 'types.c'; then $(CYGPATH_W) 'types.c'; else $(CYGPATH_W) '$(srcdir)/types.c'; fi`
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: adns/types.c
===================================================================
--- adns/types.c	(revision 0)
+++ adns/types.c	(revision 0)
@@ -0,0 +1,1038 @@
+/*
+ * types.c: $Id: types.c,v 1.4 2001/12/04 16:12:11 androsyn Exp $
+ *  
+ */
+/*
+ * types.c
+ * - RR-type-specific code, and the machinery to call it
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-1999 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ */
+
+#include <stdlib.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include "internal.h"
+
+#define R_NOMEM           return adns_s_nomemory
+#define CSP_ADDSTR(s)     do { if (!adns__vbuf_appendstr(vb,(s))) R_NOMEM; } while (0)
+
+/*
+ * order of sections:
+ *
+ * _string                    (pap)
+ * _textdata, _qstring        (csp)
+ * _str                       (mf,cs)
+ * _intstr                    (mf,csp,cs)
+ * _manyistr                  (mf,cs)
+ * _txt                       (pa)
+ * _inaddr                    (pa,dip,di)
+ * _addr                      (pa,di,csp,cs)
+ * _domain                    (pap)
+ * _host_raw                  (pa)
+ * _hostaddr                  (pap,pa,dip,di,mfp,mf,csp,cs +pap_findaddrs)
+ * _mx_raw                    (pa,di)
+ * _mx                        (pa,di)
+ * _inthostaddr               (mf,cs)
+ * _ptr                       (pa)
+ * _strpair                   (mf,cs)
+ * _intstrpair                (mf,cs)
+ * _hinfo                     (pa)
+ * _mailbox                   (pap +pap_mailbox822)
+ * _rp                        (pa)
+ * _soa                       (pa,mf,cs)
+ * _flat                      (mf)
+ *
+ * within each section:
+ *    pap_*
+ *    pa_*
+ *    dip_*
+ *    di_*
+ *    mfp_*
+ *    mf_*
+ *    csp_*
+ *    cs_*
+ */
+
+/*
+ * _qstring               (pap,csp)
+ */
+
+static adns_status pap_qstring(const parseinfo *pai, int *cbyte_io, int max,
+			      int *len_r, char **str_r) {
+  /* Neither len_r nor str_r may be null.
+   * End of datagram (overrun) is indicated by returning adns_s_invaliddata;
+   */
+  const byte *dgram= pai->dgram;
+  int l, cbyte;
+  char *str;
+
+  cbyte= *cbyte_io;
+
+  if (cbyte >= max) return adns_s_invaliddata;
+  GET_B(cbyte,l);
+  if (cbyte+l > max) return adns_s_invaliddata;
+  
+  str= adns__alloc_interim(pai->qu, l+1);
+  if (!str) R_NOMEM;
+  
+  str[l]= 0;
+  memcpy(str,dgram+cbyte,l);
+
+  *len_r= l;
+  *str_r= str;
+  *cbyte_io= cbyte+l;
+  
+  return adns_s_ok;
+}
+
+static adns_status csp_qstring(vbuf *vb, const char *dp, int len) {
+  unsigned char ch;
+  char buf[10];
+  int cn;
+
+  CSP_ADDSTR("\"");
+  for (cn=0; cn<len; cn++) {
+    ch= *dp++;
+    if (ch == '\\') {
+      CSP_ADDSTR("\\\\");
+    } else if (ch == '"') {
+      CSP_ADDSTR("\\\"");
+    } else if (ch >= 32 && ch <= 126) {
+      if (!adns__vbuf_append(vb,&ch,1)) R_NOMEM;
+    } else {
+      sprintf(buf,"\\x%02x",ch);
+      CSP_ADDSTR(buf);
+    }
+  }
+  CSP_ADDSTR("\"");
+  
+  return adns_s_ok;
+}
+
+/*
+ * _str  (mf)
+ */
+
+static void mf_str(adns_query qu, void *datap) {
+  char **rrp= datap;
+
+  adns__makefinal_str(qu,rrp);
+}
+
+/*
+ * _intstr  (mf)
+ */
+
+static void mf_intstr(adns_query qu, void *datap) {
+  adns_rr_intstr *rrp= datap;
+
+  adns__makefinal_str(qu,&rrp->str);
+}
+
+/*
+ * _manyistr   (mf)
+ */
+
+static void mf_manyistr(adns_query qu, void *datap) {
+  adns_rr_intstr **rrp= datap;
+  adns_rr_intstr *te, *table;
+  void *tablev;
+  int tc;
+
+  for (tc=0, te= *rrp; te->i >= 0; te++, tc++);
+  tablev= *rrp;
+  adns__makefinal_block(qu,&tablev,sizeof(*te)*(tc+1));
+  *rrp= table= tablev;
+  for (te= *rrp; te->i >= 0; te++)
+    adns__makefinal_str(qu,&te->str);
+}
+
+/*
+ * _txt   (pa,cs)
+ */
+
+static adns_status pa_txt(const parseinfo *pai, int cbyte, int max, void *datap) {
+  adns_rr_intstr **rrp= datap, *table, *te;
+  const byte *dgram= pai->dgram;
+  int ti, tc, l, startbyte;
+  adns_status st;
+
+  startbyte= cbyte;
+  if (cbyte >= max) return adns_s_invaliddata;
+  tc= 0;
+  while (cbyte < max) {
+    GET_B(cbyte,l);
+    cbyte+= l;
+    tc++;
+  }
+  if (cbyte != max || !tc) return adns_s_invaliddata;
+
+  table= adns__alloc_interim(pai->qu,sizeof(*table)*(tc+1));
+  if (!table) R_NOMEM;
+
+  for (cbyte=startbyte, ti=0, te=table; ti<tc; ti++, te++) {
+    st= pap_qstring(pai, &cbyte, max, &te->i, &te->str);
+    if (st) return st;
+  }
+  assert(cbyte == max);
+
+  te->i= -1;
+  te->str= 0;
+  
+  *rrp= table;
+  return adns_s_ok;
+}
+
+static adns_status cs_txt(vbuf *vb, const void *datap) {
+  const adns_rr_intstr *const *rrp= datap;
+  const adns_rr_intstr *current;
+  adns_status st;
+  int spc;
+
+  for (current= *rrp, spc=0;  current->i >= 0;  current++, spc=1) {
+    if (spc) CSP_ADDSTR(" ");
+    st= csp_qstring(vb,current->str,current->i); if (st) return st;
+  }
+  return adns_s_ok;
+}
+
+/*
+ * _hinfo   (cs)
+ */
+
+static adns_status cs_hinfo(vbuf *vb, const void *datap) {
+  const adns_rr_intstrpair *rrp= datap;
+  adns_status st;
+
+  st= csp_qstring(vb,rrp->array[0].str,rrp->array[0].i);  if (st) return st;
+  CSP_ADDSTR(" ");
+  st= csp_qstring(vb,rrp->array[1].str,rrp->array[1].i);  if (st) return st;
+  return adns_s_ok;
+}
+
+/*
+ * _inaddr   (pa,dip,di)
+ */
+
+static adns_status pa_inaddr(const parseinfo *pai, int cbyte, int max, void *datap) {
+  struct in_addr *storeto= datap;
+  
+  if (max-cbyte != 4) return adns_s_invaliddata;
+  memcpy(storeto, pai->dgram + cbyte, 4);
+  return adns_s_ok;
+}
+
+static int search_sortlist(adns_state ads, struct in_addr ad) {
+  const struct sortlist *slp;
+  int i;
+  
+  for (i=0, slp=ads->sortlist;
+       i<ads->nsortlist && !((ad.s_addr & slp->mask.s_addr) == slp->base.s_addr);
+       i++, slp++);
+  return i;
+}
+
+static int dip_inaddr(adns_state ads, struct in_addr a, struct in_addr b) {
+  int ai, bi;
+  
+  if (!ads->nsortlist) return 0;
+
+  ai= search_sortlist(ads,a);
+  bi= search_sortlist(ads,b);
+  return bi<ai;
+}
+
+static int di_inaddr(adns_state ads, const void *datap_a, const void *datap_b) {
+  const struct in_addr *ap= datap_a, *bp= datap_b;
+
+  return dip_inaddr(ads,*ap,*bp);
+}
+
+static adns_status cs_inaddr(vbuf *vb, const void *datap) {
+  const struct in_addr *rrp= datap, rr= *rrp;
+  const char *ia;
+
+  ia= inet_ntoa(rr); assert(ia);
+  CSP_ADDSTR(ia);
+  return adns_s_ok;
+}
+
+/*
+ * _addr   (pa,di,csp,cs)
+ */
+
+static adns_status pa_addr(const parseinfo *pai, int cbyte, int max, void *datap) {
+  adns_rr_addr *storeto= datap;
+  const byte *dgram= pai->dgram;
+
+  if (max-cbyte != 4) return adns_s_invaliddata;
+  storeto->len= sizeof(storeto->addr.inet);
+  memset(&storeto->addr,0,sizeof(storeto->addr.inet));
+  storeto->addr.inet.sin_family= AF_INET;
+  memcpy(&storeto->addr.inet.sin_addr,dgram+cbyte,4);
+  return adns_s_ok;
+}
+
+static int di_addr(adns_state ads, const void *datap_a, const void *datap_b) {
+  const adns_rr_addr *ap= datap_a, *bp= datap_b;
+
+  assert(ap->addr.sa.sa_family == AF_INET);
+  return dip_inaddr(ads, ap->addr.inet.sin_addr, bp->addr.inet.sin_addr);
+}
+
+static int div_addr(void *context, const void *datap_a, const void *datap_b) {
+  const adns_state ads= context;
+
+  return di_addr(ads, datap_a, datap_b);
+}		     
+
+static adns_status csp_addr(vbuf *vb, const adns_rr_addr *rrp) {
+  const char *ia;
+  static char buf[30];
+
+  switch (rrp->addr.inet.sin_family) {
+  case AF_INET:
+    CSP_ADDSTR("INET ");
+    ia= inet_ntoa(rrp->addr.inet.sin_addr); assert(ia);
+    CSP_ADDSTR(ia);
+    break;
+  default:
+    sprintf(buf,"AF=%u",rrp->addr.sa.sa_family);
+    CSP_ADDSTR(buf);
+    break;
+  }
+  return adns_s_ok;
+}
+
+static adns_status cs_addr(vbuf *vb, const void *datap) {
+  const adns_rr_addr *rrp= datap;
+
+  return csp_addr(vb,rrp);
+}
+
+/*
+ * _domain      (pap,csp,cs)
+ * _dom_raw     (pa)
+ */
+
+static adns_status pap_domain(const parseinfo *pai, int *cbyte_io, int max,
+			      char **domain_r, parsedomain_flags flags) {
+  adns_status st;
+  char *dm;
+  
+  st= adns__parse_domain(pai->qu->ads, pai->serv, pai->qu, &pai->qu->vb, flags,
+			 pai->dgram,pai->dglen, cbyte_io, max);
+  if (st) return st;
+  if (!pai->qu->vb.used) return adns_s_invaliddata;
+
+  dm= adns__alloc_interim(pai->qu, pai->qu->vb.used+1);
+  if (!dm) R_NOMEM;
+
+  dm[pai->qu->vb.used]= 0;
+  memcpy(dm,pai->qu->vb.buf,pai->qu->vb.used);
+  
+  *domain_r= dm;
+  return adns_s_ok;
+}
+
+static adns_status csp_domain(vbuf *vb, const char *domain) {
+  CSP_ADDSTR(domain);
+  if (!*domain) CSP_ADDSTR(".");
+  return adns_s_ok;
+}
+
+static adns_status cs_domain(vbuf *vb, const void *datap) {
+  const char *const *domainp= datap;
+  return csp_domain(vb,*domainp);
+}
+
+static adns_status pa_dom_raw(const parseinfo *pai, int cbyte, int max, void *datap) {
+  char **rrp= datap;
+  adns_status st;
+
+  st= pap_domain(pai, &cbyte, max, rrp, pdf_quoteok);
+  if (st) return st;
+  
+  if (cbyte != max) return adns_s_invaliddata;
+  return adns_s_ok;
+}
+
+/*
+ * _host_raw   (pa)
+ */
+
+static adns_status pa_host_raw(const parseinfo *pai, int cbyte, int max, void *datap) {
+  char **rrp= datap;
+  adns_status st;
+
+  st= pap_domain(pai, &cbyte, max, rrp,
+		 pai->qu->flags & adns_qf_quoteok_anshost ? pdf_quoteok : 0);
+  if (st) return st;
+  
+  if (cbyte != max) return adns_s_invaliddata;
+  return adns_s_ok;
+}
+
+/*
+ * _hostaddr   (pap,pa,dip,di,mfp,mf,csp,cs +icb_hostaddr, pap_findaddrs)
+ */
+
+static adns_status pap_findaddrs(const parseinfo *pai, adns_rr_hostaddr *ha,
+				 int *cbyte_io, int count, int dmstart) {
+  int rri, naddrs;
+  int type, class, rdlen, rdstart, ownermatched;
+  unsigned long ttl;
+  adns_status st;
+  
+  for (rri=0, naddrs=-1; rri<count; rri++) {
+    st= adns__findrr_anychk(pai->qu, pai->serv, pai->dgram, pai->dglen, cbyte_io,
+			    &type, &class, &ttl, &rdlen, &rdstart,
+			    pai->dgram, pai->dglen, dmstart, &ownermatched);
+    if (st) return st;
+    if (!ownermatched || class != DNS_CLASS_IN || type != adns_r_a) {
+      if (naddrs>0) break; else continue;
+    }
+    if (naddrs == -1) {
+      naddrs= 0;
+    }
+    if (!adns__vbuf_ensure(&pai->qu->vb, (naddrs+1)*sizeof(adns_rr_addr))) R_NOMEM;
+    adns__update_expires(pai->qu,ttl,pai->now);
+    st= pa_addr(pai, rdstart,rdstart+rdlen,
+		pai->qu->vb.buf + naddrs*sizeof(adns_rr_addr));
+    if (st) return st;
+    naddrs++;
+  }
+  if (naddrs >= 0) {
+    ha->addrs= adns__alloc_interim(pai->qu, naddrs*sizeof(adns_rr_addr));
+    if (!ha->addrs) R_NOMEM;
+    memcpy(ha->addrs, pai->qu->vb.buf, naddrs*sizeof(adns_rr_addr));
+    ha->naddrs= naddrs;
+    ha->astatus= adns_s_ok;
+
+    adns__isort(ha->addrs, naddrs, sizeof(adns_rr_addr), pai->qu->vb.buf,
+		div_addr, pai->ads);
+  }
+  return adns_s_ok;
+}
+
+static void icb_hostaddr(adns_query parent, adns_query child) {
+  adns_answer *cans= child->answer;
+  adns_rr_hostaddr *rrp= child->ctx.info.hostaddr;
+  adns_state ads= parent->ads;
+  adns_status st;
+
+  st= cans->status;
+  rrp->astatus= st;
+  rrp->naddrs= (st>0 && st<=adns_s_max_tempfail) ? -1 : cans->nrrs;
+  rrp->addrs= cans->rrs.addr;
+  adns__transfer_interim(child, parent, rrp->addrs, rrp->naddrs*sizeof(adns_rr_addr));
+
+  if (parent->children.head) {
+    DLIST_LINK_TAIL(ads->childw,parent);
+  } else {
+    adns__query_done(parent);
+  }
+}
+
+static adns_status pap_hostaddr(const parseinfo *pai, int *cbyte_io,
+				int max, adns_rr_hostaddr *rrp) {
+  adns_status st;
+  int dmstart, cbyte;
+  qcontext ctx;
+  int id;
+  adns_query nqu;
+  adns_queryflags nflags;
+
+  dmstart= cbyte= *cbyte_io;
+  st= pap_domain(pai, &cbyte, max, &rrp->host,
+		 pai->qu->flags & adns_qf_quoteok_anshost ? pdf_quoteok : 0);
+  if (st) return st;
+  *cbyte_io= cbyte;
+
+  rrp->astatus= adns_s_ok;
+  rrp->naddrs= -1;
+  rrp->addrs= 0;
+
+  cbyte= pai->nsstart;
+
+  st= pap_findaddrs(pai, rrp, &cbyte, pai->nscount, dmstart);
+  if (st) return st;
+  if (rrp->naddrs != -1) return adns_s_ok;
+
+  st= pap_findaddrs(pai, rrp, &cbyte, pai->arcount, dmstart);
+  if (st) return st;
+  if (rrp->naddrs != -1) return adns_s_ok;
+
+  st= adns__mkquery_frdgram(pai->ads, &pai->qu->vb, &id,
+			    pai->dgram, pai->dglen, dmstart,
+			    adns_r_addr, adns_qf_quoteok_query);
+  if (st) return st;
+
+  ctx.ext= 0;
+  ctx.callback= icb_hostaddr;
+  ctx.info.hostaddr= rrp;
+  
+  nflags= adns_qf_quoteok_query;
+  if (!(pai->qu->flags & adns_qf_cname_loose)) nflags |= adns_qf_cname_forbid;
+  
+  st= adns__internal_submit(pai->ads, &nqu, adns__findtype(adns_r_addr),
+			    &pai->qu->vb, id, nflags, pai->now, &ctx);
+  if (st) return st;
+
+  nqu->parent= pai->qu;
+  DLIST_LINK_TAIL_PART(pai->qu->children,nqu,siblings.);
+
+  return adns_s_ok;
+}
+
+static adns_status pa_hostaddr(const parseinfo *pai, int cbyte, int max, void *datap) {
+  adns_rr_hostaddr *rrp= datap;
+  adns_status st;
+
+  st= pap_hostaddr(pai, &cbyte, max, rrp);
+  if (st) return st;
+  if (cbyte != max) return adns_s_invaliddata;
+
+  return adns_s_ok;
+}
+
+static int dip_hostaddr(adns_state ads, const adns_rr_hostaddr *ap, const adns_rr_hostaddr *bp) {
+  if (ap->astatus != bp->astatus) return ap->astatus;
+  if (ap->astatus) return 0;
+
+  assert(ap->addrs[0].addr.sa.sa_family == AF_INET);
+  assert(bp->addrs[0].addr.sa.sa_family == AF_INET);
+  return dip_inaddr(ads,
+		    ap->addrs[0].addr.inet.sin_addr,
+		    bp->addrs[0].addr.inet.sin_addr);
+}
+
+static int di_hostaddr(adns_state ads, const void *datap_a, const void *datap_b) {
+  const adns_rr_hostaddr *ap= datap_a, *bp= datap_b;
+
+  return dip_hostaddr(ads, ap,bp);
+}
+
+static void mfp_hostaddr(adns_query qu, adns_rr_hostaddr *rrp) {
+  void *tablev;
+
+  adns__makefinal_str(qu,&rrp->host);
+  tablev= rrp->addrs;
+  adns__makefinal_block(qu, &tablev, rrp->naddrs*sizeof(*rrp->addrs));
+  rrp->addrs= tablev;
+}
+
+static void mf_hostaddr(adns_query qu, void *datap) {
+  adns_rr_hostaddr *rrp= datap;
+
+  mfp_hostaddr(qu,rrp);
+}
+
+static adns_status csp_hostaddr(vbuf *vb, const adns_rr_hostaddr *rrp) {
+  const char *errstr;
+  adns_status st;
+  char buf[20];
+  int i;
+
+  st= csp_domain(vb,rrp->host);  if (st) return st;
+
+  CSP_ADDSTR(" ");
+  CSP_ADDSTR(adns_errtypeabbrev(rrp->astatus));
+
+  sprintf(buf," %d ",rrp->astatus);
+  CSP_ADDSTR(buf);
+
+  CSP_ADDSTR(adns_errabbrev(rrp->astatus));
+  CSP_ADDSTR(" ");
+
+  errstr= adns_strerror(rrp->astatus);
+  st= csp_qstring(vb,errstr,strlen(errstr));  if (st) return st;
+  
+  if (rrp->naddrs >= 0) {
+    CSP_ADDSTR(" (");
+    for (i=0; i<rrp->naddrs; i++) {
+      CSP_ADDSTR(" ");
+      st= csp_addr(vb,&rrp->addrs[i]);
+    }
+    CSP_ADDSTR(" )");
+  } else {
+    CSP_ADDSTR(" ?");
+  }
+  return adns_s_ok;
+}
+
+static adns_status cs_hostaddr(vbuf *vb, const void *datap) {
+  const adns_rr_hostaddr *rrp= datap;
+
+  return csp_hostaddr(vb,rrp);
+}
+
+/*
+ * _mx_raw   (pa,di)
+ */
+
+static adns_status pa_mx_raw(const parseinfo *pai, int cbyte, int max, void *datap) {
+  const byte *dgram= pai->dgram;
+  adns_rr_intstr *rrp= datap;
+  adns_status st;
+  int pref;
+
+  if (cbyte+2 > max) return adns_s_invaliddata;
+  GET_W(cbyte,pref);
+  rrp->i= pref;
+  st= pap_domain(pai, &cbyte, max, &rrp->str,
+		 pai->qu->flags & adns_qf_quoteok_anshost ? pdf_quoteok : 0);
+  if (st) return st;
+  
+  if (cbyte != max) return adns_s_invaliddata;
+  return adns_s_ok;
+}
+
+static int di_mx_raw(adns_state ads, const void *datap_a, const void *datap_b) {
+  const adns_rr_intstr *ap= datap_a, *bp= datap_b;
+
+  if (ap->i < bp->i) return 0;
+  if (ap->i > bp->i) return 1;
+  return 0;
+}
+
+/*
+ * _mx   (pa,di)
+ */
+
+static adns_status pa_mx(const parseinfo *pai, int cbyte, int max, void *datap) {
+  const byte *dgram= pai->dgram;
+  adns_rr_inthostaddr *rrp= datap;
+  adns_status st;
+  int pref;
+
+  if (cbyte+2 > max) return adns_s_invaliddata;
+  GET_W(cbyte,pref);
+  rrp->i= pref;
+  st= pap_hostaddr(pai, &cbyte, max, &rrp->ha);
+  if (st) return st;
+  
+  if (cbyte != max) return adns_s_invaliddata;
+  return adns_s_ok;
+}
+
+static int di_mx(adns_state ads, const void *datap_a, const void *datap_b) {
+  const adns_rr_inthostaddr *ap= datap_a, *bp= datap_b;
+
+  if (ap->i < bp->i) return 0;
+  if (ap->i > bp->i) return 1;
+  return dip_hostaddr(ads, &ap->ha, &bp->ha);
+}
+
+/*
+ * _inthostaddr  (mf,cs)
+ */
+
+static void mf_inthostaddr(adns_query qu, void *datap) {
+  adns_rr_inthostaddr *rrp= datap;
+
+  mfp_hostaddr(qu,&rrp->ha);
+}
+
+static adns_status cs_inthostaddr(vbuf *vb, const void *datap) {
+  const adns_rr_inthostaddr *rrp= datap;
+  char buf[10];
+
+  sprintf(buf,"%u ",rrp->i);
+  CSP_ADDSTR(buf);
+
+  return csp_hostaddr(vb,&rrp->ha);
+}
+
+/*
+ * _inthost  (cs)
+ */
+
+static adns_status cs_inthost(vbuf *vb, const void *datap) {
+  const adns_rr_intstr *rrp= datap;
+  char buf[10];
+
+  sprintf(buf,"%u ",rrp->i);
+  CSP_ADDSTR(buf);
+  return csp_domain(vb,rrp->str);
+}
+
+/*
+ * _ptr   (pa, +icb_ptr)
+ */
+
+static void icb_ptr(adns_query parent, adns_query child) {
+  adns_answer *cans= child->answer;
+  const adns_rr_addr *queried, *found;
+  adns_state ads= parent->ads;
+  int i;
+
+  if (cans->status == adns_s_nxdomain || cans->status == adns_s_nodata) {
+    adns__query_fail(parent,adns_s_inconsistent);
+    return;
+  } else if (cans->status) {
+    adns__query_fail(parent,cans->status);
+    return;
+  }
+
+  queried= &parent->ctx.info.ptr_parent_addr;
+  for (i=0, found=cans->rrs.addr; i<cans->nrrs; i++, found++) {
+    if (queried->len == found->len &&
+	!memcmp(&queried->addr,&found->addr,queried->len)) {
+      if (!parent->children.head) {
+	adns__query_done(parent);
+	return;
+      } else {
+	DLIST_LINK_TAIL(ads->childw,parent);
+	return;
+      }
+    }
+  }
+
+  adns__query_fail(parent,adns_s_inconsistent);
+}
+
+static adns_status pa_ptr(const parseinfo *pai, int dmstart, int max, void *datap) {
+  static const char *(expectdomain[])= { DNS_INADDR_ARPA };
+  
+  char **rrp= datap;
+  adns_status st;
+  adns_rr_addr *ap;
+  findlabel_state fls;
+  char *ep;
+  byte ipv[4];
+  char labbuf[4];
+  int cbyte, i, lablen, labstart, l, id;
+  adns_query nqu;
+  qcontext ctx;
+
+  cbyte= dmstart;
+  st= pap_domain(pai, &cbyte, max, rrp,
+		 pai->qu->flags & adns_qf_quoteok_anshost ? pdf_quoteok : 0);
+  if (st) return st;
+  if (cbyte != max) return adns_s_invaliddata;
+
+  ap= &pai->qu->ctx.info.ptr_parent_addr;
+  if (!ap->len) {
+    adns__findlabel_start(&fls, pai->ads, -1, pai->qu,
+			  pai->qu->query_dgram, pai->qu->query_dglen,
+			  pai->qu->query_dglen, DNS_HDRSIZE, 0);
+    for (i=0; i<4; i++) {
+      st= adns__findlabel_next(&fls,&lablen,&labstart); assert(!st);
+      if (lablen<=0 || lablen>3) return adns_s_querydomainwrong;
+      memcpy(labbuf, pai->qu->query_dgram + labstart, lablen);  labbuf[lablen]= 0;
+      ipv[3-i]= strtoul(labbuf,&ep,10);  if (*ep) return adns_s_querydomainwrong;
+      if (lablen>1 && pai->qu->query_dgram[labstart]=='0')
+	return adns_s_querydomainwrong;
+    }
+    for (i=0; i<sizeof(expectdomain)/sizeof(*expectdomain); i++) {
+      st= adns__findlabel_next(&fls,&lablen,&labstart); assert(!st);
+      l= strlen(expectdomain[i]);
+      if (lablen != l || memcmp(pai->qu->query_dgram + labstart, expectdomain[i], l))
+	return adns_s_querydomainwrong;
+    }
+    st= adns__findlabel_next(&fls,&lablen,0); assert(!st);
+    if (lablen) return adns_s_querydomainwrong;
+    
+    ap->len= sizeof(struct sockaddr_in);
+    memset(&ap->addr,0,sizeof(ap->addr.inet));
+    ap->addr.inet.sin_family= AF_INET;
+    ap->addr.inet.sin_addr.s_addr=
+      htonl((ipv[0]<<24) | (ipv[1]<<16) | (ipv[2]<<8) | (ipv[3]));
+  }
+
+  st= adns__mkquery_frdgram(pai->ads, &pai->qu->vb, &id,
+			    pai->dgram, pai->dglen, dmstart,
+			    adns_r_addr, adns_qf_quoteok_query);
+  if (st) return st;
+
+  ctx.ext= 0;
+  ctx.callback= icb_ptr;
+  memset(&ctx.info,0,sizeof(ctx.info));
+  st= adns__internal_submit(pai->ads, &nqu, adns__findtype(adns_r_addr),
+			    &pai->qu->vb, id,
+			    adns_qf_quoteok_query, pai->now, &ctx);
+  if (st) return st;
+
+  nqu->parent= pai->qu;
+  DLIST_LINK_TAIL_PART(pai->qu->children,nqu,siblings.);
+  return adns_s_ok;
+}
+
+/*
+ * _strpair   (mf)
+ */
+
+static void mf_strpair(adns_query qu, void *datap) {
+  adns_rr_strpair *rrp= datap;
+
+  adns__makefinal_str(qu,&rrp->array[0]);
+  adns__makefinal_str(qu,&rrp->array[1]);
+}
+
+/*
+ * _intstrpair   (mf)
+ */
+
+static void mf_intstrpair(adns_query qu, void *datap) {
+  adns_rr_intstrpair *rrp= datap;
+
+  adns__makefinal_str(qu,&rrp->array[0].str);
+  adns__makefinal_str(qu,&rrp->array[1].str);
+}
+
+/*
+ * _hinfo   (pa)
+ */
+
+static adns_status pa_hinfo(const parseinfo *pai, int cbyte, int max, void *datap) {
+  adns_rr_intstrpair *rrp= datap;
+  adns_status st;
+  int i;
+
+  for (i=0; i<2; i++) {
+    st= pap_qstring(pai, &cbyte, max, &rrp->array[i].i, &rrp->array[i].str);
+    if (st) return st;
+  }
+
+  if (cbyte != max) return adns_s_invaliddata;
+  
+  return adns_s_ok;
+}
+
+/*
+ * _mailbox   (pap,cs)
+ */
+
+static adns_status pap_mailbox822(const parseinfo *pai, int *cbyte_io, int max,
+				  char **mb_r) {
+  int lablen, labstart, i, needquote, c, r, neednorm;
+  const unsigned char *p;
+  char *str;
+  findlabel_state fls;
+  adns_status st;
+  vbuf *vb;
+
+  vb= &pai->qu->vb;
+  vb->used= 0;
+  adns__findlabel_start(&fls, pai->ads,
+			-1, pai->qu,
+			pai->dgram, pai->dglen, max,
+			*cbyte_io, cbyte_io);
+  st= adns__findlabel_next(&fls,&lablen,&labstart);
+  if (!lablen) {
+    adns__vbuf_appendstr(vb,".");
+    goto x_ok;
+  }
+
+  neednorm= 1;
+  for (i=0, needquote=0, p= pai->dgram+labstart; i<lablen; i++) {
+    c= *p++;
+    if ((c&~128) < 32 || (c&~128) == 127) return adns_s_invaliddata;
+    if (c == '.' && !neednorm) neednorm= 1;
+    else if (c==' ' || c>=127 || ctype_822special(c)) needquote++;
+    else neednorm= 0;
+  }
+
+  if (needquote || neednorm) {
+    r= adns__vbuf_ensure(vb, lablen+needquote+4); if (!r) R_NOMEM;
+    adns__vbuf_appendq(vb,"\"",1);
+    for (i=0, needquote=0, p= pai->dgram+labstart; i<lablen; i++, p++) {
+      c= *p;
+      if (c == '"' || c=='\\') adns__vbuf_appendq(vb,"\\",1);
+      adns__vbuf_appendq(vb,p,1);
+    }
+    adns__vbuf_appendq(vb,"\"",1);
+  } else {
+    r= adns__vbuf_append(vb, pai->dgram+labstart, lablen); if (!r) R_NOMEM;
+  }
+
+  r= adns__vbuf_appendstr(vb,"@"); if (!r) R_NOMEM;
+
+  st= adns__parse_domain_more(&fls,pai->ads, pai->qu,vb,0, pai->dgram);
+  if (st) return st;
+
+ x_ok:
+  str= adns__alloc_interim(pai->qu, vb->used+1); if (!str) R_NOMEM;
+  memcpy(str,vb->buf,vb->used);
+  str[vb->used]= 0;
+  *mb_r= str;
+  return adns_s_ok;
+}
+
+static adns_status pap_mailbox(const parseinfo *pai, int *cbyte_io, int max,
+			       char **mb_r) {
+  if (pai->qu->typei->type & adns__qtf_mail822) {
+    return pap_mailbox822(pai, cbyte_io, max, mb_r);
+  } else {
+    return pap_domain(pai, cbyte_io, max, mb_r, pdf_quoteok);
+  }
+}
+
+static adns_status csp_mailbox(vbuf *vb, const char *mailbox) {
+  return csp_domain(vb,mailbox);
+}
+
+/*
+ * _rp   (pa,cs)
+ */
+
+static adns_status pa_rp(const parseinfo *pai, int cbyte, int max, void *datap) {
+  adns_rr_strpair *rrp= datap;
+  adns_status st;
+
+  st= pap_mailbox(pai, &cbyte, max, &rrp->array[0]);
+  if (st) return st;
+
+  st= pap_domain(pai, &cbyte, max, &rrp->array[1], pdf_quoteok);
+  if (st) return st;
+
+  if (cbyte != max) return adns_s_invaliddata;
+  return adns_s_ok;
+}
+
+static adns_status cs_rp(vbuf *vb, const void *datap) {
+  const adns_rr_strpair *rrp= datap;
+  adns_status st;
+
+  st= csp_mailbox(vb,rrp->array[0]);  if (st) return st;
+  CSP_ADDSTR(" ");
+  st= csp_domain(vb,rrp->array[1]);  if (st) return st;
+
+  return adns_s_ok;
+}  
+
+/*
+ * _soa   (pa,mf,cs)
+ */
+
+static adns_status pa_soa(const parseinfo *pai, int cbyte, int max, void *datap) {
+  adns_rr_soa *rrp= datap;
+  const byte *dgram= pai->dgram;
+  adns_status st;
+  int msw, lsw, i;
+
+  st= pap_domain(pai, &cbyte, max, &rrp->mname,
+		 pai->qu->flags & adns_qf_quoteok_anshost ? pdf_quoteok : 0);
+  if (st) return st;
+
+  st= pap_mailbox(pai, &cbyte, max, &rrp->rname);
+  if (st) return st;
+
+  if (cbyte+20 != max) return adns_s_invaliddata;
+  
+  for (i=0; i<5; i++) {
+    GET_W(cbyte,msw);
+    GET_W(cbyte,lsw);
+    (&rrp->serial)[i]= (msw<<16) | lsw;
+  }
+
+  return adns_s_ok;
+}
+
+static void mf_soa(adns_query qu, void *datap) {
+  adns_rr_soa *rrp= datap;
+
+  adns__makefinal_str(qu,&rrp->mname);
+  adns__makefinal_str(qu,&rrp->rname);
+}
+
+static adns_status cs_soa(vbuf *vb, const void *datap) {
+  const adns_rr_soa *rrp= datap;
+  char buf[20];
+  int i;
+  adns_status st;
+  
+  st= csp_domain(vb,rrp->mname);  if (st) return st;
+  CSP_ADDSTR(" ");
+  st= csp_mailbox(vb,rrp->rname);  if (st) return st;
+
+  for (i=0; i<5; i++) {
+    sprintf(buf," %lu",(&rrp->serial)[i]);
+    CSP_ADDSTR(buf);
+  }
+
+  return adns_s_ok;
+}
+
+/*
+ * _flat   (mf)
+ */
+
+static void mf_flat(adns_query qu, void *foo) { }
+
+/*
+ * Now the table.
+ */
+
+#define TYPESZ_M(member)           (sizeof(*((adns_answer*)0)->rrs.member))
+
+#define DEEP_MEMB(memb) TYPESZ_M(memb), mf_##memb, cs_##memb
+#define FLAT_MEMB(memb) TYPESZ_M(memb), mf_flat, cs_##memb
+
+#define DEEP_TYPE(code,rrt,fmt,memb,parser,comparer,printer) \
+ { adns_r_##code, rrt, fmt, TYPESZ_M(memb), mf_##memb, printer, parser, comparer }
+#define FLAT_TYPE(code,rrt,fmt,memb,parser,comparer,printer) \
+ { adns_r_##code, rrt, fmt, TYPESZ_M(memb), mf_flat, printer, parser, comparer }
+
+static const typeinfo typeinfos[] = {
+/* Must be in ascending order of rrtype ! */
+/* mem-mgmt code  rrt     fmt     member      parser      comparer    printer       */
+  		    		     		 	     		 	       
+FLAT_TYPE(a,      "A",     0,     inaddr,     pa_inaddr,  di_inaddr,  cs_inaddr     ),
+DEEP_TYPE(ns_raw, "NS",   "raw",  str,        pa_host_raw,0,          cs_domain     ),
+DEEP_TYPE(cname,  "CNAME", 0,     str,        pa_dom_raw, 0,          cs_domain     ),
+DEEP_TYPE(soa_raw,"SOA",  "raw",  soa,        pa_soa,     0,          cs_soa        ),
+DEEP_TYPE(ptr_raw,"PTR",  "raw",  str,        pa_host_raw,0,          cs_domain     ),
+DEEP_TYPE(hinfo,  "HINFO", 0,     intstrpair, pa_hinfo,   0,          cs_hinfo      ),
+DEEP_TYPE(mx_raw, "MX",   "raw",  intstr,     pa_mx_raw,  di_mx_raw,  cs_inthost    ),
+DEEP_TYPE(txt,    "TXT",   0,     manyistr,   pa_txt,     0,          cs_txt        ),
+DEEP_TYPE(rp_raw, "RP",   "raw",  strpair,    pa_rp,      0,          cs_rp         ),
+ 		     	                                     		   	       
+FLAT_TYPE(addr,   "A",  "addr",   addr,       pa_addr,    di_addr,    cs_addr       ),
+DEEP_TYPE(ns,     "NS", "+addr",  hostaddr,   pa_hostaddr,di_hostaddr,cs_hostaddr   ),
+DEEP_TYPE(ptr,    "PTR","checked",str,        pa_ptr,     0,          cs_domain     ),
+DEEP_TYPE(mx,     "MX", "+addr",  inthostaddr,pa_mx,      di_mx,      cs_inthostaddr),
+ 		     	                                     		      
+DEEP_TYPE(soa,    "SOA","822",    soa,        pa_soa,     0,          cs_soa        ),
+DEEP_TYPE(rp,     "RP", "822",    strpair,    pa_rp,      0,          cs_rp         ),
+};
+
+const typeinfo *adns__findtype(adns_rrtype type) {
+  const typeinfo *begin, *end, *mid;
+
+  begin= typeinfos;  end= typeinfos+(sizeof(typeinfos)/sizeof(typeinfo));
+
+  while (begin < end) {
+    mid= begin + ((end-begin)>>1);
+    if (mid->type == type) return mid;
+    if (type > mid->type) begin= mid+1;
+    else end= mid;
+  }
+  return 0;
+}
Index: adns/query.c
===================================================================
--- adns/query.c	(revision 0)
+++ adns/query.c	(revision 0)
@@ -0,0 +1,576 @@
+/*
+ * query.c: $Id: query.c,v 1.4 2001/12/04 16:12:11 androsyn Exp $
+ *  
+ */
+/*
+ * query.c
+ * - overall query management (allocation, completion)
+ * - per-query memory management
+ * - query submission and cancellation (user-visible and internal)
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ */
+
+#include "internal.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <sys/time.h>
+
+#include "internal.h"
+
+static adns_query query_alloc(adns_state ads, const typeinfo *typei,
+			      adns_queryflags flags, struct timeval now) {
+  /* Allocate a virgin query and return it. */
+  adns_query qu;
+  
+  qu= MyMalloc(sizeof(*qu));  if (!qu) return 0;
+  qu->answer= MyMalloc(sizeof(*qu->answer));  if (!qu->answer) { MyFree(qu); return 0; }
+  
+  qu->ads= ads;
+  qu->state= query_tosend;
+  qu->back= qu->next= qu->parent= 0;
+  DLIST_INIT(qu->children);
+  DLINK_INIT(qu->siblings);
+  DLIST_INIT(qu->allocations);
+  qu->interim_allocd= 0;
+  qu->preserved_allocd= 0;
+  qu->final_allocspace= 0;
+
+  qu->typei= typei;
+  qu->query_dgram= 0;
+  qu->query_dglen= 0;
+  adns__vbuf_init(&qu->vb);
+
+  qu->cname_dgram= 0;
+  qu->cname_dglen= qu->cname_begin= 0;
+
+  adns__vbuf_init(&qu->search_vb);
+  qu->search_origlen= qu->search_pos= qu->search_doneabs= 0;
+
+  qu->id= -2; /* will be overwritten with real id before we leave adns */
+  qu->flags= flags;
+  qu->retries= 0;
+  qu->udpnextserver= 0;
+  qu->udpsent= 0;
+  timerclear(&qu->timeout);
+  qu->expires= now.tv_sec + MAXTTLBELIEVE;
+
+  memset(&qu->ctx,0,sizeof(qu->ctx));
+
+  qu->answer->status= adns_s_ok;
+  qu->answer->cname= qu->answer->owner= 0;
+  qu->answer->type= typei->type;
+  qu->answer->expires= -1;
+  qu->answer->nrrs= 0;
+  qu->answer->rrs.untyped= 0;
+  qu->answer->rrsz= typei->rrsz;
+
+  return qu;
+}
+
+static void query_submit(adns_state ads, adns_query qu,
+			 const typeinfo *typei, vbuf *qumsg_vb, int id,
+			 adns_queryflags flags, struct timeval now) {
+  /* Fills in the query message in for a previously-allocated query,
+   * and submits it.  Cannot fail.  Takes over the memory for qumsg_vb.
+   */
+
+  qu->vb= *qumsg_vb;
+  adns__vbuf_init(qumsg_vb);
+
+  qu->query_dgram= MyMalloc(qu->vb.used);
+  if (!qu->query_dgram) { adns__query_fail(qu,adns_s_nomemory); return; }
+  
+  qu->id= id;
+  qu->query_dglen= qu->vb.used;
+  memcpy(qu->query_dgram,qu->vb.buf,qu->vb.used);
+  
+  adns__query_send(qu,now);
+}
+
+adns_status adns__internal_submit(adns_state ads, adns_query *query_r,
+				  const typeinfo *typei, vbuf *qumsg_vb, int id,
+				  adns_queryflags flags, struct timeval now,
+				  const qcontext *ctx) {
+  adns_query qu;
+
+  qu= query_alloc(ads,typei,flags,now);
+  if (!qu) { adns__vbuf_free(qumsg_vb); return adns_s_nomemory; }
+  *query_r= qu;
+
+  memcpy(&qu->ctx,ctx,sizeof(qu->ctx));
+  query_submit(ads,qu, typei,qumsg_vb,id,flags,now);
+  
+  return adns_s_ok;
+}
+
+static void query_simple(adns_state ads, adns_query qu,
+			 const char *owner, int ol,
+			 const typeinfo *typei, adns_queryflags flags,
+			 struct timeval now) {
+  vbuf vb_new;
+  int id;
+  adns_status stat;
+
+  stat= adns__mkquery(ads,&qu->vb,&id, owner,ol, typei,flags);
+  if (stat) {
+    if (stat == adns_s_querydomaintoolong && (flags & adns_qf_search)) {
+      adns__search_next(ads,qu,now);
+      return;
+    } else {
+      adns__query_fail(qu,stat);
+      return;
+    }
+  }
+
+  vb_new= qu->vb;
+  adns__vbuf_init(&qu->vb);
+  query_submit(ads,qu, typei,&vb_new,id, flags,now);
+}
+
+void adns__search_next(adns_state ads, adns_query qu, struct timeval now) {
+  const char *nextentry;
+  adns_status stat;
+  
+  if (qu->search_doneabs<0) {
+    nextentry= 0;
+    qu->search_doneabs= 1;
+  } else {
+    if (qu->search_pos >= ads->nsearchlist) {
+      if (qu->search_doneabs) {
+	stat= adns_s_nxdomain; goto x_fail;
+	return;
+      } else {
+	nextentry= 0;
+	qu->search_doneabs= 1;
+      }
+    } else {
+      nextentry= ads->searchlist[qu->search_pos++];
+    }
+  }
+
+  qu->search_vb.used= qu->search_origlen;
+  if (nextentry) {
+    if (!adns__vbuf_append(&qu->search_vb,".",1) ||
+	!adns__vbuf_appendstr(&qu->search_vb,nextentry)) {
+      stat= adns_s_nomemory; goto x_fail;
+    }
+  }
+
+  MyFree(qu->query_dgram);
+  qu->query_dgram= 0; qu->query_dglen= 0;
+
+  query_simple(ads,qu, qu->search_vb.buf, qu->search_vb.used, qu->typei, qu->flags, now);
+  return;
+  
+x_fail:
+  adns__query_fail(qu,stat);
+}
+
+static int save_owner(adns_query qu, const char *owner, int ol) {
+  /* Returns 1 if OK, otherwise there was no memory. */
+  adns_answer *ans;
+
+  ans= qu->answer;
+  assert(!ans->owner);
+
+  ans->owner= adns__alloc_preserved(qu,ol+1);  if (!ans->owner) return 0;
+
+  memcpy(ans->owner,owner,ol);
+  ans->owner[ol]= 0;
+  return 1;
+}
+
+int adns_submit(adns_state ads,
+		const char *owner,
+		adns_rrtype type,
+		adns_queryflags flags,
+		void *context,
+		adns_query *query_r) {
+  int r, ol, ndots;
+  adns_status stat;
+  const typeinfo *typei;
+  struct timeval now;
+  adns_query qu;
+  const char *p;
+
+  adns__consistency(ads,0,cc_entex);
+
+  typei= adns__findtype(type);
+  if (!typei) return ENOSYS;
+
+  r= gettimeofday(&now,0); if (r) goto x_errno;
+  qu= query_alloc(ads,typei,flags,now); if (!qu) goto x_errno;
+  
+  qu->ctx.ext= context;
+  qu->ctx.callback= 0;
+  memset(&qu->ctx.info,0,sizeof(qu->ctx.info));
+
+  *query_r= qu;
+
+  ol= strlen(owner);
+  if (!ol) { stat= adns_s_querydomaininvalid; goto x_adnsfail; }
+  if (ol>DNS_MAXDOMAIN+1) { stat= adns_s_querydomaintoolong; goto x_adnsfail; }
+				 
+  if (ol>=1 && owner[ol-1]=='.' && (ol<2 || owner[ol-2]!='\\')) {
+    flags &= ~adns_qf_search;
+    qu->flags= flags;
+    ol--;
+  }
+
+  if (flags & adns_qf_search) {
+    r= adns__vbuf_append(&qu->search_vb,owner,ol);
+    if (!r) { stat= adns_s_nomemory; goto x_adnsfail; }
+
+    for (ndots=0, p=owner; (p= strchr(p,'.')); p++, ndots++);
+    qu->search_doneabs= (ndots >= ads->searchndots) ? -1 : 0;
+    qu->search_origlen= ol;
+    adns__search_next(ads,qu,now);
+  } else {
+    if (flags & adns_qf_owner) {
+      if (!save_owner(qu,owner,ol)) { stat= adns_s_nomemory; goto x_adnsfail; }
+    }
+    query_simple(ads,qu, owner,ol, typei,flags, now);
+  }
+  adns__autosys(ads,now);
+  adns__consistency(ads,qu,cc_entex);
+  return 0;
+
+ x_adnsfail:
+  adns__query_fail(qu,stat);
+  adns__consistency(ads,qu,cc_entex);
+  return 0;
+
+ x_errno:
+  r= errno;
+  assert(r);
+  adns__consistency(ads,0,cc_entex);
+  return r;
+}
+
+int adns_submit_reverse_any(adns_state ads,
+			    const struct sockaddr *addr,
+			    const char *zone,
+			    adns_rrtype type,
+			    adns_queryflags flags,
+			    void *context,
+			    adns_query *query_r) {
+  const unsigned char *iaddr;
+  char *buf, *buf_free;
+  char shortbuf[100];
+  int r, lreq;
+
+  flags &= ~adns_qf_search;
+
+  if (addr->sa_family != AF_INET) return ENOSYS;
+  iaddr= (const unsigned char*) &(((const struct sockaddr_in*)addr) -> sin_addr);
+
+  lreq= strlen(zone) + 4*4 + 1;
+  if (lreq > sizeof(shortbuf)) {
+    buf= MyMalloc(strlen(zone) + 4*4 + 1);
+    if (!buf) return errno;
+    buf_free= buf;
+  } else {
+    buf= shortbuf;
+    buf_free= 0;
+  }
+  sprintf(buf, "%d.%d.%d.%d.%s", iaddr[3], iaddr[2], iaddr[1], iaddr[0], zone);
+
+  r= adns_submit(ads,buf,type,flags,context,query_r);
+  MyFree(buf_free);
+  return r;
+}
+
+int adns_submit_reverse(adns_state ads,
+			const struct sockaddr *addr,
+			adns_rrtype type,
+			adns_queryflags flags,
+			void *context,
+			adns_query *query_r) {
+  if (type != adns_r_ptr && type != adns_r_ptr_raw) return EINVAL;
+  return adns_submit_reverse_any(ads,addr,"in-addr.arpa",type,flags,context,query_r);
+}
+
+int adns_synchronous(adns_state ads,
+		     const char *owner,
+		     adns_rrtype type,
+		     adns_queryflags flags,
+		     adns_answer **answer_r) {
+  adns_query qu;
+  int r;
+  
+  r= adns_submit(ads,owner,type,flags,0,&qu);
+  if (r) return r;
+
+  r= adns_wait(ads,&qu,answer_r,0);
+  if (r) adns_cancel(qu);
+
+  return r;
+}
+
+static void *alloc_common(adns_query qu, size_t sz) {
+  allocnode *an;
+
+  if (!sz) return qu; /* Any old pointer will do */
+  assert(!qu->final_allocspace);
+  an= MyMalloc(MEM_ROUND(MEM_ROUND(sizeof(*an)) + sz));
+  if (!an) return 0;
+  DLIST_LINK_TAIL(qu->allocations,an);
+  return (byte*)an + MEM_ROUND(sizeof(*an));
+}
+
+void *adns__alloc_interim(adns_query qu, size_t sz) {
+  void *rv;
+  
+  sz= MEM_ROUND(sz);
+  rv= alloc_common(qu,sz);
+  if (!rv) return 0;
+  qu->interim_allocd += sz;
+  return rv;
+}
+
+void *adns__alloc_preserved(adns_query qu, size_t sz) {
+  void *rv;
+  
+  sz= MEM_ROUND(sz);
+  rv= adns__alloc_interim(qu,sz);
+  if (!rv) return 0;
+  qu->preserved_allocd += sz;
+  return rv;
+}
+
+void *adns__alloc_mine(adns_query qu, size_t sz) {
+  return alloc_common(qu,MEM_ROUND(sz));
+}
+
+void adns__transfer_interim(adns_query from, adns_query to, void *block, size_t sz) {
+  allocnode *an;
+
+  if (!block) return;
+  an= (void*)((byte*)block - MEM_ROUND(sizeof(*an)));
+
+  assert(!to->final_allocspace);
+  assert(!from->final_allocspace);
+  
+  DLIST_UNLINK(from->allocations,an);
+  DLIST_LINK_TAIL(to->allocations,an);
+
+  sz= MEM_ROUND(sz);
+  from->interim_allocd -= sz;
+  to->interim_allocd += sz;
+
+  if (to->expires > from->expires) to->expires= from->expires;
+}
+
+void *adns__alloc_final(adns_query qu, size_t sz) {
+  /* When we're in the _final stage, we _subtract_ from interim_alloc'd
+   * each allocation, and use final_allocspace to point to the next free
+   * bit.
+   */
+  void *rp;
+
+  sz= MEM_ROUND(sz);
+  rp= qu->final_allocspace;
+  assert(rp);
+  qu->interim_allocd -= sz;
+  assert(qu->interim_allocd>=0);
+  qu->final_allocspace= (byte*)rp + sz;
+  return rp;
+}
+
+static void cancel_children(adns_query qu) {
+  adns_query cqu, ncqu;
+
+  for (cqu= qu->children.head; cqu; cqu= ncqu) {
+    ncqu= cqu->siblings.next;
+    adns_cancel(cqu);
+  }
+}
+
+void adns__reset_preserved(adns_query qu) {
+  assert(!qu->final_allocspace);
+  cancel_children(qu);
+  qu->answer->nrrs= 0;
+  qu->answer->rrs.untyped= 0;
+  qu->interim_allocd= qu->preserved_allocd;
+}
+
+static void free_query_allocs(adns_query qu) {
+  allocnode *an, *ann;
+
+  cancel_children(qu);
+  for (an= qu->allocations.head; an; an= ann) { ann= an->next; MyFree(an); }
+  DLIST_INIT(qu->allocations);
+  adns__vbuf_free(&qu->vb);
+  adns__vbuf_free(&qu->search_vb);
+  MyFree(qu->query_dgram);
+  qu->query_dgram= 0;
+}
+
+void adns_cancel(adns_query qu) {
+  adns_state ads;
+
+  ads= qu->ads;
+  adns__consistency(ads,qu,cc_entex);
+  if (qu->parent) DLIST_UNLINK_PART(qu->parent->children,qu,siblings.);
+  switch (qu->state) {
+  case query_tosend:
+    DLIST_UNLINK(ads->udpw,qu);
+    break;
+  case query_tcpw:
+    DLIST_UNLINK(ads->tcpw,qu);
+    break;
+  case query_childw:
+    DLIST_UNLINK(ads->childw,qu);
+    break;
+  case query_done:
+    DLIST_UNLINK(ads->output,qu);
+    break;
+  default:
+    abort();
+  }
+  free_query_allocs(qu);
+  MyFree(qu->answer);
+  MyFree(qu);
+  adns__consistency(ads,0,cc_entex);
+}
+
+void adns__update_expires(adns_query qu, unsigned long ttl, struct timeval now) {
+  time_t max;
+
+  assert(ttl <= MAXTTLBELIEVE);
+  max= now.tv_sec + ttl;
+  if (qu->expires < max) return;
+  qu->expires= max;
+}
+
+static void makefinal_query(adns_query qu) {
+  adns_answer *ans;
+  int rrn;
+
+  ans= qu->answer;
+
+  if (qu->interim_allocd) {
+    ans= MyRealloc(qu->answer, MEM_ROUND(MEM_ROUND(sizeof(*ans)) + qu->interim_allocd));
+    if (!ans) goto x_nomem;
+    qu->answer= ans;
+  }
+
+  qu->final_allocspace= (byte*)ans + MEM_ROUND(sizeof(*ans));
+  adns__makefinal_str(qu,&ans->cname);
+  adns__makefinal_str(qu,&ans->owner);
+  
+  if (ans->nrrs) {
+    adns__makefinal_block(qu, &ans->rrs.untyped, ans->nrrs*ans->rrsz);
+
+    for (rrn=0; rrn<ans->nrrs; rrn++)
+      qu->typei->makefinal(qu, ans->rrs.bytes + rrn*ans->rrsz);
+  }
+  
+  free_query_allocs(qu);
+  return;
+  
+ x_nomem:
+  qu->preserved_allocd= 0;
+  qu->answer->cname= 0;
+  qu->answer->owner= 0;
+  adns__reset_preserved(qu); /* (but we just threw away the preserved stuff) */
+
+  qu->answer->status= adns_s_nomemory;
+  free_query_allocs(qu);
+}
+
+void adns__query_done(adns_query qu) {
+  adns_answer *ans;
+  adns_query parent;
+
+  cancel_children(qu);
+
+  qu->id= -1;
+  ans= qu->answer;
+
+  if (qu->flags & adns_qf_owner && qu->flags & adns_qf_search &&
+      ans->status != adns_s_nomemory) {
+    if (!save_owner(qu, qu->search_vb.buf, qu->search_vb.used)) {
+      adns__query_fail(qu,adns_s_nomemory);
+      return;
+    }
+  }
+
+  if (ans->nrrs && qu->typei->diff_needswap) {
+    if (!adns__vbuf_ensure(&qu->vb,qu->typei->rrsz)) {
+      adns__query_fail(qu,adns_s_nomemory);
+      return;
+    }
+    adns__isort(ans->rrs.bytes, ans->nrrs, ans->rrsz,
+		qu->vb.buf,
+		(int(*)(void*, const void*, const void*))qu->typei->diff_needswap,
+		qu->ads);
+  }
+
+  ans->expires= qu->expires;
+  parent= qu->parent;
+  if (parent) {
+    DLIST_UNLINK_PART(parent->children,qu,siblings.);
+    DLIST_UNLINK(qu->ads->childw,parent);
+    qu->ctx.callback(parent,qu);
+    free_query_allocs(qu);
+    MyFree(qu->answer);
+    MyFree(qu);
+  } else {
+    makefinal_query(qu);
+    DLIST_LINK_TAIL(qu->ads->output,qu);
+    qu->state= query_done;
+  }
+}
+
+void adns__query_fail(adns_query qu, adns_status stat) {
+  adns__reset_preserved(qu);
+  qu->answer->status= stat;
+  adns__query_done(qu);
+}
+
+void adns__makefinal_str(adns_query qu, char **strp) {
+  int l;
+  char *before, *after;
+
+  before= *strp;
+  if (!before) return;
+  l= strlen(before)+1;
+  after= adns__alloc_final(qu,l);
+  memcpy(after,before,l);
+  *strp= after;  
+}
+
+void adns__makefinal_block(adns_query qu, void **blpp, size_t sz) {
+  void *before, *after;
+
+  before= *blpp;
+  if (!before) return;
+  after= adns__alloc_final(qu,sz);
+  memcpy(after,before,sz);
+  *blpp= after;
+}
Index: adns/poll.c
===================================================================
--- adns/poll.c	(revision 0)
+++ adns/poll.c	(revision 0)
@@ -0,0 +1,135 @@
+/*
+ * poll.c: $Id: poll.c,v 1.2 2001/12/04 16:12:11 androsyn Exp $
+ *  
+ */
+/*
+ * poll.c
+ * - wrappers for poll(2)
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-1999 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ */
+
+#include <limits.h>
+#include <string.h>
+
+#include "internal.h"
+
+#ifdef USE_POLL
+
+int adns_beforepoll(adns_state ads, struct pollfd *fds, int *nfds_io, int *timeout_io,
+		    const struct timeval *now) {
+  struct timeval tv_nowbuf, tv_tobuf, *tv_to;
+  int space, found, timeout_ms, r;
+  struct pollfd fds_tmp[MAX_POLLFDS];
+
+  adns__consistency(ads,0,cc_entex);
+
+  if (timeout_io) {
+    adns__must_gettimeofday(ads,&now,&tv_nowbuf);
+    if (!now) { *nfds_io= 0; r= 0; goto xit; }
+
+    timeout_ms= *timeout_io;
+    if (timeout_ms == -1) {
+      tv_to= 0;
+    } else {
+      tv_tobuf.tv_sec= timeout_ms / 1000;
+      tv_tobuf.tv_usec= (timeout_ms % 1000)*1000;
+      tv_to= &tv_tobuf;
+    }
+
+    adns__timeouts(ads, 0, &tv_to,&tv_tobuf, *now);
+
+    if (tv_to) {
+      assert(tv_to == &tv_tobuf);
+      timeout_ms= (tv_tobuf.tv_usec+999)/1000;
+      assert(tv_tobuf.tv_sec < (INT_MAX-timeout_ms)/1000);
+      timeout_ms += tv_tobuf.tv_sec*1000;
+    } else {
+      timeout_ms= -1;
+    }
+    *timeout_io= timeout_ms;
+  }
+  
+  space= *nfds_io;
+  if (space >= MAX_POLLFDS) {
+    found= adns__pollfds(ads,fds);
+    *nfds_io= found;
+  } else {
+    found= adns__pollfds(ads,fds_tmp);
+    *nfds_io= found;
+    if (space < found) { r= ERANGE; goto xit; }
+    memcpy(fds,fds_tmp,sizeof(struct pollfd)*found);
+  }
+  r= 0;
+xit:
+  adns__consistency(ads,0,cc_entex);
+  return r;
+}
+
+void adns_afterpoll(adns_state ads, const struct pollfd *fds, int nfds,
+		    const struct timeval *now) {
+  struct timeval tv_buf;
+
+  adns__consistency(ads,0,cc_entex);
+  adns__must_gettimeofday(ads,&now,&tv_buf);
+  if (now) {
+    adns__timeouts(ads, 1, 0,0, *now);
+    adns__fdevents(ads, fds,nfds, 0,0,0,0, *now,0);
+  }
+  adns__consistency(ads,0,cc_entex);
+}
+
+int adns_wait_poll(adns_state ads,
+		   adns_query *query_io,
+		   adns_answer **answer_r,
+		   void **context_r) {
+  int r, nfds, to;
+  struct pollfd fds[MAX_POLLFDS];
+  
+  adns__consistency(ads,0,cc_entex);
+
+  for (;;) {
+    r= adns__internal_check(ads,query_io,answer_r,context_r);
+    if (r != EAGAIN) goto xit;
+    nfds= MAX_POLLFDS; to= -1;
+    adns_beforepoll(ads,fds,&nfds,&to,0);
+    r= poll(fds,nfds,to);
+    if (r == -1) {
+      if (errno == EINTR) {
+	if (ads->iflags & adns_if_eintr) { r= EINTR; goto xit; }
+      } else {
+	adns__diag(ads,-1,0,"poll failed in wait: %s",strerror(errno));
+	adns_globalsystemfailure(ads);
+      }
+    } else {
+      assert(r >= 0);
+      adns_afterpoll(ads,fds,nfds,0);
+    }
+  }
+
+ xit:
+  adns__consistency(ads,0,cc_entex);
+  return r;
+}
+
+#endif
Index: adns/parse.c
===================================================================
--- adns/parse.c	(revision 0)
+++ adns/parse.c	(revision 0)
@@ -0,0 +1,250 @@
+/*
+ * parse.c: $Id: parse.c,v 1.3 2002/01/28 04:26:09 androsyn Exp $
+ *  
+ */
+/*
+ * parse.c
+ * - parsing assistance functions (mainly for domains inside datagrams)
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ */
+
+#include "internal.h"
+
+int vbuf__append_quoted1035(vbuf *vb, const byte *buf, int len) {
+  char qbuf[10];
+  int i, ch;
+  
+  while (len) {
+    qbuf[0]= 0;
+    for (i=0; i<len; i++) {
+      ch= buf[i];
+      if (ch <= ' ' || ch >= 127) {
+	sprintf(qbuf,"\\%03o",ch);
+	break;
+      } else if (!ctype_domainunquoted(ch)) {
+	sprintf(qbuf,"\\%c",ch);
+	break;
+      }
+    }
+    if (!adns__vbuf_append(vb,buf,i) || !adns__vbuf_append(vb,qbuf,strlen(qbuf)))
+      return 0;
+    if (i<len) i++;
+    buf+= i;
+    len-= i;
+  }
+  return 1;
+}
+
+void adns__findlabel_start(findlabel_state *fls, adns_state ads,
+			   int serv, adns_query qu,
+			   const byte *dgram, int dglen, int max,
+			   int dmbegin, int *dmend_rlater) {
+  fls->ads= ads;
+  fls->qu= qu;
+  fls->serv= serv;
+  fls->dgram= dgram;
+  fls->dglen= dglen;
+  fls->max= max;
+  fls->cbyte= dmbegin;
+  fls->namelen= 0;
+  fls->dmend_r= dmend_rlater;
+}
+
+adns_status adns__findlabel_next(findlabel_state *fls,
+				 int *lablen_r, int *labstart_r) {
+  int lablen, jumpto;
+  const char *dgram;
+
+  dgram= fls->dgram;
+  for (;;) {
+    if (fls->cbyte >= fls->dglen) goto x_truncated;
+    if (fls->cbyte >= fls->max) goto x_badresponse;
+    GET_B(fls->cbyte,lablen);
+    if (!(lablen & 0x0c0)) break;
+    if ((lablen & 0x0c0) != 0x0c0) return adns_s_unknownformat;
+    if (fls->cbyte >= fls->dglen) goto x_truncated;
+    if (fls->cbyte >= fls->max) goto x_badresponse;
+    GET_B(fls->cbyte,jumpto);
+    jumpto |= (lablen&0x3f)<<8;
+    if (fls->dmend_r) *(fls->dmend_r)= fls->cbyte;
+    fls->cbyte= jumpto;
+    fls->dmend_r= 0; fls->max= fls->dglen+1;
+  }
+  if (labstart_r) *labstart_r= fls->cbyte;
+  if (lablen) {
+    if (fls->namelen) fls->namelen++;
+    fls->namelen+= lablen;
+    if (fls->namelen > DNS_MAXDOMAIN) return adns_s_answerdomaintoolong;
+    fls->cbyte+= lablen;
+    if (fls->cbyte > fls->dglen) goto x_truncated;
+    if (fls->cbyte > fls->max) goto x_badresponse;
+  } else {
+    if (fls->dmend_r) *(fls->dmend_r)= fls->cbyte;
+  }
+  *lablen_r= lablen;
+  return adns_s_ok;
+
+ x_truncated:
+  *lablen_r= -1;
+  return adns_s_ok;
+
+ x_badresponse: 
+  adns__diag(fls->ads,fls->serv,fls->qu,"label in domain runs beyond end of domain");
+  return adns_s_invalidresponse;
+}
+
+adns_status adns__parse_domain(adns_state ads, int serv, adns_query qu,
+			       vbuf *vb, parsedomain_flags flags,
+			       const byte *dgram, int dglen, int *cbyte_io, int max) {
+  findlabel_state fls;
+  
+  adns__findlabel_start(&fls,ads, serv,qu, dgram,dglen,max, *cbyte_io,cbyte_io);
+  vb->used= 0;
+  return adns__parse_domain_more(&fls,ads,qu, vb,flags,dgram);
+}
+
+adns_status adns__parse_domain_more(findlabel_state *fls, adns_state ads,
+				    adns_query qu, vbuf *vb, parsedomain_flags flags,
+				    const byte *dgram) {
+  int lablen, labstart, i, ch, first;
+  adns_status st;
+
+  first= 1;
+  for (;;) {
+    st= adns__findlabel_next(fls,&lablen,&labstart);
+    if (st) return st;
+    if (lablen<0) { vb->used=0; return adns_s_ok; }
+    if (!lablen) break;
+    if (first) {
+      first= 0;
+    } else {
+      if (!adns__vbuf_append(vb,".",1)) return adns_s_nomemory;
+    }
+    if (flags & pdf_quoteok) {
+      if (!vbuf__append_quoted1035(vb,dgram+labstart,lablen))
+	return adns_s_nomemory;
+    } else {
+      ch= dgram[labstart];
+      if (!ctype_alpha(ch) && !ctype_digit(ch)) return adns_s_answerdomaininvalid;
+      for (i= labstart+1; i<labstart+lablen; i++) {
+	ch= dgram[i];
+	if (ch != '-' && !ctype_alpha(ch) && !ctype_digit(ch))
+	  return adns_s_answerdomaininvalid;
+      }
+      if (!adns__vbuf_append(vb,dgram+labstart,lablen))
+	return adns_s_nomemory;
+    }
+  }
+  if (!adns__vbuf_append(vb,"",1)) return adns_s_nomemory;
+  return adns_s_ok;
+}
+	
+adns_status adns__findrr_anychk(adns_query qu, int serv,
+				const byte *dgram, int dglen, int *cbyte_io,
+				int *type_r, int *class_r, unsigned long *ttl_r,
+				int *rdlen_r, int *rdstart_r,
+				const byte *eo_dgram, int eo_dglen, int eo_cbyte,
+				int *eo_matched_r) {
+  findlabel_state fls, eo_fls;
+  int cbyte;
+  
+  int tmp, rdlen, mismatch;
+  unsigned long ttl;
+  int lablen, labstart, ch;
+  int eo_lablen, eo_labstart, eo_ch;
+  adns_status st;
+
+  cbyte= *cbyte_io;
+
+  adns__findlabel_start(&fls,qu->ads, serv,qu, dgram,dglen,dglen,cbyte,&cbyte);
+  if (eo_dgram) {
+    adns__findlabel_start(&eo_fls,qu->ads, -1,0, eo_dgram,eo_dglen,eo_dglen,eo_cbyte,0);
+    mismatch= 0;
+  } else {
+    mismatch= 1;
+  }
+  
+  for (;;) {
+    st= adns__findlabel_next(&fls,&lablen,&labstart);
+    if (st) return st;
+    if (lablen<0) goto x_truncated;
+
+    if (!mismatch) {
+      st= adns__findlabel_next(&eo_fls,&eo_lablen,&eo_labstart);
+      assert(!st); assert(eo_lablen>=0);
+      if (lablen != eo_lablen) mismatch= 1;
+      while (!mismatch && eo_lablen-- > 0) {
+	ch= dgram[labstart++]; if (ctype_alpha(ch)) ch &= ~32;
+	eo_ch= eo_dgram[eo_labstart++]; if (ctype_alpha(eo_ch)) eo_ch &= ~32;
+	if (ch != eo_ch) mismatch= 1;
+      }
+    }
+    if (!lablen) break;
+  }
+  if (eo_matched_r) *eo_matched_r= !mismatch;
+   
+  if (cbyte+10>dglen) goto x_truncated;
+  GET_W(cbyte,tmp); *type_r= tmp;
+  GET_W(cbyte,tmp); *class_r= tmp;
+
+  GET_L(cbyte,ttl);
+  if (ttl > MAXTTLBELIEVE) ttl= MAXTTLBELIEVE;
+  *ttl_r= ttl;
+  
+  GET_W(cbyte,rdlen); if (rdlen_r) *rdlen_r= rdlen;
+  if (rdstart_r) *rdstart_r= cbyte;
+  cbyte+= rdlen;
+  if (cbyte>dglen) goto x_truncated;
+  *cbyte_io= cbyte;
+  return adns_s_ok;
+
+ x_truncated:
+  *type_r= -1;
+  return 0;
+}
+
+adns_status adns__findrr(adns_query qu, int serv,
+			 const byte *dgram, int dglen, int *cbyte_io,
+			 int *type_r, int *class_r, unsigned long *ttl_r,
+			 int *rdlen_r, int *rdstart_r,
+			 int *ownermatchedquery_r) {
+  if (!ownermatchedquery_r) {
+    return adns__findrr_anychk(qu,serv,
+			       dgram,dglen,cbyte_io,
+			       type_r,class_r,ttl_r,rdlen_r,rdstart_r,
+			       0,0,0, 0);
+  } else if (!qu->cname_dgram) {
+    return adns__findrr_anychk(qu,serv,
+			       dgram,dglen,cbyte_io,
+			       type_r,class_r,ttl_r,rdlen_r,rdstart_r,
+			       qu->query_dgram,qu->query_dglen,DNS_HDRSIZE,
+			       ownermatchedquery_r);
+  } else {
+    return adns__findrr_anychk(qu,serv,
+			       dgram,dglen,cbyte_io,
+			       type_r,class_r,ttl_r,rdlen_r,rdstart_r,
+			       qu->cname_dgram,qu->cname_dglen,qu->cname_begin,
+			       ownermatchedquery_r);
+  }
+}
Index: adns/README
===================================================================
--- adns/README	(revision 0)
+++ adns/README	(revision 0)
@@ -0,0 +1,167 @@
+
+                                   GNU adns
+                                       
+   Advanced, easy to use, asynchronous-capable DNS client library and
+   utilities.
+   
+   adns is a resolver library for C (and C++) programs, and a collection
+   of useful DNS resolver utilities.
+   
+C library
+
+   In contrast with the standard interfaces, gethostbyname et al and
+   libresolv, it has the following features:
+     * It is reasonably easy to use for simple programs which just want
+       to translate names to addresses, look up MX records, etc.
+     * It can be used in an asynchronous, non-blocking, manner. Many
+       queries can be handled simultaneously.
+     * Responses are decoded automatically into a natural representation
+       for a C program - there is no need to deal with DNS packet
+       formats.
+     * Sanity checking (eg, name syntax checking, reverse/forward
+       correspondence, CNAME pointing to CNAME) is performed
+       automatically.
+     * Time-to-live, CNAME and other similar information is returned in
+       an easy-to-use form, without getting in the way.
+     * There is no global state in the library; resolver state is an
+       opaque data structure which the client creates explicitly. A
+       program can have several instances of the resolver.
+     * Errors are reported to the application in a way that distinguishes
+       the various causes of failure properly.
+     * Understands conventional resolv.conf, but this can overridden by
+       environment variables.
+     * Flexibility. For example, the application can tell adns to: ignore
+       environment variables (for setuid programs), disable hostname
+       syntax sanity checks to return arbitrary data, override or ignore
+       resolv.conf in favour of supplied configuration, etc.
+     * Believed to be correct ! For example, will correctly back off to
+       TCP in case of long replies or queries, or to other nameservers if
+       several are available. It has sensible handling of bad responses
+       etc.
+       
+DNS utility programs
+
+   adns also comes with a number of utility programs for use from the
+   command line and in scripts:
+     * adnslogres is a much faster version of Apache's logresolv program.
+     * adnsresfilter is a filter which copies its input to its output,
+       replacing IP addresses by the corresponding names, without unduly
+       delaying the output. For example, you can usefully pipe the output
+       of netstat -n, tcpdump -ln, and the like, into it.
+     * adnshost is a general-purpose DNS lookup utility which can be used
+       easily in from the command line and from shell scripts to do
+       simple lookups. In a more advanced mode it can be used as a
+       general-purpose DNS helper program for scripting languages which
+       can invoke and communicate with subprocesses. See the [1]adnshost
+       usage message for a summary of its capabilities.
+       
+Documentation
+
+   I'm afraid there is no manual yet. However, competent C programmers
+   should be able to use the library based on the [2]commented adns.h
+   header file, and the usage messages for the programs should be
+   sufficient.
+   
+Feedback
+
+   I'd be pleased if you would let me know if you're using my library in
+   your project, and what you think of it.
+   
+   If you are subscribed to adns-discuss please send feedback, including
+   bug reports, there; otherwise send mail to
+   adns-bugreports@chiark.greenend.org.uk. If you'd prefer that your
+   message wasn't forwarded to the adns-bugreports list, send it to
+   adns-maint@chiark.greenend.org.uk.
+   
+Mailinglists
+
+   I have set up mailinglists adns-announce and adns-discuss. The
+   announcements list is moderated and will contain only announcements of
+   important bugs, new versions, etc. The bug reports address mentioned
+   above is also a mailing list; feel free to subscribe to it.
+   
+   There are [3]archives and subscription web pages, or you can subscribe
+   by sending mail containing the word `subscribe' to
+   adns-announce-REQUEST@chiark.greenend.org.uk or
+   adns-discuss-REQUEST@chiark.greenend.org.uk.
+   
+Download
+
+   Available for download from [4]chiark.greenend.org.uk are:
+     * The [5]current release as a gzipped tarfile.
+     * [6]adns.h API header file with comments, and [7]usage message for
+       adnshost (currently there is no manual, sorry).
+     * All versions released so far are also available via [8]anonymous
+       FTP and [9]HTTP,
+     * A mirror of my CVS repository is available via rsync from
+       rsync.chiark.greenend.org.uk::ftp/users/ian/cvs-pub/adns (use FTP
+       first to find your way around), or via [10]cvsweb.
+       
+   adns is also available from the [11]GNU Project FTP servers and their
+   [12]mirrors.
+   
+Technical note
+
+   adns requires a real nameserver like [13]BIND or [14]Dents running on
+   the same system or a nearby one, which must be willing to provide
+   `recursive service'. I.e., adns is a `stub resolver'. All properly
+   configured UN*X and GNU systems will already have such nameserver(s);
+   they are usually listed in /etc/resolv.conf.
+   
+Copyright and licensing
+
+   adns is Copyright 1997-2000 Ian Jackson, Copyright 1999-2000 Tony
+   Finch, and Copyright (C) 1991 Massachusetts Institute of Technology.
+   
+   adns is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+   
+   This program and documentation is distributed in the hope that it will
+   be useful, but without any warranty; without even the implied warranty
+   of merchantability or fitness for a particular purpose. See the
+   [15]GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with adns, or one should be available above; if not, write to
+   the [16]Free Software Foundation, 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA, or email adns-maint@chiark.greenend.org.uk.
+     _________________________________________________________________
+   
+   [17]Ian Jackson / [18]adns-maint@chiark.greenend.org.uk; more [19]free
+   software by me.
+   
+   [20]GNU home page; [21]chiark home page; [22]site or mirror home page
+   
+   This web page is Copyright (C)1996-2000 Ian Jackson. See the
+   [23]Copyright/acknowledgements.
+   
+   Use any browser - [24]Campaign for a non-browser-specific WWW
+
+References
+
+   1. http://www.chiark.greenend.org.uk/~ian/adns/adnshost.txt
+   2. http://www.chiark.greenend.org.uk/~ian/adns/adns.h.txt
+   3. http://www.chiark.greenend.org.uk/mailman/listinfo
+   4. http://www.chiark.greenend.org.uk/~ian/adns/
+   5. http://www.chiark.greenend.org.uk/~ian/adns/adns.tar.gz
+   6. http://www.chiark.greenend.org.uk/~ian/adns/adns.h.txt
+   7. http://www.chiark.greenend.org.uk/~ian/adns/adnshost.txt
+   8. ftp://ftp.chiark.greenend.org.uk/users/ian/adns/
+   9. http://www.chiark.greenend.org.uk/~ian/adns/ftp/
+  10. http://www.chiark.greenend.org.uk/ucgi/~ijackson/cvsweb/adns/
+  11. http://www.gnu.org/
+  12. http://www.gnu.org/order/ftp.html
+  13. http://www.isc.org/view.cgi?/products/BIND/index.phtml
+  14. http://www.dents.org/
+  15. http://www.chiark.greenend.org.uk/~ian/COPYING.txt
+  16. http://www.fsf.org/
+  17. http://www.chiark.greenend.org.uk/
+  18. mailto:adns-maint@chiark.greenend.org.uk
+  19. http://www.chiark.greenend.org.uk/~ian/software/
+  20. http://www.gnu.org/
+  21. http://www.chiark.greenend.org.uk/
+  22. file://localhost/
+  23. http://www.chiark.greenend.org.uk/~ian/sw-www-copy.html
+  24. http://www.anybrowser.org/campaign/
Index: adns/check.c
===================================================================
--- adns/check.c	(revision 0)
+++ adns/check.c	(revision 0)
@@ -0,0 +1,209 @@
+/*
+ * check.c: $Id: check.c,v 1.3 2003/05/09 02:20:55 db Exp $
+ *  
+ */
+/*
+ * check.c
+ * - consistency checks
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-1999 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ */
+
+#include "internal.h"
+
+/* This crap is needed to make it compile on OS X
+ * Leave it to apple to take a perfectly good preprocessor and fuck it
+ * up.
+ */
+#define unused_arg /**/
+
+void adns_checkconsistency(adns_state ads, adns_query qu) {
+  adns__consistency(ads,qu,cc_user);
+}
+
+#define DLIST_CHECK(list, nodevar, part, body)					\
+  if ((list).head) {								\
+    assert(! (list).head->part back);						\
+    for ((nodevar)= (list).head; (nodevar); (nodevar)= (nodevar)->part next) {	\
+      assert((nodevar)->part next						\
+	     ? (nodevar) == (nodevar)->part next->part back			\
+	     : (nodevar) == (list).tail);					\
+      body									\
+    }										\
+  }
+
+#define DLIST_ASSERTON(node, nodevar, list, part)				\
+  do {										\
+    for ((nodevar)= (list).head;						\
+	 (nodevar) != (node);							\
+	 (nodevar)= (nodevar)->part next) {					\
+      assert((nodevar));							\
+    }										\
+  } while(0)
+
+static void checkc_query_alloc(adns_state ads, adns_query qu) {
+  allocnode *an;
+
+  DLIST_CHECK(qu->allocations, an, , {
+  });
+}
+
+static void checkc_query(adns_state ads, adns_query qu) {
+  adns_query child;
+
+  assert(qu->udpnextserver < ads->nservers);
+  assert(!(qu->udpsent & (~0UL << ads->nservers)));
+  assert(qu->search_pos <= ads->nsearchlist);
+  if (qu->parent) DLIST_ASSERTON(qu, child, qu->parent->children, siblings.);
+}
+
+static void checkc_notcpbuf(adns_state ads) {
+  assert(!ads->tcpsend.used);
+  assert(!ads->tcprecv.used);
+  assert(!ads->tcprecv_skip);
+}
+
+static void checkc_global(adns_state ads) {
+  int i;
+  
+  assert(ads->udpsocket >= 0);
+
+  for (i=0; i<ads->nsortlist; i++)
+    assert(!(ads->sortlist[i].base.s_addr & ~ads->sortlist[i].mask.s_addr));
+
+  assert(ads->tcpserver >= 0 && ads->tcpserver < ads->nservers);
+  
+  switch (ads->tcpstate) {
+  case server_connecting:
+    assert(ads->tcpsocket >= 0);
+    checkc_notcpbuf(ads);
+    break;
+  case server_disconnected:
+  case server_broken:
+    assert(ads->tcpsocket == -1);
+    checkc_notcpbuf(ads);
+    break;
+  case server_ok:
+    assert(ads->tcpsocket >= 0);
+    assert(ads->tcprecv_skip <= ads->tcprecv.used);
+    break;
+  default:
+    assert(!"ads->tcpstate value");
+  }
+
+  assert(ads->searchlist || !ads->nsearchlist);
+}
+
+static void checkc_queue_udpw(adns_state ads) {
+  adns_query qu;
+  
+  DLIST_CHECK(ads->udpw, qu, , {
+    assert(qu->state==query_tosend);
+    assert(qu->retries <= UDPMAXRETRIES);
+    assert(qu->udpsent);
+    assert(!qu->children.head && !qu->children.tail);
+    checkc_query(ads,qu);
+    checkc_query_alloc(ads,qu);
+  });
+}
+
+static void checkc_queue_tcpw(adns_state ads) {
+  adns_query qu;
+  
+  DLIST_CHECK(ads->tcpw, qu, , {
+    assert(qu->state==query_tcpw);
+    assert(!qu->children.head && !qu->children.tail);
+    assert(qu->retries <= ads->nservers+1);
+    checkc_query(ads,qu);
+    checkc_query_alloc(ads,qu);
+  });
+}
+
+static void checkc_queue_childw(adns_state ads) {
+  adns_query parent, child;
+
+  DLIST_CHECK(ads->childw, parent, , {
+    assert(parent->state == query_childw);
+    assert(parent->children.head);
+    DLIST_CHECK(parent->children, child, siblings., {
+      assert(child->parent == parent);
+      assert(child->state != query_done);
+    });
+    checkc_query(ads,parent);
+    checkc_query_alloc(ads,parent);
+  });
+}
+
+static void checkc_queue_output(adns_state ads) {
+  adns_query qu;
+  
+  DLIST_CHECK(ads->output, qu, , {
+    assert(qu->state == query_done);
+    assert(!qu->children.head && !qu->children.tail);
+    assert(!qu->parent);
+    assert(!qu->allocations.head && !qu->allocations.tail);
+    checkc_query(ads,qu);
+  });
+}
+
+void adns__consistency(adns_state ads, adns_query qu, consistency_checks cc) {
+  adns_query search;
+  
+  switch (cc) {
+  case cc_user:
+    break;
+  case cc_entex:
+    if (!(ads->iflags & adns_if_checkc_entex)) return;
+    break;
+  case cc_freq:
+    if ((ads->iflags & adns_if_checkc_freq) != adns_if_checkc_freq) return;
+    break;
+  default:
+    abort();
+  }
+
+  checkc_global(ads);
+  checkc_queue_udpw(ads);
+  checkc_queue_tcpw(ads);
+  checkc_queue_childw(ads);
+  checkc_queue_output(ads);
+
+  if (qu) {
+    switch (qu->state) {
+    case query_tosend:
+      DLIST_ASSERTON(qu, search, ads->udpw, unused_arg);
+      break;
+    case query_tcpw:
+      DLIST_ASSERTON(qu, search, ads->tcpw, unused_arg);
+      break;
+    case query_childw:
+      DLIST_ASSERTON(qu, search, ads->childw, unused_arg);
+      break;
+    case query_done:
+      DLIST_ASSERTON(qu, search, ads->output, unused_arg);
+      break;
+    default:
+      assert(!"specific query state");
+    }
+  }
+}
Index: adns/general.c
===================================================================
--- adns/general.c	(revision 0)
+++ adns/general.c	(revision 0)
@@ -0,0 +1,361 @@
+/*
+ * general.c: $Id: general.c,v 1.4 2003/06/24 03:57:12 ievil Exp $
+ *  
+ */
+/*
+ * general.c
+ * - diagnostic functions
+ * - vbuf handling
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ *
+ * $Id: general.c,v 1.4 2003/06/24 03:57:12 ievil Exp $
+ */
+
+#include "fileio.h"
+#include "s_log.h"
+#include "memory.h"
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include "internal.h"
+#include "irc_string.h"
+/* Core diagnostic functions */
+
+#define LOG_BUFSIZE 2000
+
+#if 0
+void adns__vdiag(adns_state ads, const char *pfx, adns_initflags prevent,
+		 int serv, adns_query qu, const char *fmt, va_list al)
+{
+
+/* Fix this to log to the ircd log interface */
+#if 0
+  const char *bef, *aft;
+  vbuf vb;
+  
+  vfprintf(ads->diagfile,fmt,al);
+
+  bef= " (";
+  aft= "\n";
+
+  if (qu && qu->query_dgram) {
+    adns__vbuf_init(&vb);
+    fprintf(ads->diagfile,"%sQNAME=%s, QTYPE=%s",
+	    bef,
+	    adns__diag_domain(qu->ads,-1,0, &vb,
+			      qu->query_dgram,qu->query_dglen,DNS_HDRSIZE),
+	    qu->typei ? qu->typei->rrtname : "<unknown>");
+    if (qu->typei && qu->typei->fmtname)
+      fprintf(ads->diagfile,"(%s)",qu->typei->fmtname);
+    bef=", "; aft=")\n";
+    adns__vbuf_free(&vb);
+  }
+  
+  if (serv>=0) {
+    fprintf(ads->diagfile,"%sNS=%s",bef,inetntoa((unsigned char *)&ads->servers[serv].addr));
+    bef=", "; aft=")\n";
+  }
+
+  fputs(aft,ads->diagfile);
+#endif
+}
+#endif
+
+void adns__debug(adns_state ads, int serv, adns_query qu, const char *fmt, ...) {
+  char    buf[LOG_BUFSIZE];
+  va_list al;
+
+  va_start(al,fmt);
+  vsprintf(buf, fmt, al);
+#if 0
+  adns__vdiag(ads," debug",0,serv,qu,fmt,al);
+#endif
+  va_end(al);
+
+  /* redundant calls to vsprintf() but what can you do,
+   * when you live in a shoe?
+   */
+  logprintf(L_DEBUG, "%s", buf);
+}
+
+void adns__warn(adns_state ads, int serv, adns_query qu, const char *fmt, ...) {
+  char    buf[LOG_BUFSIZE];
+  va_list al;
+
+  va_start(al,fmt);
+  vsprintf(buf, fmt, al);
+#if 0
+  adns__vdiag(ads," warning",adns_if_noerrprint|adns_if_noserverwarn,serv,qu,fmt,al);
+#endif
+  va_end(al);
+
+  logprintf(L_WARN, "%s", buf);
+}
+
+void adns__diag(adns_state ads, int serv, adns_query qu, const char *fmt, ...) {
+  char    buf[LOG_BUFSIZE];
+  va_list al;
+
+  va_start(al,fmt);
+  vsprintf(buf, fmt, al);
+#if 0
+  adns__vdiag(ads,"",adns_if_noerrprint,serv,qu,fmt,al);
+#endif
+  va_end(al);
+
+  logprintf(L_DEBUG, "%s", buf);
+}
+
+/* vbuf functions */
+
+void adns__vbuf_init(vbuf *vb) {
+  vb->used= vb->avail= 0; vb->buf= 0;
+}
+
+int adns__vbuf_ensure(vbuf *vb, int want) {
+  void *nb;
+  
+  if (vb->avail >= want) return 1;
+  nb= MyRealloc(vb->buf,want); if (!nb) return 0;
+  vb->buf= nb;
+  vb->avail= want;
+  return 1;
+}
+  
+void adns__vbuf_appendq(vbuf *vb, const byte *ddata, int len) {
+  memcpy(vb->buf+vb->used,ddata,len);
+  vb->used+= len;
+}
+
+int adns__vbuf_append(vbuf *vb, const byte *ddata, int len) {
+  int newlen;
+  void *nb;
+
+  newlen= vb->used+len;
+  if (vb->avail < newlen) {
+    if (newlen<20) newlen= 20;
+    newlen <<= 1;
+    nb= MyRealloc(vb->buf,newlen);
+    if (!nb) { newlen= vb->used+len; nb= MyRealloc(vb->buf,newlen); }
+    if (!nb) return 0;
+    vb->buf= nb;
+    vb->avail= newlen;
+  }
+  adns__vbuf_appendq(vb,ddata,len);
+  return 1;
+}
+
+int adns__vbuf_appendstr(vbuf *vb, const char *ddata) {
+  int l;
+  l= strlen(ddata);
+  return adns__vbuf_append(vb,(const byte *)ddata,l);
+}
+
+void adns__vbuf_free(vbuf *vb) {
+  MyFree(vb->buf);
+  adns__vbuf_init(vb);
+}
+
+/* Additional diagnostic functions */
+
+const char *adns__diag_domain(adns_state ads, int serv, adns_query qu,
+			      vbuf *vb, const byte *dgram, int dglen, int cbyte) {
+  adns_status st;
+
+  st= adns__parse_domain(ads,serv,qu,vb, pdf_quoteok, dgram,dglen,&cbyte,dglen);
+  if (st == adns_s_nomemory) {
+    return "<cannot report domain... out of memory>";
+  }
+  if (st) {
+    vb->used= 0;
+    if (!(adns__vbuf_appendstr(vb,"<bad format... ") &&
+	  adns__vbuf_appendstr(vb,adns_strerror(st)) &&
+	  adns__vbuf_appendstr(vb,">") &&
+	  adns__vbuf_append(vb,(const byte *)"",1))) {
+      return "<cannot report bad format... out of memory>";
+    }
+  }
+  if (!vb->used) {
+    adns__vbuf_appendstr(vb,"<truncated ...>");
+    adns__vbuf_append(vb,(const byte *)"",1);
+  }
+  return (const char *)vb->buf;
+}
+
+adns_status adns_rr_info(adns_rrtype type,
+			 const char **rrtname_r, const char **fmtname_r,
+			 int *len_r,
+			 const void *datap, char **data_r) {
+  const typeinfo *typei;
+  vbuf vb;
+  adns_status st;
+
+  typei= adns__findtype(type);
+  if (!typei) return adns_s_unknownrrtype;
+
+  if (rrtname_r) *rrtname_r= typei->rrtname;
+  if (fmtname_r) *fmtname_r= typei->fmtname;
+  if (len_r) *len_r= typei->rrsz;
+
+  if (!datap) return adns_s_ok;
+  
+  adns__vbuf_init(&vb);
+  st= typei->convstring(&vb,datap);
+  if (st) goto x_freevb;
+  if (!adns__vbuf_append(&vb,(const byte *)"",1)) { st= adns_s_nomemory; goto x_freevb; }
+  assert(strlen((const char *)vb.buf) == vb.used-1);
+  *data_r= MyRealloc(vb.buf,vb.used);
+  if (!*data_r) *data_r= (char *)vb.buf;
+  return adns_s_ok;
+
+ x_freevb:
+  adns__vbuf_free(&vb);
+  return st;
+}
+
+
+#define SINFO(n,s) { adns_s_##n, #n, s }
+
+static const struct sinfo {
+  adns_status st;
+  const char *abbrev;
+  const char *string;
+} sinfos[]= {
+  SINFO(  ok,                  "OK"                                            ),
+
+  SINFO(  nomemory,            "Out of memory"                                 ),
+  SINFO(  unknownrrtype,       "Query not implemented in DNS library"          ),
+  SINFO(  systemfail,          "General resolver or system failure"            ),
+
+  SINFO(  timeout,             "DNS query timed out"                           ),
+  SINFO(  allservfail,         "All nameservers failed"                        ),
+  SINFO(  norecurse,           "Recursion denied by nameserver"                ),
+  SINFO(  invalidresponse,     "Nameserver sent bad response"                  ),
+  SINFO(  unknownformat,       "Nameserver used unknown format"                ),
+
+  SINFO(  rcodeservfail,       "Nameserver reports failure"                    ),
+  SINFO(  rcodeformaterror,    "Query not understood by nameserver"            ),
+  SINFO(  rcodenotimplemented, "Query not implemented by nameserver"           ),
+  SINFO(  rcoderefused,        "Query refused by nameserver"                   ),
+  SINFO(  rcodeunknown,        "Nameserver sent unknown response code"         ),
+  
+  SINFO(  inconsistent,        "Inconsistent resource records in DNS"          ),
+  SINFO(  prohibitedcname,     "DNS alias found where canonical name wanted"   ),
+  SINFO(  answerdomaininvalid, "Found syntactically invalid domain name"       ),
+  SINFO(  answerdomaintoolong, "Found overly-long domain name"                 ),
+  SINFO(  invaliddata,         "Found invalid DNS data"                        ),
+
+  SINFO(  querydomainwrong,    "Domain invalid for particular DNS query type"  ),
+  SINFO(  querydomaininvalid,  "Domain name is syntactically invalid"          ),
+  SINFO(  querydomaintoolong,  "Domain name or component is too long"          ),
+
+  SINFO(  nxdomain,            "No such domain"                                ),
+  SINFO(  nodata,              "No such data"                                  )
+};
+
+static int si_compar(const void *key, const void *elem) {
+  const adns_status *st= key;
+  const struct sinfo *si= elem;
+
+  return *st < si->st ? -1 : *st > si->st ? 1 : 0;
+}
+
+static const struct sinfo *findsinfo(adns_status st) {
+  return bsearch(&st,sinfos,sizeof(sinfos)/sizeof(*sinfos),sizeof(*sinfos),si_compar);
+}
+
+const char *adns_strerror(adns_status st) {
+  const struct sinfo *si;
+
+  si= findsinfo(st);
+  return si->string;
+}
+
+const char *adns_errabbrev(adns_status st) {
+  const struct sinfo *si;
+
+  si= findsinfo(st);
+  return si->abbrev;
+}
+
+
+#define STINFO(max) { adns_s_max_##max, #max }
+
+static const struct stinfo {
+  adns_status stmax;
+  const char *abbrev;
+} stinfos[]= {
+  { adns_s_ok, "ok" },
+  STINFO(  localfail   ),
+  STINFO(  remotefail  ),
+  STINFO(  tempfail    ),
+  STINFO(  misconfig   ),
+  STINFO(  misquery    ),
+  STINFO(  permfail    )
+};
+
+static int sti_compar(const void *key, const void *elem) {
+  const adns_status *st= key;
+  const struct stinfo *sti= elem;
+
+  adns_status here, min, max;
+
+  here= *st;
+  min= (sti==stinfos) ? 0 : sti[-1].stmax+1;
+  max= sti->stmax;
+  
+  return here < min  ? -1 : here > max ? 1 : 0;
+}
+
+const char *adns_errtypeabbrev(adns_status st) {
+  const struct stinfo *sti;
+
+  sti= bsearch(&st,stinfos,sizeof(stinfos)/sizeof(*stinfos),sizeof(*stinfos),sti_compar);
+  return sti->abbrev;
+}
+
+
+void adns__isort(void *array, int nobjs, int sz, void *tempbuf,
+		 int (*needswap)(void *context, const void *a, const void *b),
+		 void *context) {
+  byte *ddata= array;
+  int i, place;
+
+  for (i=0; i<nobjs; i++) {
+    for (place= i;
+	 place>0 && needswap(context, ddata + (place-1)*sz, ddata + i*sz);
+	 place--);
+    if (place != i) {
+      memcpy(tempbuf, ddata + i*sz, sz);
+      memmove(ddata + (place+1)*sz, ddata + place*sz, (i-place)*sz);
+      memcpy(ddata + place*sz, tempbuf, sz);
+    }
+  }
+}
+
Index: adns/event.c
===================================================================
--- adns/event.c	(revision 0)
+++ adns/event.c	(revision 0)
@@ -0,0 +1,731 @@
+/*
+ * event.c: $Id: event.c,v 1.8 2003/06/24 03:14:30 ievil Exp $
+ *  
+ */
+/*
+ * event.c
+ * - event loop core
+ * - TCP connection management
+ * - user-visible check/wait and event-loop-related functions
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <netdb.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include "internal.h"
+#include "tvarith.h"
+
+/* TCP connection management. */
+
+static void tcp_close(adns_state ads) {
+  int serv;
+  
+  serv= ads->tcpserver;
+  close(ads->tcpsocket);
+  ads->tcpsocket= -1;
+  ads->tcprecv.used= ads->tcprecv_skip= ads->tcpsend.used= 0;
+}
+
+void adns__tcp_broken(adns_state ads, const char *what, const char *why) {
+  int serv;
+  adns_query qu;
+  
+  assert(ads->tcpstate == server_connecting || ads->tcpstate == server_ok);
+  serv= ads->tcpserver;
+  if (what) adns__warn(ads,serv,0,"TCP connection failed: %s: %s",what,why);
+
+  if (ads->tcpstate == server_connecting) {
+    /* Counts as a retry for all the queries waiting for TCP. */
+    for (qu= ads->tcpw.head; qu; qu= qu->next)
+      qu->retries++;
+  }
+
+  tcp_close(ads);
+  ads->tcpstate= server_broken;
+  ads->tcpserver= (serv+1)%ads->nservers;
+}
+
+static void tcp_connected(adns_state ads, struct timeval now) {
+  adns_query qu, nqu;
+  
+  adns__debug(ads,ads->tcpserver,0,"TCP connected");
+  ads->tcpstate= server_ok;
+  for (qu= ads->tcpw.head; qu && ads->tcpstate == server_ok; qu= nqu) {
+    nqu= qu->next;
+    assert(qu->state == query_tcpw);
+    adns__querysend_tcp(qu,now);
+  }
+}
+
+void adns__tcp_tryconnect(adns_state ads, struct timeval now) {
+  int r, fd, tries;
+  struct sockaddr_in addr;
+
+  for (tries=0; tries<ads->nservers; tries++) {
+    switch (ads->tcpstate) {
+    case server_connecting:
+    case server_ok:
+    case server_broken:
+      return;
+    case server_disconnected:
+      break;
+    default:
+      abort();
+    }
+    
+    assert(!ads->tcpsend.used);
+    assert(!ads->tcprecv.used);
+    assert(!ads->tcprecv_skip);
+
+    fd= socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
+    if (fd<0) {
+      adns__diag(ads,-1,0,"cannot create TCP socket: %s",strerror(errno));
+      return;
+    }
+    r= adns__setnonblock(ads,fd);
+    if (r) {
+      adns__diag(ads,-1,0,"cannot make TCP socket nonblocking: %s",strerror(r));
+      close(fd);
+      return;
+    }
+    memset(&addr,0,sizeof(addr));
+    addr.sin_family= AF_INET;
+    addr.sin_port= htons(DNS_PORT);
+    addr.sin_addr= ads->servers[ads->tcpserver].addr;
+    r= connect(fd,(const struct sockaddr*)&addr,sizeof(addr));
+    ads->tcpsocket= fd;
+    ads->tcpstate= server_connecting;
+    if (r==0) { tcp_connected(ads,now); return; }
+    if (errno == EWOULDBLOCK || errno == EINPROGRESS) {
+      ads->tcptimeout= now;
+      timevaladd(&ads->tcptimeout,TCPCONNMS);
+      return;
+    }
+    adns__tcp_broken(ads,"connect",strerror(errno));
+    ads->tcpstate= server_disconnected;
+  }
+}
+
+/* Timeout handling functions. */
+
+void adns__must_gettimeofday(adns_state ads, const struct timeval **now_io,
+			     struct timeval *tv_buf) {
+  const struct timeval *now;
+  int r;
+
+  now= *now_io;
+  if (now) return;
+  r= gettimeofday(tv_buf,0); if (!r) { *now_io= tv_buf; return; }
+  adns__diag(ads,-1,0,"gettimeofday failed: %s",strerror(errno));
+  adns_globalsystemfailure(ads);
+  return;
+}
+
+static void inter_immed(struct timeval **tv_io, struct timeval *tvbuf) {
+  struct timeval *rbuf;
+
+  if (!tv_io) return;
+
+  rbuf= *tv_io;
+  if (!rbuf) { *tv_io= rbuf= tvbuf; }
+
+  timerclear(rbuf);
+}
+    
+static void inter_maxto(struct timeval **tv_io, struct timeval *tvbuf,
+			struct timeval maxto) {
+  struct timeval *rbuf;
+
+  if (!tv_io) return;
+  rbuf= *tv_io;
+  if (!rbuf) {
+    *tvbuf= maxto; *tv_io= tvbuf;
+  } else {
+    if (timercmp(rbuf,&maxto,>)) *rbuf= maxto;
+  }
+/*fprintf(stderr,"inter_maxto maxto=%ld.%06ld result=%ld.%06ld\n",
+	maxto.tv_sec,maxto.tv_usec,(**tv_io).tv_sec,(**tv_io).tv_usec);*/
+}
+
+static void inter_maxtoabs(struct timeval **tv_io, struct timeval *tvbuf,
+			   struct timeval now, struct timeval maxtime) {
+  /* tv_io may be 0 */
+  ldiv_t dr;
+
+/*fprintf(stderr,"inter_maxtoabs now=%ld.%06ld maxtime=%ld.%06ld\n",
+	now.tv_sec,now.tv_usec,maxtime.tv_sec,maxtime.tv_usec);*/
+  if (!tv_io) return;
+  maxtime.tv_sec -= (now.tv_sec+2);
+  maxtime.tv_usec -= (now.tv_usec-2000000);
+  dr= ldiv(maxtime.tv_usec,1000000);
+  maxtime.tv_sec += dr.quot;
+  maxtime.tv_usec -= dr.quot*1000000;
+  if (maxtime.tv_sec<0) timerclear(&maxtime);
+  inter_maxto(tv_io,tvbuf,maxtime);
+}
+
+static void timeouts_queue(adns_state ads, int act,
+			   struct timeval **tv_io, struct timeval *tvbuf,
+			   struct timeval now, struct query_queue *queue) {
+  adns_query qu, nqu;
+  
+  for (qu= queue->head; qu; qu= nqu) {
+    nqu= qu->next;
+    if (!timercmp(&now,&qu->timeout,>)) {
+      inter_maxtoabs(tv_io,tvbuf,now,qu->timeout);
+    } else {
+      if (!act) { inter_immed(tv_io,tvbuf); return; }
+      DLIST_UNLINK(*queue,qu);
+      if (qu->state != query_tosend) {
+	adns__query_fail(qu,adns_s_timeout);
+      } else {
+	adns__query_send(qu,now);
+      }
+      nqu= queue->head;
+    }
+  }
+}
+
+static void tcp_events(adns_state ads, int act,
+		       struct timeval **tv_io, struct timeval *tvbuf,
+		       struct timeval now) {
+  adns_query qu, nqu;
+  
+  for (;;) {
+    switch (ads->tcpstate) {
+    case server_broken:
+      if (!act) { inter_immed(tv_io,tvbuf); return; }
+      for (qu= ads->tcpw.head; qu; qu= nqu) {
+	nqu= qu->next;
+	assert(qu->state == query_tcpw);
+	if (qu->retries > ads->nservers) {
+	  DLIST_UNLINK(ads->tcpw,qu);
+	  adns__query_fail(qu,adns_s_allservfail);
+	}
+      }
+      ads->tcpstate= server_disconnected;
+    case server_disconnected: /* fall through */
+      if (!ads->tcpw.head) return;
+      if (!act) { inter_immed(tv_io,tvbuf); return; }
+      for (qu= ads->tcpw.head; qu; qu= nqu) {
+       nqu= qu->next;
+       assert(qu->state == query_tcpw);
+       if (qu->retries > ads->nservers) {
+         DLIST_UNLINK(ads->tcpw,qu);
+         adns__query_fail(qu,adns_s_allservfail);
+       }
+      }
+      adns__tcp_tryconnect(ads,now);
+      break;
+    case server_ok:
+      if (ads->tcpw.head) return;
+      if (!ads->tcptimeout.tv_sec) {
+	assert(!ads->tcptimeout.tv_usec);
+	ads->tcptimeout= now;
+	timevaladd(&ads->tcptimeout,TCPIDLEMS);
+      }
+    case server_connecting: /* fall through */
+      if (!act || !timercmp(&now,&ads->tcptimeout,>)) {
+	inter_maxtoabs(tv_io,tvbuf,now,ads->tcptimeout);
+	return;
+      } {
+	/* TCP timeout has happened */
+	switch (ads->tcpstate) {
+	case server_connecting: /* failed to connect */
+	  adns__tcp_broken(ads,"unable to make connection","timed out");
+	  break;
+	case server_ok: /* idle timeout */
+	  tcp_close(ads);
+	  ads->tcpstate= server_disconnected;
+	  return;
+	default:
+	  abort();
+	}
+      }
+      break;
+    default:
+      abort();
+    }
+  }
+  return;
+}
+
+void adns__timeouts(adns_state ads, int act,
+		    struct timeval **tv_io, struct timeval *tvbuf,
+		    struct timeval now) {
+  timeouts_queue(ads,act,tv_io,tvbuf,now, &ads->udpw);
+  timeouts_queue(ads,act,tv_io,tvbuf,now, &ads->tcpw);
+  tcp_events(ads,act,tv_io,tvbuf,now);
+}
+
+void adns_firsttimeout(adns_state ads,
+		       struct timeval **tv_io, struct timeval *tvbuf,
+		       struct timeval now) {
+  adns__consistency(ads,0,cc_entex);
+  adns__timeouts(ads, 0, tv_io,tvbuf, now);
+  adns__consistency(ads,0,cc_entex);
+}
+
+void adns_processtimeouts(adns_state ads, const struct timeval *now) {
+  struct timeval tv_buf;
+
+  adns__consistency(ads,0,cc_entex);
+  adns__must_gettimeofday(ads,&now,&tv_buf);
+  if (now) adns__timeouts(ads, 1, 0,0, *now);
+  adns__consistency(ads,0,cc_entex);
+}
+
+/* fd handling functions.  These are the top-level of the real work of
+ * reception and often transmission.
+ */
+
+int adns__pollfds(adns_state ads, struct pollfd pollfds_buf[MAX_POLLFDS]) {
+  /* Returns the number of entries filled in.  Always zeroes revents. */
+
+  assert(MAX_POLLFDS==2);
+
+  pollfds_buf[0].fd= ads->udpsocket;
+  pollfds_buf[0].events= POLLIN;
+  pollfds_buf[0].revents= 0;
+
+  switch (ads->tcpstate) {
+  case server_disconnected:
+  case server_broken:
+    return 1;
+  case server_connecting:
+    pollfds_buf[1].events= POLLOUT;
+    break;
+  case server_ok:
+    pollfds_buf[1].events= ads->tcpsend.used ? POLLIN|POLLOUT|POLLPRI : POLLIN|POLLPRI;
+    break;
+  default:
+    abort();
+  }
+  pollfds_buf[1].fd= ads->tcpsocket;
+  return 2;
+}
+
+int adns_processreadable(adns_state ads, int fd, const struct timeval *now) {
+  int want, dgramlen, r, udpaddrlen, serv, old_skip;
+  byte udpbuf[DNS_MAXUDP];
+  struct sockaddr_in udpaddr;
+  
+  adns__consistency(ads,0,cc_entex);
+
+  switch (ads->tcpstate) {
+  case server_disconnected:
+  case server_broken:
+  case server_connecting:
+    break;
+  case server_ok:
+    if (fd != ads->tcpsocket) break;
+    assert(!ads->tcprecv_skip);
+    do {
+      if (ads->tcprecv.used >= ads->tcprecv_skip+2) {
+	dgramlen= ((ads->tcprecv.buf[ads->tcprecv_skip]<<8) |
+	           ads->tcprecv.buf[ads->tcprecv_skip+1]);
+	if (ads->tcprecv.used >= ads->tcprecv_skip+2+dgramlen) {
+	  old_skip= ads->tcprecv_skip;
+	  ads->tcprecv_skip += 2+dgramlen;
+	  adns__procdgram(ads, ads->tcprecv.buf+old_skip+2,
+			  dgramlen, ads->tcpserver, 1,*now);
+	  continue;
+	} else {
+	  want= 2+dgramlen;
+	}
+      } else {
+	want= 2;
+      }
+      ads->tcprecv.used -= ads->tcprecv_skip;
+      memmove(ads->tcprecv.buf,ads->tcprecv.buf+ads->tcprecv_skip,ads->tcprecv.used);
+      ads->tcprecv_skip= 0;
+      if (!adns__vbuf_ensure(&ads->tcprecv,want)) { r= ENOMEM; goto xit; }
+      assert(ads->tcprecv.used <= ads->tcprecv.avail);
+      if (ads->tcprecv.used == ads->tcprecv.avail) continue;
+      r= read(ads->tcpsocket,
+	      ads->tcprecv.buf+ads->tcprecv.used,
+	      ads->tcprecv.avail-ads->tcprecv.used);
+      if (r>0) {
+	ads->tcprecv.used+= r;
+      } else {
+	if (r) {
+	  if (errno==EAGAIN || errno==EWOULDBLOCK) { r= 0; goto xit; }
+	  if (errno==EINTR) continue;
+	  if (errno_resources(errno)) { r= errno; goto xit; }
+	}
+	adns__tcp_broken(ads,"read",r?strerror(errno):"closed");
+      }
+    } while (ads->tcpstate == server_ok);
+    r= 0; goto xit;
+  default:
+    abort();
+  }
+  if (fd == ads->udpsocket) {
+    for (;;) {
+      udpaddrlen= sizeof(udpaddr);
+      r= recvfrom(ads->udpsocket,udpbuf,sizeof(udpbuf),0,
+		  (struct sockaddr*)&udpaddr,&udpaddrlen);
+      if (r<0) {
+	if (errno == EAGAIN || errno == EWOULDBLOCK) { r= 0; goto xit; }
+	if (errno == EINTR) continue;
+	if (errno_resources(errno)) { r= errno; goto xit; }
+	adns__warn(ads,-1,0,"datagram receive error: %s",strerror(errno));
+	r= 0; goto xit;
+      }
+      if (udpaddrlen != sizeof(udpaddr)) {
+	adns__diag(ads,-1,0,"datagram received with wrong address length %d"
+		   " (expected %lu)", udpaddrlen,
+		   (unsigned long)sizeof(udpaddr));
+	continue;
+      }
+      if (udpaddr.sin_family != AF_INET) {
+	adns__diag(ads,-1,0,"datagram received with wrong protocol family"
+		   " %u (expected %u)",udpaddr.sin_family,AF_INET);
+	continue;
+      }
+      if (ntohs(udpaddr.sin_port) != DNS_PORT) {
+	adns__diag(ads,-1,0,"datagram received from wrong port %u (expected %u)",
+		   ntohs(udpaddr.sin_port),DNS_PORT);
+	continue;
+      }
+      for (serv= 0;
+	   serv < ads->nservers &&
+	     ads->servers[serv].addr.s_addr != udpaddr.sin_addr.s_addr;
+	   serv++);
+      if (serv >= ads->nservers) {
+	adns__warn(ads,-1,0,"datagram received from unknown nameserver %s",
+		   inet_ntoa(udpaddr.sin_addr));
+	continue;
+      }
+      adns__procdgram(ads,udpbuf,r,serv,0,*now);
+    }
+  }
+  r= 0;
+xit:
+  adns__consistency(ads,0,cc_entex);
+  return r;
+}
+
+int adns_processwriteable(adns_state ads, int fd, const struct timeval *now) {
+  int r;
+  
+  adns__consistency(ads,0,cc_entex);
+
+  switch (ads->tcpstate) {
+  case server_disconnected:
+  case server_broken:
+    break;
+  case server_connecting:
+    if (fd != ads->tcpsocket) break;
+    assert(ads->tcprecv.used==0);
+    assert(ads->tcprecv_skip==0);
+    for (;;) {
+      if (!adns__vbuf_ensure(&ads->tcprecv,1)) { r= ENOMEM; goto xit; }
+      r= read(ads->tcpsocket,&ads->tcprecv.buf,1);
+      if (r==0 || (r<0 && (errno==EAGAIN || errno==EWOULDBLOCK))) {
+	tcp_connected(ads,*now);
+	r= 0; goto xit;
+      }
+      if (r>0) {
+	adns__tcp_broken(ads,"connect/read","sent data before first request");
+	r= 0; goto xit;
+      }
+      if (errno==EINTR) continue;
+      if (errno_resources(errno)) { r= errno; goto xit; }
+      adns__tcp_broken(ads,"connect/read",strerror(errno));
+      r= 0; goto xit;
+    } /* not reached */
+  case server_ok:
+    if (fd != ads->tcpsocket) break;
+    while (ads->tcpsend.used) {
+      r= write(ads->tcpsocket,ads->tcpsend.buf,ads->tcpsend.used);
+      if (r<0) {
+	if (errno==EINTR) continue;
+	if (errno==EAGAIN || errno==EWOULDBLOCK) { r= 0; goto xit; }
+	if (errno_resources(errno)) { r= errno; goto xit; }
+	adns__tcp_broken(ads,"write",strerror(errno));
+	r= 0; goto xit;
+      } else if (r>0) {
+	ads->tcpsend.used -= r;
+	memmove(ads->tcpsend.buf,ads->tcpsend.buf+r,ads->tcpsend.used);
+      }
+    }
+    r= 0;
+    goto xit;
+  default:
+    abort();
+  }
+  r= 0;
+xit:
+  adns__consistency(ads,0,cc_entex);
+  return r;
+}
+  
+int adns_processexceptional(adns_state ads, int fd, const struct timeval *now) {
+  adns__consistency(ads,0,cc_entex);
+  switch (ads->tcpstate) {
+  case server_disconnected:
+  case server_broken:
+    break;
+  case server_connecting:
+  case server_ok:
+    if (fd != ads->tcpsocket) break;
+    adns__tcp_broken(ads,"poll/select","exceptional condition detected");
+    break;
+  default:
+    abort();
+  }
+  adns__consistency(ads,0,cc_entex);
+  return 0;
+}
+
+static void fd_event(adns_state ads, int fd,
+		     int revent, int pollflag,
+		     int maxfd, const fd_set *fds,
+		     int (*func)(adns_state, int fd, const struct timeval *now),
+		     struct timeval now, int *r_r) {
+  int r;
+  
+  if (!(revent & pollflag)) return;
+  if (fds && !(fd<maxfd && FD_ISSET(fd,fds))) return;
+  r= func(ads,fd,&now);
+  if (r) {
+    if (r_r) {
+      *r_r= r;
+    } else {
+      adns__diag(ads,-1,0,"process fd failed after select: %s",strerror(errno));
+      adns_globalsystemfailure(ads);
+    }
+  }
+}
+
+void adns__fdevents(adns_state ads,
+		    const struct pollfd *pollfds, int npollfds,
+		    int maxfd, const fd_set *readfds,
+		    const fd_set *writefds, const fd_set *exceptfds,
+		    struct timeval now, int *r_r) {
+  int i, fd, revents;
+
+  for (i=0; i<npollfds; i++) {
+    fd= pollfds[i].fd;
+    if (fd >= maxfd) maxfd= fd+1;
+    revents= pollfds[i].revents;
+    fd_event(ads,fd, revents,POLLIN, maxfd,readfds, adns_processreadable,now,r_r);
+    fd_event(ads,fd, revents,POLLOUT, maxfd,writefds, adns_processwriteable,now,r_r);
+    fd_event(ads,fd, revents,POLLPRI, maxfd,exceptfds, adns_processexceptional,now,r_r);
+  }
+}
+
+/* Wrappers for select(2). */
+
+void adns_beforeselect(adns_state ads, int *maxfd_io, fd_set *readfds_io,
+		       fd_set *writefds_io, fd_set *exceptfds_io,
+		       struct timeval **tv_mod, struct timeval *tv_tobuf,
+		       const struct timeval *now) {
+  struct timeval tv_nowbuf;
+  struct pollfd pollfds[MAX_POLLFDS];
+  int i, fd, maxfd, npollfds;
+  
+  adns__consistency(ads,0,cc_entex);
+
+  if (tv_mod && (!*tv_mod || (*tv_mod)->tv_sec || (*tv_mod)->tv_usec)) {
+    /* The caller is planning to sleep. */
+    adns__must_gettimeofday(ads,&now,&tv_nowbuf);
+    if (!now) { inter_immed(tv_mod,tv_tobuf); goto xit; }
+    adns__timeouts(ads, 0, tv_mod,tv_tobuf, *now);
+  }
+
+  npollfds= adns__pollfds(ads,pollfds);
+  maxfd= *maxfd_io;
+  for (i=0; i<npollfds; i++) {
+    fd= pollfds[i].fd;
+    if (fd >= maxfd) maxfd= fd+1;
+    if (pollfds[i].events & POLLIN) FD_SET(fd,readfds_io);
+    if (pollfds[i].events & POLLOUT) FD_SET(fd,writefds_io);
+    if (pollfds[i].events & POLLPRI) FD_SET(fd,exceptfds_io);
+  }
+  *maxfd_io= maxfd;
+
+xit:
+  adns__consistency(ads,0,cc_entex);
+}
+
+void adns_afterselect(adns_state ads, int maxfd, const fd_set *readfds,
+		      const fd_set *writefds, const fd_set *exceptfds,
+		      const struct timeval *now) {
+  struct timeval tv_buf;
+  struct pollfd pollfds[MAX_POLLFDS];
+  int npollfds, i;
+
+  adns__consistency(ads,0,cc_entex);
+  adns__must_gettimeofday(ads,&now,&tv_buf);
+  if (!now) goto xit;
+  adns_processtimeouts(ads,now);
+
+  npollfds= adns__pollfds(ads,pollfds);
+  for (i=0; i<npollfds; i++) pollfds[i].revents= POLLIN|POLLOUT|POLLPRI;
+  adns__fdevents(ads,
+		 pollfds,npollfds,
+		 maxfd,readfds,writefds,exceptfds,
+		 *now, 0);
+xit:
+  adns__consistency(ads,0,cc_entex);
+}
+
+/* General helpful functions. */
+
+void adns_globalsystemfailure(adns_state ads) {
+  adns__consistency(ads,0,cc_entex);
+
+  while (ads->udpw.head) adns__query_fail(ads->udpw.head, adns_s_systemfail);
+  while (ads->tcpw.head) adns__query_fail(ads->tcpw.head, adns_s_systemfail);
+  
+  switch (ads->tcpstate) {
+  case server_connecting:
+  case server_ok:
+    adns__tcp_broken(ads,0,0);
+    break;
+  case server_disconnected:
+  case server_broken:
+    break;
+  default:
+    abort();
+  }
+  adns__consistency(ads,0,cc_entex);
+}
+
+int adns_processany(adns_state ads) {
+  int r, i;
+  struct timeval now;
+  struct pollfd pollfds[MAX_POLLFDS];
+  int npollfds;
+
+  adns__consistency(ads,0,cc_entex);
+
+  r= gettimeofday(&now,0);
+  if (!r) adns_processtimeouts(ads,&now);
+
+  /* We just use adns__fdevents to loop over the fd's trying them.
+   * This seems more sensible than calling select, since we're most
+   * likely just to want to do a read on one or two fds anyway.
+   */
+  npollfds= adns__pollfds(ads,pollfds);
+  for (i=0; i<npollfds; i++) pollfds[i].revents= pollfds[i].events & ~POLLPRI;
+  adns__fdevents(ads,
+		 pollfds,npollfds,
+		 0,0,0,0,
+		 now,&r);
+
+  adns__consistency(ads,0,cc_entex);
+  return 0;
+}
+
+void adns__autosys(adns_state ads, struct timeval now) {
+  if (ads->iflags & adns_if_noautosys) return;
+  adns_processany(ads);
+}
+
+int adns__internal_check(adns_state ads,
+			 adns_query *query_io,
+			 adns_answer **answer,
+			 void **context_r) {
+  adns_query qu;
+
+  qu= *query_io;
+  if (!qu) {
+    if (ads->output.head) {
+      qu= ads->output.head;
+    } else if (ads->udpw.head || ads->tcpw.head) {
+      return EAGAIN;
+    } else {
+      return ESRCH;
+    }
+  } else {
+    if (qu->id>=0) return EAGAIN;
+  }
+  DLIST_UNLINK(ads->output,qu);
+  *answer= qu->answer;
+  if (context_r) *context_r= qu->ctx.ext;
+  *query_io= qu;
+  MyFree(qu);
+  return 0;
+}
+
+int adns_wait(adns_state ads,
+	      adns_query *query_io,
+	      adns_answer **answer_r,
+	      void **context_r) {
+  int r, maxfd, rsel;
+  fd_set readfds, writefds, exceptfds;
+  struct timeval tvbuf, *tvp;
+  
+  adns__consistency(ads,*query_io,cc_entex);
+  for (;;) {
+    r= adns__internal_check(ads,query_io,answer_r,context_r);
+    if (r != EAGAIN) break;
+    maxfd= 0; tvp= 0;
+    FD_ZERO(&readfds); FD_ZERO(&writefds); FD_ZERO(&exceptfds);
+    adns_beforeselect(ads,&maxfd,&readfds,&writefds,&exceptfds,&tvp,&tvbuf,0);
+    assert(tvp);
+    rsel= select(maxfd,&readfds,&writefds,&exceptfds,tvp);
+    if (rsel==-1) {
+      if (errno == EINTR) {
+	if (ads->iflags & adns_if_eintr) { r= EINTR; break; }
+      } else {
+	adns__diag(ads,-1,0,"select failed in wait: %s",strerror(errno));
+	adns_globalsystemfailure(ads);
+      }
+    } else {
+      assert(rsel >= 0);
+      adns_afterselect(ads,maxfd,&readfds,&writefds,&exceptfds,0);
+    }
+  }
+  adns__consistency(ads,0,cc_entex);
+  return r;
+}
+
+int adns_check(adns_state ads,
+	       adns_query *query_io,
+	       adns_answer **answer_r,
+	       void **context_r) {
+  struct timeval now;
+  int r;
+  
+  adns__consistency(ads,*query_io,cc_entex);
+  r= gettimeofday(&now,0);
+  if (!r) adns__autosys(ads,now);
+
+  r= adns__internal_check(ads,query_io,answer_r,context_r);
+  adns__consistency(ads,0,cc_entex);
+  return r;
+}
Index: adns/internal.h
===================================================================
--- adns/internal.h	(revision 0)
+++ adns/internal.h	(revision 0)
@@ -0,0 +1,730 @@
+/*
+ * internal.h: $Id: internal.h,v 1.8 2002/02/06 04:56:09 androsyn Exp $
+ *  
+ */
+/*
+ * internal.h
+ * - declarations of private objects with external linkage (adns__*)
+ * - definitons of internal macros
+ * - comments regarding library data structures
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef ADNS_INTERNAL_H_INCLUDED
+#define ADNS_INTERNAL_H_INCLUDED
+
+#include "config.h"
+typedef unsigned char byte;
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <unistd.h>
+#include <signal.h>
+#include <errno.h>
+#include <string.h>
+
+#include <sys/time.h>
+
+#include "adns.h"
+#include "dlist.h"
+
+#ifdef ADNS_REGRESS_TEST
+# include "hredirect.h"
+#endif
+
+/* Configuration and constants */
+
+#define MAXSERVERS 5
+#define MAXSORTLIST 15
+#define UDPMAXRETRIES 15
+#define UDPRETRYMS 1500
+#define TCPWAITMS 30000
+#define TCPCONNMS 14000
+#define TCPIDLEMS 30000
+#define MAXTTLBELIEVE (7*86400) /* any TTL > 7 days is capped */
+
+#define DNS_PORT 53
+#define DNS_MAXUDP 512
+#define DNS_MAXLABEL 63
+#define DNS_MAXDOMAIN 255
+#define DNS_HDRSIZE 12
+#define DNS_IDOFFSET 0
+#define DNS_CLASS_IN 1
+
+#define DNS_INADDR_ARPA "in-addr", "arpa"
+
+#define MAX_POLLFDS  ADNS_POLLFDS_RECOMMENDED
+
+typedef enum {
+  cc_user,
+  cc_entex,
+  cc_freq
+} consistency_checks;
+
+typedef enum {
+  rcode_noerror,
+  rcode_formaterror,
+  rcode_servfail,
+  rcode_nxdomain,
+  rcode_notimp,
+  rcode_refused
+} dns_rcode;
+
+/* Shared data structures */
+
+typedef union {
+  adns_status status;
+  char *cp;
+  adns_rrtype type;
+  int i;
+  struct in_addr ia;
+  unsigned long ul;
+} rr_align;
+
+typedef struct {
+  int used, avail;
+  byte *buf;
+} vbuf;
+
+typedef struct {
+  adns_state ads;
+  adns_query qu;
+  int serv;
+  const byte *dgram;
+  int dglen, nsstart, nscount, arcount;
+  struct timeval now;
+} parseinfo;
+
+typedef struct {
+  adns_rrtype type;
+  const char *rrtname;
+  const char *fmtname;
+  int rrsz;
+
+  void (*makefinal)(adns_query qu, void *data);
+  /* Change memory management of *data.
+   * Previously, used alloc_interim, now use alloc_final.
+   */
+
+  adns_status (*convstring)(vbuf *vb, const void *data);
+  /* Converts the RR data to a string representation in vbuf.
+   * vbuf will be appended to (it must have been initialised),
+   * and will not be null-terminated by convstring.
+   */
+
+  adns_status (*parse)(const parseinfo *pai, int cbyte, int max, void *store_r);
+  /* Parse one RR, in dgram of length dglen, starting at cbyte and
+   * extending until at most max.
+   *
+   * The RR should be stored at *store_r, of length qu->typei->rrsz.
+   *
+   * If there is an overrun which might indicate truncation, it should set
+   * *rdstart to -1; otherwise it may set it to anything else positive.
+   *
+   * nsstart is the offset of the authority section.
+   */
+
+  int (*diff_needswap)(adns_state ads, const void *datap_a, const void *datap_b);
+  /* Returns !0 if RR a should be strictly after RR b in the sort order,
+   * 0 otherwise.  Must not fail.
+   */
+} typeinfo;
+
+typedef struct allocnode {
+  struct allocnode *next, *back;
+} allocnode;
+
+union maxalign {
+  byte d[1];
+  struct in_addr ia;
+  long l;
+  void *p;
+  void (*fp)(void);
+  union maxalign *up;
+} data;
+
+typedef struct {
+  void *ext;
+  void (*callback)(adns_query parent, adns_query child);
+  union {
+    adns_rr_addr ptr_parent_addr;
+    adns_rr_hostaddr *hostaddr;
+  } info;
+} qcontext;
+
+struct adns__query {
+  adns_state ads;
+  enum { query_tosend, query_tcpw, query_childw, query_done } state;
+  adns_query back, next, parent;
+  struct { adns_query head, tail; } children;
+  struct { adns_query back, next; } siblings;
+  struct { allocnode *head, *tail; } allocations;
+  int interim_allocd, preserved_allocd;
+  void *final_allocspace;
+  const typeinfo *typei;
+  byte *query_dgram;
+  int query_dglen;
+
+  vbuf vb;
+  /* General-purpose messing-about buffer.
+   * Wherever a `big' interface is crossed, this may be corrupted/changed
+   * unless otherwise specified.
+   */
+
+  adns_answer *answer;
+  /* This is allocated when a query is submitted, to avoid being unable
+   * to relate errors to queries if we run out of memory.  During
+   * query processing status, rrs is 0.  cname is set if
+   * we found a cname (this corresponds to cname_dgram in the query
+   * structure).  type is set from the word go.  nrrs and rrs
+   * are set together, when we find how many rrs there are.
+   * owner is set during querying unless we're doing searchlist,
+   * in which case it is set only when we find an answer.
+   */
+
+  byte *cname_dgram;
+  int cname_dglen, cname_begin;
+  int cname_count;
+
+  /* If non-0, has been allocated using . */
+
+  vbuf search_vb;
+  int search_origlen, search_pos, search_doneabs;
+  /* Used by the searching algorithm.  The query domain in textual form
+   * is copied into the vbuf, and _origlen set to its length.  Then
+   * we walk the searchlist, if we want to.  _pos says where we are
+   * (next entry to try), and _doneabs says whether we've done the
+   * absolute query yet (0=not yet, 1=done, -1=must do straight away,
+   * but not done yet).  If flags doesn't have adns_qf_search then
+   * the vbuf is initialised but empty and everything else is zero.
+   */
+
+  int id, flags, retries;
+  int udpnextserver;
+  unsigned long udpsent; /* bitmap indexed by server */
+  struct timeval timeout;
+  time_t expires; /* Earliest expiry time of any record we used. */
+
+  qcontext ctx;
+
+  /* Possible states:
+   *
+   *  state   Queue   child  id   nextudpserver  udpsent     tcpfailed
+   *
+   *  tosend  NONE    null   >=0  0              zero        zero
+   *  tosend  udpw    null   >=0  any            nonzero     zero
+   *  tosend  NONE    null   >=0  any            nonzero     zero
+   *
+   *  tcpw    tcpw    null   >=0  irrelevant     any         any
+   *
+   *  child   childw  set    >=0  irrelevant     irrelevant  irrelevant
+   *  child   NONE    null   >=0  irrelevant     irrelevant  irrelevant
+   *  done    output  null   -1   irrelevant     irrelevant  irrelevant
+   *
+   * Queries are only not on a queue when they are actually being processed.
+   * Queries in state tcpw/tcpw have been sent (or are in the to-send buffer)
+   * iff the tcp connection is in state server_ok.
+   *
+   *			      +------------------------+
+   *             START -----> |      tosend/NONE       |
+   *			      +------------------------+
+   *                         /                       |\  \
+   *        too big for UDP /             UDP timeout  \  \ send via UDP
+   *        send via TCP   /              more retries  \  \
+   *        when conn'd   /                  desired     \  \
+   *                     |     	       	       	       	  |  |
+   *                     v				  |  v
+   *              +-----------+         	    	+-------------+
+   *              | tcpw/tcpw | ________                | tosend/udpw |
+   *              +-----------+         \	    	+-------------+
+   *                 |    |              |     UDP timeout | |
+   *                 |    |              |      no more    | |
+   *                 |    |              |      retries    | |
+   *                  \   | TCP died     |      desired    | |
+   *                   \   \ no more     |                 | |
+   *                    \   \ servers    | TCP            /  |
+   *                     \   \ to try    | timeout       /   |
+   *                  got \   \          v             |_    | got
+   *                 reply \   _| +------------------+      / reply
+   *   	       	       	    \  	  | done/output FAIL |     /
+   *                         \    +------------------+    /
+   *                          \                          /
+   *                           _|                      |_
+   *                             (..... got reply ....)
+   *                              /                   \
+   *        need child query/ies /                     \ no child query
+   *                            /                       \
+   *                          |_                         _|
+   *		   +---------------+		       +----------------+
+   *               | childw/childw | ----------------> | done/output OK |
+   *               +---------------+  children done    +----------------+
+   */
+};
+
+struct query_queue { adns_query head, tail; };
+
+struct adns__state {
+  adns_initflags iflags;
+  FILE *diagfile;
+  int configerrno;
+  struct query_queue udpw, tcpw, childw, output;
+  adns_query forallnext;
+  int nextid, udpsocket, tcpsocket;
+  vbuf tcpsend, tcprecv;
+  int nservers, nsortlist, nsearchlist, searchndots, tcpserver, tcprecv_skip;
+  enum adns__tcpstate {
+    server_disconnected, server_connecting,
+    server_ok, server_broken
+  } tcpstate;
+  struct timeval tcptimeout;
+  /* This will have tv_sec==0 if it is not valid.  It will always be
+   * valid if tcpstate _connecting.  When _ok, it will be nonzero if
+   * we are idle (ie, tcpw queue is empty), in which case it is the
+   * absolute time when we will close the connection.
+   */
+  struct sigaction stdsigpipe;
+  sigset_t stdsigmask;
+  struct pollfd pollfds_buf[MAX_POLLFDS];
+  struct server {
+    struct in_addr addr;
+  } servers[MAXSERVERS];
+  struct sortlist {
+    struct in_addr base, mask;
+  } sortlist[MAXSORTLIST];
+  char **searchlist;
+};
+
+/* From setup.c: */
+
+int adns__setnonblock(adns_state ads, int fd); /* => errno value */
+
+/* From general.c: */
+
+void adns__vdiag(adns_state ads, const char *pfx, adns_initflags prevent,
+		 int serv, adns_query qu, const char *fmt, va_list al);
+
+void adns__debug(adns_state ads, int serv, adns_query qu,
+		 const char *fmt, ...);
+void adns__warn(adns_state ads, int serv, adns_query qu,
+		const char *fmt, ...);
+void adns__diag(adns_state ads, int serv, adns_query qu,
+		const char *fmt, ...) ;
+
+int adns__vbuf_ensure(vbuf *vb, int want);
+int adns__vbuf_appendstr(vbuf *vb, const char *); /* does not include nul */
+int adns__vbuf_append(vbuf *vb, const byte *, int len);
+/* 1=>success, 0=>realloc failed */
+void adns__vbuf_appendq(vbuf *vb, const byte *, int len);
+void adns__vbuf_init(vbuf *vb);
+void adns__vbuf_free(vbuf *vb);
+
+const char *adns__diag_domain(adns_state ads, int serv, adns_query qu,
+			      vbuf *vb, const byte *dgram, int dglen, int cbyte);
+/* Unpicks a domain in a datagram and returns a string suitable for
+ * printing it as.  Never fails - if an error occurs, it will
+ * return some kind of string describing the error.
+ *
+ * serv may be -1 and qu may be 0.  vb must have been initialised,
+ * and will be left in an arbitrary consistent state.
+ *
+ * Returns either vb->buf, or a pointer to a string literal.  Do not modify
+ * vb before using the return value.
+ */
+
+void adns__isort(void *array, int nobjs, int sz, void *tempbuf,
+		 int (*needswap)(void *context, const void *a, const void *b),
+		 void *context);
+/* Does an insertion sort of array which must contain nobjs objects
+ * each sz bytes long.  tempbuf must point to a buffer at least
+ * sz bytes long.  needswap should return !0 if a>b (strictly, ie
+ * wrong order) 0 if a<=b (ie, order is fine).
+ */
+
+void adns__sigpipe_protect(adns_state);
+void adns__sigpipe_unprotect(adns_state);
+/* If SIGPIPE protection is not disabled, will block all signals except
+ * SIGPIPE, and set SIGPIPE's disposition to SIG_IGN.  (And then restore.)
+ * Each call to _protect must be followed by a call to _unprotect before
+ * any significant amount of code gets to run, since the old signal mask
+ * is stored in the adns structure.
+ */
+
+/* From transmit.c: */
+
+adns_status adns__mkquery(adns_state ads, vbuf *vb, int *id_r,
+			  const char *owner, int ol,
+			  const typeinfo *typei, adns_queryflags flags);
+/* Assembles a query packet in vb.  A new id is allocated and returned.
+ */
+
+adns_status adns__mkquery_frdgram(adns_state ads, vbuf *vb, int *id_r,
+				  const byte *qd_dgram, int qd_dglen, int qd_begin,
+				  adns_rrtype type, adns_queryflags flags);
+/* Same as adns__mkquery, but takes the owner domain from an existing datagram.
+ * That domain must be correct and untruncated.
+ */
+
+void adns__querysend_tcp(adns_query qu, struct timeval now);
+/* Query must be in state tcpw/tcpw; it will be sent if possible and
+ * no further processing can be done on it for now.  The connection
+ * might be broken, but no reconnect will be attempted.
+ */
+
+void adns__query_send(adns_query qu, struct timeval now);
+/* Query must be in state tosend/NONE; it will be moved to a new state,
+ * and no further processing can be done on it for now.
+ * (Resulting state is one of udp/timew, tcpwait/timew (if server not connected),
+ *  tcpsent/timew, child/childw or done/output.)
+ * __query_send may decide to use either UDP or TCP depending whether
+ * _qf_usevc is set (or has become set) and whether the query is too
+ * large.
+ */
+
+/* From query.c: */
+
+adns_status adns__internal_submit(adns_state ads, adns_query *query_r,
+				  const typeinfo *typei, vbuf *qumsg_vb, int id,
+				  adns_queryflags flags, struct timeval now,
+				  const qcontext *ctx);
+/* Submits a query (for internal use, called during external submits).
+ *
+ * The new query is returned in *query_r, or we return adns_s_nomemory.
+ *
+ * The query datagram should already have been assembled in qumsg_vb;
+ * the memory for it is _taken over_ by this routine whether it
+ * succeeds or fails (if it succeeds, the vbuf is reused for qu->vb).
+ *
+ * *ctx is copied byte-for-byte into the query.
+ *
+ * When the child query is done, ctx->callback will be called.  The
+ * child will already have been taken off both the global list of
+ * queries in ads and the list of children in the parent.  The child
+ * will be freed when the callback returns.  The parent will have been
+ * taken off the global childw queue.
+ *
+ * The callback should either call adns__query_done, if it is
+ * complete, or adns__query_fail, if an error has occurred, in which
+ * case the other children (if any) will be cancelled.  If the parent
+ * has more unfinished children (or has just submitted more) then the
+ * callback may choose to wait for them - it must then put the parent
+ * back on the childw queue.
+ */
+
+void adns__search_next(adns_state ads, adns_query qu, struct timeval now);
+/* Walks down the searchlist for a query with adns_qf_search.
+ * The query should have just had a negative response, or not had
+ * any queries sent yet, and should not be on any queue.
+ * The query_dgram if any will be freed and forgotten and a new
+ * one constructed from the search_* members of the query.
+ *
+ * Cannot fail (in case of error, calls adns__query_fail).
+ */
+
+void *adns__alloc_interim(adns_query qu, size_t sz);
+void *adns__alloc_preserved(adns_query qu, size_t sz);
+/* Allocates some memory, and records which query it came from
+ * and how much there was.
+ *
+ * If an error occurs in the query, all the memory from _interim is
+ * simply freed.  If the query succeeds, one large buffer will be made
+ * which is big enough for all these allocations, and then
+ * adns__alloc_final will get memory from this buffer.
+ *
+ * _alloc_interim can fail (and return 0).
+ * The caller must ensure that the query is failed.
+ *
+ * The memory from _preserved is is kept and transferred into the
+ * larger buffer - unless we run out of memory, in which case it too
+ * is freed.  When you use _preserved you have to add code to the
+ * x_nomem error exit case in adns__makefinal_query to clear out the
+ * pointers you made to those allocations, because that's when they're
+ * thrown away; you should also make a note in the declaration of
+ * those pointer variables, to note that they are _preserved rather
+ * than _interim.  If they're in the answer, note it here:
+ *  answer->cname and answer->owner are _preserved.
+ */
+
+void adns__transfer_interim(adns_query from, adns_query to, void *block, size_t sz);
+/* Transfers an interim allocation from one query to another, so that
+ * the `to' query will have room for the data when we get to makefinal
+ * and so that the free will happen when the `to' query is freed
+ * rather than the `from' query.
+ *
+ * It is legal to call adns__transfer_interim with a null pointer; this
+ * has no effect.
+ *
+ * _transfer_interim also ensures that the expiry time of the `to' query
+ * is no later than that of the `from' query, so that child queries'
+ * TTLs get inherited by their parents.
+ */
+
+void *adns__alloc_mine(adns_query qu, size_t sz);
+/* Like _interim, but does not record the length for later
+ * copying into the answer.  This just ensures that the memory
+ * will be freed when we're done with the query.
+ */
+
+void *adns__alloc_final(adns_query qu, size_t sz);
+/* Cannot fail, and cannot return 0.
+ */
+
+void adns__makefinal_block(adns_query qu, void **blpp, size_t sz);
+void adns__makefinal_str(adns_query qu, char **strp);
+
+void adns__reset_preserved(adns_query qu);
+/* Resets all of the memory management stuff etc. to take account of
+ * only the _preserved stuff from _alloc_preserved.  Used when we find
+ * an error somewhere and want to just report the error (with perhaps
+ * CNAME, owner, etc. info), and also when we're halfway through RRs
+ * in a datagram and discover that we need to retry the query.
+ */
+
+void adns__query_done(adns_query qu);
+void adns__query_fail(adns_query qu, adns_status);
+
+/* From reply.c: */
+
+void adns__procdgram(adns_state ads, const byte *dgram, int len,
+		     int serv, int viatcp, struct timeval now);
+/* This function is allowed to cause new datagrams to be constructed
+ * and sent, or even new queries to be started.  However,
+ * query-sending functions are not allowed to call any general event
+ * loop functions in case they accidentally call this.
+ *
+ * Ie, receiving functions may call sending functions.
+ * Sending functions may NOT call receiving functions.
+ */
+
+/* From types.c: */
+
+const typeinfo *adns__findtype(adns_rrtype type);
+
+/* From parse.c: */
+
+typedef struct {
+  adns_state ads;
+  adns_query qu;
+  int serv;
+  const byte *dgram;
+  int dglen, max, cbyte, namelen;
+  int *dmend_r;
+} findlabel_state;
+
+void adns__findlabel_start(findlabel_state *fls, adns_state ads,
+			   int serv, adns_query qu,
+			   const byte *dgram, int dglen, int max,
+			   int dmbegin, int *dmend_rlater);
+/* Finds labels in a domain in a datagram.
+ *
+ * Call this routine first.
+ * dmend_rlater may be null.  ads (and of course fls) may not be.
+ * serv may be -1, qu may be null - they are for error reporting.
+ */
+
+adns_status adns__findlabel_next(findlabel_state *fls, int *lablen_r, int *labstart_r);
+/* Then, call this one repeatedly.
+ *
+ * It will return adns_s_ok if all is well, and tell you the length
+ * and start of successive labels.  labstart_r may be null, but
+ * lablen_r must not be.
+ *
+ * After the last label, it will return with *lablen_r zero.
+ * Do not then call it again; instead, just throw away the findlabel_state.
+ *
+ * *dmend_rlater will have been set to point to the next part of
+ * the datagram after the label (or after the uncompressed part,
+ * if compression was used).  *namelen_rlater will have been set
+ * to the length of the domain name (total length of labels plus
+ * 1 for each intervening dot).
+ *
+ * If the datagram appears to be truncated, *lablen_r will be -1.
+ * *dmend_rlater, *labstart_r and *namelen_r may contain garbage.
+ * Do not call _next again.
+ *
+ * There may also be errors, in which case *dmend_rlater,
+ * *namelen_rlater, *lablen_r and *labstart_r may contain garbage.
+ * Do not then call findlabel_next again.
+ */
+
+typedef enum {
+  pdf_quoteok= 0x001
+} parsedomain_flags;
+
+adns_status adns__parse_domain(adns_state ads, int serv, adns_query qu,
+			       vbuf *vb, parsedomain_flags flags,
+			       const byte *dgram, int dglen, int *cbyte_io, int max);
+/* vb must already have been initialised; it will be reset if necessary.
+ * If there is truncation, vb->used will be set to 0; otherwise
+ * (if there is no error) vb will be null-terminated.
+ * If there is an error vb and *cbyte_io may be left indeterminate.
+ *
+ * serv may be -1 and qu may be 0 - they are used for error reporting only.
+ */
+
+adns_status adns__parse_domain_more(findlabel_state *fls, adns_state ads,
+				    adns_query qu, vbuf *vb, parsedomain_flags flags,
+				    const byte *dgram);
+/* Like adns__parse_domain, but you pass it a pre-initialised findlabel_state,
+ * for continuing an existing domain or some such of some kind.  Also, unlike
+ * _parse_domain, the domain data will be appended to vb, rather than replacing
+ * the existing contents.
+ */
+
+adns_status adns__findrr(adns_query qu, int serv,
+			 const byte *dgram, int dglen, int *cbyte_io,
+			 int *type_r, int *class_r, unsigned long *ttl_r,
+			 int *rdlen_r, int *rdstart_r,
+			 int *ownermatchedquery_r);
+/* Finds the extent and some of the contents of an RR in a datagram
+ * and does some checks.  The datagram is *dgram, length dglen, and
+ * the RR starts at *cbyte_io (which is updated afterwards to point
+ * to the end of the RR).
+ *
+ * The type, class, TTL and RRdata length and start are returned iff
+ * the corresponding pointer variables are not null.  type_r, class_r
+ * and ttl_r may not be null.  The TTL will be capped.
+ *
+ * If ownermatchedquery_r != 0 then the owner domain of this
+ * RR will be compared with that in the query (or, if the query
+ * has gone to a CNAME lookup, with the canonical name).
+ * In this case, *ownermatchedquery_r will be set to 0 or 1.
+ * The query datagram (or CNAME datagram) MUST be valid and not truncated.
+ *
+ * If there is truncation then *type_r will be set to -1 and
+ * *cbyte_io, *class_r, *rdlen_r, *rdstart_r and *eo_matched_r will be
+ * undefined.
+ *
+ * qu must obviously be non-null.
+ *
+ * If an error is returned then *type_r will be undefined too.
+ */
+
+adns_status adns__findrr_anychk(adns_query qu, int serv,
+				const byte *dgram, int dglen, int *cbyte_io,
+				int *type_r, int *class_r, unsigned long *ttl_r,
+				int *rdlen_r, int *rdstart_r,
+				const byte *eo_dgram, int eo_dglen, int eo_cbyte,
+				int *eo_matched_r);
+/* Like adns__findrr_checked, except that the datagram and
+ * owner to compare with can be specified explicitly.
+ *
+ * If the caller thinks they know what the owner of the RR ought to
+ * be they can pass in details in eo_*: this is another (or perhaps
+ * the same datagram), and a pointer to where the putative owner
+ * starts in that datagram.  In this case *eo_matched_r will be set
+ * to 1 if the datagram matched or 0 if it did not.  Either
+ * both eo_dgram and eo_matched_r must both be non-null, or they
+ * must both be null (in which case eo_dglen and eo_cbyte will be ignored).
+ * The eo datagram and contained owner domain MUST be valid and
+ * untruncated.
+ */
+
+void adns__update_expires(adns_query qu, unsigned long ttl, struct timeval now);
+/* Updates the `expires' field in the query, so that it doesn't exceed
+ * now + ttl.
+ */
+
+int vbuf__append_quoted1035(vbuf *vb, const byte *buf, int len);
+
+/* From event.c: */
+
+void adns__tcp_broken(adns_state ads, const char *what, const char *why);
+/* what and why may be both 0, or both non-0. */
+
+void adns__tcp_tryconnect(adns_state ads, struct timeval now);
+
+void adns__autosys(adns_state ads, struct timeval now);
+/* Make all the system calls we want to if the application wants us to.
+ * Must not be called from within adns internal processing functions,
+ * lest we end up in recursive descent !
+ */
+
+void adns__must_gettimeofday(adns_state ads, const struct timeval **now_io,
+			     struct timeval *tv_buf);
+
+int adns__pollfds(adns_state ads, struct pollfd pollfds_buf[MAX_POLLFDS]);
+void adns__fdevents(adns_state ads,
+		    const struct pollfd *pollfds, int npollfds,
+		    int maxfd, const fd_set *readfds,
+		    const fd_set *writefds, const fd_set *exceptfds,
+		    struct timeval now, int *r_r);
+int adns__internal_check(adns_state ads,
+			 adns_query *query_io,
+			 adns_answer **answer,
+			 void **context_r);
+
+void adns__timeouts(adns_state ads, int act,
+		    struct timeval **tv_io, struct timeval *tvbuf,
+		    struct timeval now);
+/* If act is !0, then this will also deal with the TCP connection
+ * if previous events broke it or require it to be connected.
+ */
+
+/* From check.c: */
+
+void adns__consistency(adns_state ads, adns_query qu, consistency_checks cc);
+
+/* Useful static inline functions: */
+
+static inline int ctype_whitespace(int c) { return c==' ' || c=='\n' || c=='\t'; }
+static inline int ctype_digit(int c) { return c>='0' && c<='9'; }
+static inline int ctype_alpha(int c) {
+  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
+}
+static inline int ctype_822special(int c) { return strchr("()<>@,;:\\\".[]",c) != 0; }
+static inline int ctype_domainunquoted(int c) {
+  return ctype_alpha(c) || ctype_digit(c) || (strchr("-_/+",c) != 0);
+}
+
+static inline int errno_resources(int e) { return e==ENOMEM || e==ENOBUFS; }
+
+/* Useful macros */
+
+#define MEM_ROUND(sz) \
+  (( ((sz)+sizeof(union maxalign)-1) / sizeof(union maxalign) ) \
+   * sizeof(union maxalign) )
+
+#define GETIL_B(cb) (((dgram)[(cb)++]) & 0x0ff)
+#define GET_B(cb,tv) ((tv)= GETIL_B((cb)))
+#define GET_W(cb,tv) ((tv)=0, (tv)|=(GETIL_B((cb))<<8), (tv)|=GETIL_B(cb), (tv))
+#define GET_L(cb,tv) ( (tv)=0, \
+		       (tv)|=(GETIL_B((cb))<<24), \
+		       (tv)|=(GETIL_B((cb))<<16), \
+		       (tv)|=(GETIL_B((cb))<<8), \
+		       (tv)|=GETIL_B(cb), \
+		       (tv) )
+
+#ifndef timerclear
+#define timerclear(tvp)   (tvp)->tv_sec = (tvp)->tv_usec = 0
+#endif
+
+#ifndef timercmp
+#define timercmp(tvp, uvp, cmp) \
+        (((tvp)->tv_sec != (uvp)->tv_sec) ? \
+        ((tvp)->tv_sec cmp (uvp)->tv_sec) : \
+        ((tvp)->tv_usec cmp (uvp)->tv_usec))
+#endif
+
+#endif
Index: adns/GPL-vs-LGPL
===================================================================
--- adns/GPL-vs-LGPL	(revision 0)
+++ adns/GPL-vs-LGPL	(revision 0)
@@ -0,0 +1,122 @@
+              GPL vs LGPL, in the context of adns
+              -----------------------------------
+
+Several people have asked me to release GNU adns under the GNU Lesser
+General Public Licence (LGPL, formerly the Library GPL) instead of the
+`stronger' GPL.  This file is intended to answer most of these
+questions.  If you still have questions or comments, please mail me at
+<adns-maint@chiark.greenend.org.uk>.
+
+Typically there are two or three kinds of situation where people make
+this request: the first is where someone is developing a proprietary
+program and wishes to make use of adns but doesn't wish to make their
+program free software.  The second case is where a free software
+project is currently using an MIT-like licence or the LGPL and fear
+`GPL infection'.  The third case, which often overlaps with the
+second, is where another free software project currently using a
+GPL-incompatible licence, wishes to use adns.
+
+
+1. Proprietary applications of adns
+-----------------------------------
+
+So, let me get this straight.  You're writing a proprietary
+program, by which I mean that you will not be distributing source code
+and not allowing users to modify and share your software; most likely
+you are doing this for your own (personal or corporate) financial
+gain.
+
+However, you want to take advantage of adns, software which I have
+spent my time and effort on, and which I release as free software so
+that everyone can improve, share and use it.
+
+Don't you think that is a little hypocritical ?  I'm sorry, but I
+don't want you to just take my nice convenient software, without
+giving something back to the free software community or giving the
+same rights to your users as I do to you.
+
+If you really aren't the nasty kind of person I've described here, for
+example if you have a good reason other than your own selfishness for
+wanting to restrict distribution of your program, then perhaps you
+should contact me to discuss it.
+
+
+2. GPL-avoiding projects (MIT licence, et al)
+---------------------------------------------
+
+Some free software projects prefer to avoid the GPL and other licences
+which force the software always to be free.  Instead they use
+something like the MIT X licence, which allows proprietary versions of
+their software, or the in the case of some free libraries, the LGPL,
+which allows proprietary applications.  I have to say that I think
+these people are misguided, but that doesn't mean that they don't have
+a perfect right to do that.
+
+Some of these people think that merely writing to an interface
+provided by GPL'd software will cause their program to become GPL'd
+too, even if they don't distribute the GPL'd software.  I don't think
+this is the case.  I'm perfectly happy for non-GPL'd but
+GPL-compatible software to refer to adns in its source code.  However,
+I think that exectuables (or compiled libraries) which contain or are
+dynamically linked against adns must be GPL'd; likewise executable
+programs (whether compiled or in an interpreted language) which
+require utilities from adns to function properly must be GPL'd.
+
+So, you can distribute your non-GPL'd program source which needs adns
+to compile (provided it's under a GPL-compatible licence), but people
+who wish to distribute binaries must do so under the terms of the GNU
+GPL.  This may make sense for some GPL-avoiding free software
+projects; people can still make proprietary programs from your code,
+provided that they make some provision to replace adns with something
+whose copyright allows proprietary versions.
+
+However, this doesn't make much sense for the authors of LGPL'd
+libraries.  All I can say to them is to ask which is more important:
+that their library be well-constructed and use all the best technology
+available as free software, or whether it is worth degrading quality
+of their library in order to allow proprietary programs to use it !
+
+To help the case of LGPL'd libraries for which adns is not a vital
+component - for example, a library which provides access to other
+libraries so that programs which use it need only use certain parts,
+I have released adns.h (just the public header file) under the LGPL as
+well as the GPL.  See the copyright notice in adns.h for details.
+Note that this will not help you if it adns is essential to the
+functioning of your library, because all programs using your library
+must link against both your library and adns and so must be GPL'd.
+
+
+For some information and views from the Free Software Foundation on
+free software licensing, visit:
+
+ Various licenses and comments about them
+  at http://www.fsf.org/philosophy/license-list.html
+
+ Why you shouldn't use the Library GPL for your next library
+  at http://www.fsf.org/philosophy/why-not-lgpl.html
+
+
+3. GPL-incompatible free software licences
+------------------------------------------
+
+Regrettably, there are a number of free software licences (and
+semi-free licences) in existence which are not compatible with the
+GPL.  That is, they impose restrictions which are not present in the
+GPL, and therefore distributing a whole work which contains both such
+a program and a GPL'd program is not possible: either the combination
+would have to be distributed under the GPL (violating the restrictions
+made by the original author), or under the GPL-incompatible licence
+(violating the GPL).
+
+I may be prepared to make exceptions for such a licence.  Please
+contact me at <adns-maint@chiark.greenend.org.uk> with the full text
+of the GPL-incompatible licence.  However, I would usually prefer it
+if you could use a GPL-compatible licence for your project instead.
+
+
+-- Ian Jackson 17.9.2000
+
+
+Local variables:
+mode: text
+End: 
Index: adns/dlist.h
===================================================================
--- adns/dlist.h	(revision 0)
+++ adns/dlist.h	(revision 0)
@@ -0,0 +1,59 @@
+/*
+ * dlist.h: $Id: dlist.h,v 1.4 2003/05/09 02:20:55 db Exp $
+ *  
+ */
+/*
+ * dlist.h
+ * - macros for handling doubly linked lists
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-1999 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ */
+
+#ifndef ADNS_DLIST_H_INCLUDED
+#define ADNS_DLIST_H_INCLUDED
+
+#define unused_arg /**/
+
+#define DLIST_INIT(list) ((list).head= (list).tail= 0)
+#define DLINK_INIT(link) ((link).next= (link).back= 0)
+
+#define DLIST_UNLINK_PART(list,node,part) \
+  do { \
+    if ((node)->part back) (node)->part back->part next= (node)->part next; \
+      else                                  (list).head= (node)->part next; \
+    if ((node)->part next) (node)->part next->part back= (node)->part back; \
+      else                                  (list).tail= (node)->part back; \
+  } while(0)
+
+#define DLIST_LINK_TAIL_PART(list,node,part) \
+  do { \
+    (node)->part next= 0; \
+    (node)->part back= (list).tail; \
+    if ((list).tail) (list).tail->part next= (node); else (list).head= (node); \
+    (list).tail= (node); \
+  } while(0)
+
+#define DLIST_UNLINK(list,node) DLIST_UNLINK_PART(list,node,unused_arg)
+#define DLIST_LINK_TAIL(list,node) DLIST_LINK_TAIL_PART(list,node,unused_arg)
+
+#endif
Index: adns/tvarith.h
===================================================================
--- adns/tvarith.h	(revision 0)
+++ adns/tvarith.h	(revision 0)
@@ -0,0 +1,45 @@
+/*
+ * tvarith.h: $Id: tvarith.h,v 1.2 2001/12/04 16:12:11 androsyn Exp $
+ *  
+ */
+/*
+ * tvarith.h
+ * - static inline functions for doing arithmetic on timevals
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-1999 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef ADNS_TVARITH_H_INCLUDED
+#define ADNS_TVARITH_H_INCLUDED
+
+static inline void timevaladd(struct timeval *tv_io, long ms) {
+  struct timeval tmp;
+  assert(ms>=0);
+  tmp= *tv_io;
+  tmp.tv_usec += (ms%1000)*1000;
+  tmp.tv_sec += ms/1000;
+  if (tmp.tv_usec >= 1000000) { tmp.tv_sec++; tmp.tv_usec -= 1000000; }
+  *tv_io= tmp;
+}
+
+#endif
Index: adns/COPYING
===================================================================
--- adns/COPYING	(revision 0)
+++ adns/COPYING	(revision 0)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: adns/Makefile.am
===================================================================
--- adns/Makefile.am	(revision 0)
+++ adns/Makefile.am	(revision 0)
@@ -0,0 +1,5 @@
+# $Id$
+
+libadns_a_CFLAGS = -I../libircd -I.
+libadns_a_SOURCES = check.c event.c general.c parse.c query.c reply.c poll.c setup.c transmit.c types.c
+noinst_LIBRARIES = libadns.a
Index: adns/adns.h
===================================================================
--- adns/adns.h	(revision 0)
+++ adns/adns.h	(revision 0)
@@ -0,0 +1,864 @@
+/*
+ * adns.h: $Id: adns.h,v 1.5 2002/02/04 14:49:24 androsyn Exp $
+ *  
+ */
+/*
+ * adns.h
+ * - adns user-visible API (single-threaded, without any locking)
+ */
+/*
+ *
+ *  This file is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ * 
+ *  For the benefit of certain LGPL'd `omnibus' software which
+ *  provides a uniform interface to various things including adns, I
+ *  make the following additional licence.  I do this because the GPL
+ *  would otherwise force either the omnibus software to be GPL'd or
+ *  the adns-using part to be distributed separately.
+ *  
+ *  So: you may also redistribute and/or modify adns.h (but only the
+ *  public header file adns.h and not any other part of adns) under the
+ *  terms of the GNU Library General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *  
+ *  Note that adns itself is GPL'd.  Authors of adns-using applications
+ *  with GPL-incompatible licences, and people who distribute adns with
+ *  applications where the whole distribution is not GPL'd, are still
+ *  likely to be in violation of the GPL.  Anyone who wants to do this
+ *  should contact Ian Jackson.  Please note that to avoid encouraging
+ *  people to infringe the GPL as it applies to the body of adns, Ian
+ *  thinks that if you take advantage of the special exception to
+ *  redistribute just adns.h under the LGPL, you should retain this
+ *  paragraph in its place in the appropriate copyright statements.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License,
+ *  or the GNU Library General Public License, as appropriate, along
+ *  with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ *  $Id: adns.h,v 1.5 2002/02/04 14:49:24 androsyn Exp $
+ */
+
+#ifndef ADNS_H_INCLUDED
+#define ADNS_H_INCLUDED
+
+#include "config.h"
+#include <stdio.h>
+#include "irc_string.h"
+#include <sys/socket.h>
+#include <netinet/in.h>
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif /* HAVE_SYS_SELECT_H */
+#include <sys/types.h>
+#include <sys/time.h>
+#include <unistd.h>
+
+#ifdef USE_POLL
+#include <sys/poll.h>
+#else
+/* kludge it up */
+struct pollfd { int fd; short events; short revents; };
+#define POLLIN  1
+#define POLLPRI 2
+#define POLLOUT 4
+
+#endif
+
+
+#define MAXFD_POLL 2
+
+
+/* All struct in_addr anywhere in adns are in NETWORK byte order. */
+
+typedef struct adns__state *adns_state;
+typedef struct adns__query *adns_query;
+
+typedef enum {
+  adns_if_noenv=        0x0001, /* do not look at environment */
+  adns_if_noerrprint=   0x0002, /* never print output to stderr (_debug overrides) */
+  adns_if_noserverwarn= 0x0004, /* do not warn to stderr about duff nameservers etc */
+  adns_if_debug=        0x0008, /* enable all output to stderr plus debug msgs */
+  adns_if_logpid=       0x0080, /* include pid in diagnostic output */
+  adns_if_noautosys=    0x0010, /* do not make syscalls at every opportunity */
+  adns_if_eintr=        0x0020, /* allow _wait and _synchronous to return EINTR */
+  adns_if_nosigpipe=    0x0040, /* applic has SIGPIPE set to SIG_IGN, do not protect */
+  adns_if_checkc_entex= 0x0100, /* do consistency checks on entry/exit to adns funcs */
+  adns_if_checkc_freq=  0x0300  /* do consistency checks very frequently (slow!) */
+} adns_initflags;
+
+typedef enum {
+  adns_qf_search=          0x00000001, /* use the searchlist */
+  adns_qf_usevc=           0x00000002, /* use a virtual circuit (TCP connection) */
+  adns_qf_owner=           0x00000004, /* fill in the owner field in the answer */
+  adns_qf_quoteok_query=   0x00000010, /* allow special chars in query domain */
+  adns_qf_quoteok_cname=   0x00000000, /* allow ... in CNAME we go via - now default */
+  adns_qf_quoteok_anshost= 0x00000040, /* allow ... in things supposed to be hostnames */
+  adns_qf_quotefail_cname= 0x00000080, /* refuse if quote-req chars in CNAME we go via */
+  adns_qf_cname_loose=     0x00000100, /* allow refs to CNAMEs - without, get _s_cname */
+  adns_qf_cname_forbid=    0x00000200, /* don't follow CNAMEs, instead give _s_cname */
+  adns__qf_internalmask=   0x0ff00000
+} adns_queryflags;
+
+typedef enum {
+  adns__rrt_typemask=  0x0ffff,
+  adns__qtf_deref=     0x10000, /* dereference domains and perhaps produce extra data */
+  adns__qtf_mail822=   0x20000, /* make mailboxes be in RFC822 rcpt field format */
+  
+  adns_r_none=               0,
+  
+  adns_r_a=                  1,
+  
+  adns_r_ns_raw=             2,
+  adns_r_ns=                    adns_r_ns_raw|adns__qtf_deref,
+  
+  adns_r_cname=              5,
+  
+  adns_r_soa_raw=            6,
+  adns_r_soa=                   adns_r_soa_raw|adns__qtf_mail822, 
+  
+  adns_r_ptr_raw=           12,
+  adns_r_ptr=                   adns_r_ptr_raw|adns__qtf_deref,
+  
+  adns_r_hinfo=             13,  
+  
+  adns_r_mx_raw=            15,
+  adns_r_mx=                    adns_r_mx_raw|adns__qtf_deref,
+  
+  adns_r_txt=               16,
+  
+  adns_r_rp_raw=            17,
+  adns_r_rp=                    adns_r_rp_raw|adns__qtf_mail822,
+
+  adns_r_addr=                  adns_r_a|adns__qtf_deref
+  
+} adns_rrtype;
+
+/*
+ * In queries without qf_quoteok_*, all domains must have standard
+ * legal syntax, or you get adns_s_querydomainvalid (if the query
+ * domain contains bad characters) or adns_s_answerdomaininvalid (if
+ * the answer contains bad characters).
+ * 
+ * In queries _with_ qf_quoteok_*, domains in the query or response
+ * may contain any characters, quoted according to RFC1035 5.1.  On
+ * input to adns, the char* is a pointer to the interior of a "
+ * delimited string, except that " may appear in it unquoted.  On
+ * output, the char* is a pointer to a string which would be legal
+ * either inside or outside " delimiters; any character which isn't
+ * legal in a hostname (ie alphanumeric or hyphen) or one of _ / +
+ * (the three other punctuation characters commonly abused in domain
+ * names) will be quoted, as \X if it is a printing ASCII character or
+ * \DDD otherwise.
+ *
+ * If the query goes via a CNAME then the canonical name (ie, the
+ * thing that the CNAME record refers to) is usually allowed to
+ * contain any characters, which will be quoted as above.  With
+ * adns_qf_quotefail_cname you get adns_s_answerdomaininvalid when
+ * this happens.  (This is a change from version 0.4 and earlier, in
+ * which failing the query was the default, and you had to say
+ * adns_qf_quoteok_cname to avoid this; that flag is now deprecated.)
+ *
+ * In version 0.4 and earlier, asking for _raw records containing
+ * mailboxes without specifying _qf_quoteok_anshost was silly.  This
+ * is no longer the case.  In this version only parts of responses
+ * that are actually supposed to be hostnames will be refused by
+ * default if quote-requiring characters are found.
+ */
+
+/*
+ * If you ask for an RR which contains domains which are actually
+ * encoded mailboxes, and don't ask for the _raw version, then adns
+ * returns the mailbox formatted suitably for an RFC822 recipient
+ * header field.  The particular format used is that if the mailbox
+ * requires quoting according to the rules in RFC822 then the
+ * local-part is quoted in double quotes, which end at the next
+ * unescaped double quote (\ is the escape char, and is doubled, and
+ * is used to escape only \ and ").  If the local-part is legal
+ * without quoting according to RFC822, it is presented as-is.  In any
+ * case the local-part is followed by an @ and the domain.  The domain
+ * will not contain any characters not legal in hostnames.
+ *
+ * Unquoted local-parts may contain any printing 7-bit ASCII
+ * except the punctuation characters ( ) < > @ , ; : \ " [ ]
+ * I.e. they may contain alphanumerics, and the following
+ * punctuation characters:  ! # % ^ & * - _ = + { } .
+ *
+ * adns will reject local parts containing control characters (byte
+ * values 0-31, 127-159, and 255) - these appear to be legal according
+ * to RFC822 (at least 0-127) but are clearly a bad idea.  RFC1035
+ * syntax does not make any distinction between a single RFC822
+ * quoted-string containing full stops, and a series of quoted-strings
+ * separated by full stops; adns will return anything that isn't all
+ * valid atoms as a single quoted-string.  RFC822 does not allow
+ * high-bit-set characters at all, but adns does allow them in
+ * local-parts, treating them as needing quoting.
+ *
+ * If you ask for the domain with _raw then _no_ checking is done
+ * (even on the host part, regardless of adns_qf_quoteok_anshost), and
+ * you just get the domain name in master file format.
+ *
+ * If no mailbox is supplied the returned string will be `.' in either
+ * case.
+ */
+
+typedef enum {
+  adns_s_ok,
+
+  /* locally induced errors */
+  adns_s_nomemory,
+  adns_s_unknownrrtype,
+  adns_s_systemfail,
+
+  adns_s_max_localfail= 29,
+  
+  /* remotely induced errors, detected locally */
+  adns_s_timeout,
+  adns_s_allservfail,
+  adns_s_norecurse,
+  adns_s_invalidresponse,
+  adns_s_unknownformat,
+
+  adns_s_max_remotefail= 59,
+  
+  /* remotely induced errors, reported by remote server to us */
+  adns_s_rcodeservfail,
+  adns_s_rcodeformaterror,
+  adns_s_rcodenotimplemented,
+  adns_s_rcoderefused,
+  adns_s_rcodeunknown,
+
+  adns_s_max_tempfail= 99,
+
+  /* remote configuration errors */
+  adns_s_inconsistent, /* PTR gives domain whose A does not exist and match */
+  adns_s_prohibitedcname, /* CNAME found where eg A expected (not if _qf_loosecname) */
+  adns_s_answerdomaininvalid,
+  adns_s_answerdomaintoolong,
+  adns_s_invaliddata,
+  
+  adns_s_max_misconfig= 199,
+
+  /* permanent problems with the query */
+  adns_s_querydomainwrong,
+  adns_s_querydomaininvalid,
+  adns_s_querydomaintoolong,
+  
+  adns_s_max_misquery= 299,
+
+  /* permanent errors */
+  adns_s_nxdomain,
+  adns_s_nodata,
+
+  adns_s_max_permfail= 499
+  
+} adns_status;
+
+typedef struct {
+  int len;
+  union {
+    struct sockaddr sa;
+    struct sockaddr_in inet;
+  } addr;
+} adns_rr_addr;
+
+typedef struct {
+  char *host;
+  adns_status astatus;
+  int naddrs; /* temp fail => -1, perm fail => 0, s_ok => >0 */
+  adns_rr_addr *addrs;
+} adns_rr_hostaddr;
+
+typedef struct {
+  char *(array[2]);
+} adns_rr_strpair;
+
+typedef struct {
+  int i;
+  adns_rr_hostaddr ha;
+} adns_rr_inthostaddr;
+
+typedef struct {
+  /* Used both for mx_raw, in which case i is the preference and str the domain,
+   * and for txt, in which case each entry has i for the `text' length,
+   * and str for the data (which will have had an extra nul appended
+   * so that if it was plain text it is now a null-terminated string).
+   */
+  int i;
+  char *str;
+} adns_rr_intstr;
+
+typedef struct {
+  adns_rr_intstr array[2];
+} adns_rr_intstrpair;
+
+typedef struct {
+  char *mname, *rname;
+  unsigned long serial, refresh, retry, expire, minimum;
+} adns_rr_soa;
+
+typedef struct {
+  adns_status status;
+  char *cname; /* always NULL if query was for CNAME records */
+  char *owner; /* only set if requested in query flags, and may be 0 on error anyway */
+  adns_rrtype type; /* guaranteed to be same as in query */
+  time_t expires; /* expiry time, defined only if _s_ok, nxdomain or nodata. NOT TTL! */
+  int nrrs, rrsz; /* nrrs is 0 if an error occurs */
+  union {
+    void *untyped;
+    unsigned char *bytes;
+    char *(*str);                     /* ns_raw, cname, ptr, ptr_raw */
+    adns_rr_intstr *(*manyistr);      /* txt (list of strings ends with i=-1, str=0) */
+    adns_rr_addr *addr;               /* addr */
+    struct in_addr *inaddr;           /* a */
+    adns_rr_hostaddr *hostaddr;       /* ns */
+    adns_rr_intstrpair *intstrpair;   /* hinfo */
+    adns_rr_strpair *strpair;         /* rp, rp_raw */
+    adns_rr_inthostaddr *inthostaddr; /* mx */
+    adns_rr_intstr *intstr;           /* mx_raw */
+    adns_rr_soa *soa;                 /* soa, soa_raw */
+  } rrs;
+} adns_answer;
+
+/* Memory management:
+ *  adns_state and adns_query are actually pointers to malloc'd state;
+ *  On submission questions are copied, including the owner domain;
+ *  Answers are malloc'd as a single piece of memory; pointers in the
+ *  answer struct point into further memory in the answer.
+ * query_io:
+ *  Must always be non-null pointer;
+ *  If *query_io is 0 to start with then any query may be returned;
+ *  If *query_io is !0 adns_query then only that query may be returned.
+ *  If the call is successful, *query_io, *answer_r, and *context_r
+ *  will all be set.
+ * Errors:
+ *  Return values are 0 or an errno value.
+ *
+ *  For _init, _init_strcfg, _submit and _synchronous, system errors
+ *  (eg, failure to create sockets, malloc failure, etc.) return errno
+ *  values.
+ * 
+ *  For _wait and _check failures are reported in the answer
+ *  structure, and only 0, ESRCH or (for _check) EAGAIN is
+ *  returned: if no (appropriate) requests are done adns_check returns
+ *  EAGAIN; if no (appropriate) requests are outstanding both
+ *  adns_query and adns_wait return ESRCH.
+ *
+ *  Additionally, _wait can return EINTR if you set adns_if_eintr.
+ *
+ *  All other errors (nameserver failure, timed out connections, &c)
+ *  are returned in the status field of the answer.  After a
+ *  successful _wait or _check, if status is nonzero then nrrs will be
+ *  0, otherwise it will be >0.  type will always be the type
+ *  requested.
+ */
+
+int adns_init(adns_state *newstate_r, adns_initflags flags,
+	      FILE *diagfile /*0=>stderr*/);
+
+int adns_init_strcfg(adns_state *newstate_r, adns_initflags flags,
+		     FILE *diagfile /*0=>discard*/, const char *configtext);
+
+/* Configuration:
+ *  adns_init reads /etc/resolv.conf, which is expected to be (broadly
+ *  speaking) in the format expected by libresolv, and then
+ *  /etc/resolv-adns.conf if it exists.  adns_init_strcfg is instead
+ *  passed a string which is interpreted as if it were the contents of
+ *  resolv.conf or resolv-adns.conf.  In general, configuration which
+ *  is set later overrides any that is set earlier.
+ *
+ * Standard directives understood in resolv[-adns].conf:
+ * 
+ *  nameserver <address>
+ *   Must be followed by the IP address of a nameserver.  Several
+ *   nameservers may be specified, and they will be tried in the order
+ *   found.  There is a compiled in limit, currently 5, on the number
+ *   of nameservers.  (libresolv supports only 3 nameservers.)
+ *
+ *  search <domain> ...
+ *   Specifies the search list for queries which specify
+ *   adns_qf_search.  This is a list of domains to append to the query
+ *   domain.  The query domain will be tried as-is either before all
+ *   of these or after them, depending on the ndots option setting
+ *   (see below).
+ *
+ *  domain <domain>
+ *   This is present only for backward compatibility with obsolete
+ *   versions of libresolv.  It should not be used, and is interpreted
+ *   by adns as if it were `search' - note that this is subtly
+ *   different to libresolv's interpretation of this directive.
+ *
+ *  sortlist <addr>/<mask> ...
+ *   Should be followed by a sequence of IP-address and netmask pairs,
+ *   separated by spaces.  They may be specified as
+ *   eg. 172.30.206.0/24 or 172.30.206.0/255.255.255.0.  Currently up
+ *   to 15 pairs may be specified (but note that libresolv only
+ *   supports up to 10).
+ *
+ *  options
+ *   Should followed by one or more options, separated by spaces.
+ *   Each option consists of an option name, followed by optionally
+ *   a colon and a value.  Options are listed below.
+ *
+ * Non-standard directives understood in resolv[-adns].conf:
+ *
+ *  clearnameservers
+ *   Clears the list of nameservers, so that further nameserver lines
+ *   start again from the beginning.
+ *
+ *  include <filename>
+ *   The specified file will be read.
+ *
+ * Additionally, adns will ignore lines in resolv[-adns].conf which
+ * start with a #.
+ *
+ * Standard options understood:
+ *
+ *  debug
+ *   Enables debugging output from the resolver, which will be written
+ *   to stderr.
+ *
+ *  ndots:<count>
+ *   Affects whether queries with adns_qf_search will be tried first
+ *   without adding domains from the searchlist, or whether the bare
+ *   query domain will be tried last.  Queries which contain at least
+ *   <count> dots will be tried bare first.  The default is 1.
+ *
+ * Non-standard options understood:
+ *
+ *  adns_checkc:none
+ *  adns_checkc:entex
+ *  adns_checkc:freq
+ *   Changes the consistency checking frequency; this overrides the
+ *   setting of adns_if_check_entex, adns_if_check_freq, or neither,
+ *   in the flags passed to adns_init.
+ * 
+ * There are a number of environment variables which can modify the
+ * behaviour of adns.  They take effect only if adns_init is used, and
+ * the caller of adns_init can disable them using adns_if_noenv.  In
+ * each case there is both a FOO and an ADNS_FOO; the latter is
+ * interpreted later so that it can override the former.  Unless
+ * otherwise stated, environment variables are interpreted after
+ * resolv[-adns].conf are read, in the order they are listed here.
+ *
+ *  RES_CONF, ADNS_RES_CONF
+ *   A filename, whose contets are in the format of resolv.conf.
+ *
+ *  RES_CONF_TEXT, ADNS_RES_CONF_TEXT
+ *   A string in the format of resolv.conf.
+ *
+ *  RES_OPTIONS, ADNS_RES_OPTIONS
+ *   These are parsed as if they appeared in the `options' line of a
+ *   resolv.conf.  In addition to being parsed at this point in the
+ *   sequence, they are also parsed at the very beginning before
+ *   resolv.conf or any other environment variables are read, so that
+ *   any debug option can affect the processing of the configuration.
+ *
+ *  LOCALDOMAIN, ADNS_LOCALDOMAIN
+ *   These are interpreted as if their contents appeared in a `search'
+ *   line in resolv.conf.
+ */
+
+int adns_synchronous(adns_state ads,
+		     const char *owner,
+		     adns_rrtype type,
+		     adns_queryflags flags,
+		     adns_answer **answer_r);
+
+/* NB: if you set adns_if_noautosys then _submit and _check do not
+ * make any system calls; you must use some of the asynch-io event
+ * processing functions to actually get things to happen.
+ */
+
+int adns_submit(adns_state ads,
+		const char *owner,
+		adns_rrtype type,
+		adns_queryflags flags,
+		void *context,
+		adns_query *query_r);
+
+/* The owner should be quoted in master file format. */
+
+int adns_check(adns_state ads,
+	       adns_query *query_io,
+	       adns_answer **answer_r,
+	       void **context_r);
+
+int adns_wait(adns_state ads,
+	      adns_query *query_io,
+	      adns_answer **answer_r,
+	      void **context_r);
+
+/* same as adns_wait but uses poll(2) internally */
+int adns_wait_poll(adns_state ads,
+		   adns_query *query_io,
+		   adns_answer **answer_r,
+		   void **context_r);
+
+void adns_cancel(adns_query query);
+
+/* The adns_query you get back from _submit is valid (ie, can be
+ * legitimately passed into adns functions) until it is returned by
+ * adns_check or adns_wait, or passed to adns_cancel.  After that it
+ * must not be used.  You can rely on it not being reused until the
+ * first adns_submit or _transact call using the same adns_state after
+ * it became invalid, so you may compare it for equality with other
+ * query handles until you next call _query or _transact.
+ *
+ * _submit and _synchronous return ENOSYS if they don't understand the
+ * query type.
+ */
+
+int adns_submit_reverse(adns_state ads,
+			const struct sockaddr *addr,
+			adns_rrtype type,
+			adns_queryflags flags,
+			void *context,
+			adns_query *query_r);
+/* type must be _r_ptr or _r_ptr_raw.  _qf_search is ignored.
+ * addr->sa_family must be AF_INET or you get ENOSYS.
+ */
+
+int adns_submit_reverse_any(adns_state ads,
+			    const struct sockaddr *addr,
+			    const char *rzone,
+			    adns_rrtype type,
+			    adns_queryflags flags,
+			    void *context,
+			    adns_query *query_r);
+/* For RBL-style reverse `zone's; look up
+ *   <reversed-address>.<zone>
+ * Any type is allowed.  _qf_search is ignored.
+ * addr->sa_family must be AF_INET or you get ENOSYS.
+ */
+
+void adns_finish(adns_state ads);
+/* You may call this even if you have queries outstanding;
+ * they will be cancelled.
+ */
+
+
+void adns_forallqueries_begin(adns_state ads);
+adns_query adns_forallqueries_next(adns_state ads, void **context_r);
+/* Iterator functions, which you can use to loop over the outstanding
+ * (submitted but not yet successfuly checked/waited) queries.
+ *
+ * You can only have one iteration going at once.  You may call _begin
+ * at any time; after that, an iteration will be in progress.  You may
+ * only call _next when an iteration is in progress - anything else
+ * may coredump.  The iteration remains in progress until _next
+ * returns 0, indicating that all the queries have been walked over,
+ * or ANY other adns function is called with the same adns_state (or a
+ * query in the same adns_state).  There is no need to explicitly
+ * finish an iteration.
+ *
+ * context_r may be 0.  *context_r may not be set when _next returns 0.
+ */
+
+void adns_checkconsistency(adns_state ads, adns_query qu);
+/* Checks the consistency of adns's internal data structures.
+ * If any error is found, the program will abort().
+ * You may pass 0 for qu; if you pass non-null then additional checks
+ * are done to make sure that qu is a valid query.
+ */
+
+/*
+ * Example expected/legal calling sequence for submit/check/wait:
+ *  adns_init
+ *  adns_submit 1
+ *  adns_submit 2
+ *  adns_submit 3
+ *  adns_wait 1
+ *  adns_check 3 -> EAGAIN
+ *  adns_wait 2
+ *  adns_wait 3
+ *  ....
+ *  adns_finish
+ */
+
+/*
+ * Entrypoints for generic asynch io:
+ * (these entrypoints are not very useful except in combination with *
+ * some of the other I/O model calls which can tell you which fds to
+ * be interested in):
+ *
+ * Note that any adns call may cause adns to open and close fds, so
+ * you must call beforeselect or beforepoll again just before
+ * blocking, or you may not have an up-to-date list of it's fds.
+ */
+
+int adns_processany(adns_state ads);
+/* Gives adns flow-of-control for a bit.  This will never block, and
+ * can be used with any threading/asynch-io model.  If some error
+ * occurred which might cause an event loop to spin then the errno
+ * value is returned.
+ */
+
+int adns_processreadable(adns_state ads, int fd, const struct timeval *now);
+int adns_processwriteable(adns_state ads, int fd, const struct timeval *now);
+int adns_processexceptional(adns_state ads, int fd, const struct timeval *now);
+/* Gives adns flow-of-control so that it can process incoming data
+ * from, or send outgoing data via, fd.  Very like _processany.  If it
+ * returns zero then fd will no longer be readable or writeable
+ * (unless of course more data has arrived since).  adns will _only_
+ * use that fd and only in the manner specified, regardless of whether
+ * adns_if_noautosys was specified.
+ *
+ * adns_processexceptional should be called when select(2) reports an
+ * exceptional condition, or poll(2) reports POLLPRI.
+ *
+ * It is fine to call _processreabable or _processwriteable when the
+ * fd is not ready, or with an fd that doesn't belong to adns; it will
+ * then just return 0.
+ *
+ * If some error occurred which might prevent an event loop to spin
+ * then the errno value is returned.
+ */
+
+void adns_processtimeouts(adns_state ads, const struct timeval *now);
+/* Gives adns flow-of-control so that it can process any timeouts
+ * which might have happened.  Very like _processreadable/writeable.
+ *
+ * now may be 0; if it isn't, *now must be the current time, recently
+ * obtained from gettimeofday.
+ */
+
+void adns_firsttimeout(adns_state ads,
+		       struct timeval **tv_mod, struct timeval *tv_buf,
+		       struct timeval now);
+/* Asks adns when it would first like the opportunity to time
+ * something out.  now must be the current time, from gettimeofday.
+ * 
+ * If tv_mod points to 0 then tv_buf must be non-null, and
+ * _firsttimeout will fill in *tv_buf with the time until the first
+ * timeout, and make *tv_mod point to tv_buf.  If adns doesn't have
+ * anything that might need timing out it will leave *tv_mod as 0.
+ *
+ * If *tv_mod is not 0 then tv_buf is not used.  adns will update
+ * *tv_mod if it has any earlier timeout, and leave it alone if it
+ * doesn't.
+ *
+ * This call will not actually do any I/O, or change the fds that adns
+ * is using.  It always succeeds and never blocks.
+ */
+
+void adns_globalsystemfailure(adns_state ads);
+/* If serious problem(s) happen which globally affect your ability to
+ * interact properly with adns, or adns's ability to function
+ * properly, you or adns can call this function.
+ *
+ * All currently outstanding queries will be made to fail with
+ * adns_s_systemfail, and adns will close any stream sockets it has
+ * open.
+ *
+ * This is used by adns, for example, if gettimeofday() fails.
+ * Without this the program's event loop might start to spin !
+ *
+ * This call will never block.
+ */
+
+/*
+ * Entrypoints for select-loop based asynch io:
+ */
+
+void adns_beforeselect(adns_state ads, int *maxfd, fd_set *readfds,
+		       fd_set *writefds, fd_set *exceptfds,
+		       struct timeval **tv_mod, struct timeval *tv_buf,
+		       const struct timeval *now);
+/* Find out file descriptors adns is interested in, and when it would
+ * like the opportunity to time something out.  If you do not plan to
+ * block then tv_mod may be 0.  Otherwise, tv_mod and tv_buf are as
+ * for adns_firsttimeout.  readfds, writefds, exceptfds and maxfd_io may
+ * not be 0.
+ *
+ * If now is not 0 then this will never actually do any I/O, or change
+ * the fds that adns is using or the timeouts it wants.  In any case
+ * it won't block, and it will set the timeout to zero if a query
+ * finishes in _beforeselect.
+ */
+
+void adns_afterselect(adns_state ads, int maxfd, const fd_set *readfds,
+		      const fd_set *writefds, const fd_set *exceptfds,
+		      const struct timeval *now);
+/* Gives adns flow-of-control for a bit; intended for use after
+ * select.  This is just a fancy way of calling adns_processreadable/
+ * writeable/timeouts as appropriate, as if select had returned the
+ * data being passed.  Always succeeds.
+ */
+
+/*
+ * Example calling sequence:
+ *
+ *  adns_init _noautosys
+ *  loop {
+ *   adns_beforeselect
+ *   select
+ *   adns_afterselect
+ *   ...
+ *   adns_submit / adns_check
+ *   ...
+ *  }
+ */
+
+/*
+ * Entrypoints for poll-loop based asynch io:
+ */
+
+struct pollfd;
+/* In case your system doesn't have it or you forgot to include
+ * <sys/poll.h>, to stop the following declarations from causing
+ * problems.  If your system doesn't have poll then the following
+ * entrypoints will not be defined in libadns.  Sorry !
+ */
+
+int adns_beforepoll(adns_state ads, struct pollfd *fds, int *nfds_io, int *timeout_io,
+		    const struct timeval *now);
+/* Finds out which fd's adns is interested in, and when it would like
+ * to be able to time things out.  This is in a form suitable for use
+ * with poll(2).
+ * 
+ * On entry, usually fds should point to at least *nfds_io structs.
+ * adns will fill up to that many structs will information for poll,
+ * and record in *nfds_io how many structs it filled.  If it wants to
+ * listen for more structs then *nfds_io will be set to the number
+ * required and _beforepoll will return ERANGE.
+ *
+ * You may call _beforepoll with fds==0 and *nfds_io 0, in which case
+ * adns will fill in the number of fds that it might be interested in
+ * in *nfds_io, and always return either 0 (if it is not interested in
+ * any fds) or ERANGE (if it is).
+ *
+ * NOTE that (unless now is 0) adns may acquire additional fds
+ * from one call to the next, so you must put adns_beforepoll in a
+ * loop, rather than assuming that the second call (with the buffer
+ * size requested by the first) will not return ERANGE.
+ *
+ * adns only ever sets POLLIN, POLLOUT and POLLPRI in its pollfd
+ * structs, and only ever looks at those bits.  POLLPRI is required to
+ * detect TCP Urgent Data (which should not be used by a DNS server)
+ * so that adns can know that the TCP stream is now useless.
+ *
+ * In any case, *timeout_io should be a timeout value as for poll(2),
+ * which adns will modify downwards as required.  If the caller does
+ * not plan to block then *timeout_io should be 0 on entry, or
+ * alternatively, timeout_io may be 0.  (Alternatively, the caller may
+ * use _beforeselect with timeout_io==0 to find out about file
+ * descriptors, and use _firsttimeout is used to find out when adns
+ * might want to time something out.)
+ *
+ * adns_beforepoll will return 0 on success, and will not fail for any
+ * reason other than the fds buffer being too small (ERANGE).
+ *
+ * This call will never actually do any I/O.  If you supply the
+ * current time it will not change the fds that adns is using or the
+ * timeouts it wants.
+ *
+ * In any case this call won't block.
+ */
+
+#define ADNS_POLLFDS_RECOMMENDED 2
+/* If you allocate an fds buf with at least RECOMMENDED entries then
+ * you are unlikely to need to enlarge it.  You are recommended to do
+ * so if it's convenient.  However, you must be prepared for adns to
+ * require more space than this.
+ */
+
+void adns_afterpoll(adns_state ads, const struct pollfd *fds, int nfds,
+		    const struct timeval *now);
+/* Gives adns flow-of-control for a bit; intended for use after
+ * poll(2).  fds and nfds should be the results from poll().  pollfd
+ * structs mentioning fds not belonging to adns will be ignored.
+ */
+
+
+adns_status adns_rr_info(adns_rrtype type,
+			 const char **rrtname_r, const char **fmtname_r,
+			 int *len_r,
+			 const void *datap, char **data_r);
+/*
+ * Get information about a query type, or convert reply data to a
+ * textual form.  type must be specified, and the official name of the
+ * corresponding RR type will be returned in *rrtname_r, and
+ * information about the processing style in *fmtname_r.  The length
+ * of the table entry in an answer for that type will be returned in
+ * in *len_r.  Any or all of rrtname_r, fmtname_r and len_r may be 0.
+ * If fmtname_r is non-null then *fmtname_r may be null on return,
+ * indicating that no special processing is involved.
+ *
+ * data_r be must be non-null iff datap is.  In this case *data_r will
+ * be set to point to a string pointing to a representation of the RR
+ * data in master file format.  (The owner name, timeout, class and
+ * type will not be present - only the data part of the RR.)  The
+ * memory will have been obtained from malloc() and must be freed by
+ * the caller.
+ *
+ * Usually this routine will succeed.  Possible errors include:
+ *  adns_s_nomemory
+ *  adns_s_rrtypeunknown
+ *  adns_s_invaliddata (*datap contained garbage)
+ * If an error occurs then no memory has been allocated,
+ * and *rrtname_r, *fmtname_r, *len_r and *data_r are undefined.
+ *
+ * There are some adns-invented data formats which are not official
+ * master file formats.  These include:
+ *
+ * Mailboxes if __qtf_mail822: these are just included as-is.
+ *
+ * Addresses (adns_rr_addr): these may be of pretty much any type.
+ * The representation is in two parts: first, a word for the address
+ * family (ie, in AF_XXX, the XXX), and then one or more items for the
+ * address itself, depending on the format.  For an IPv4 address the
+ * syntax is INET followed by the dotted quad (from inet_ntoa).
+ * Currently only IPv4 is supported.
+ *
+ * Text strings (as in adns_rr_txt) appear inside double quotes, and
+ * use \" and \\ to represent " and \, and \xHH to represent
+ * characters not in the range 32-126.
+ *
+ * Hostname with addresses (adns_rr_hostaddr): this consists of the
+ * hostname, as usual, followed by the adns_status value, as an
+ * abbreviation, and then a descriptive string (encoded as if it were
+ * a piece of text), for the address lookup, followed by zero or more
+ * addresses enclosed in ( and ).  If the result was a temporary
+ * failure, then a single ?  appears instead of the ( ).  If the
+ * result was a permanent failure then an empty pair of parentheses
+ * appears (which a space in between).  For example, one of the NS
+ * records for greenend.org.uk comes out like
+ *  ns.chiark.greenend.org.uk ok "OK" ( INET 195.224.76.132 )
+ * an MX referring to a nonexistent host might come out like:
+ *  50 sun2.nsfnet-relay.ac.uk nxdomain "No such domain" ( )
+ * and if nameserver information is not available you might get:
+ *  dns2.spong.dyn.ml.org timeout "DNS query timed out" ?
+ */
+
+const char *adns_strerror(adns_status st);
+const char *adns_errabbrev(adns_status st);
+const char *adns_errtypeabbrev(adns_status st);
+/* Like strerror but for adns_status values.  adns_errabbrev returns
+ * the abbreviation of the error - eg, for adns_s_timeout it returns
+ * "timeout".  adns_errtypeabbrev returns the abbreviation of the
+ * error class: ie, for values up to adns_s_max_XXX it will return the
+ * string XXX.  You MUST NOT call these functions with status values
+ * not returned by the same adns library.
+ */
+int adns__rereadconfig(adns_state);
+#endif
Index: adns/reply.c
===================================================================
--- adns/reply.c	(revision 0)
+++ adns/reply.c	(revision 0)
@@ -0,0 +1,374 @@
+/*
+ * reply.c: $Id: reply.c,v 1.5 2001/12/04 16:12:11 androsyn Exp $
+ *  
+ */
+/*
+ * reply.c
+ * - main handling and parsing routine for received datagrams
+ */
+/*
+ *  This file is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *
+ *  It is part of adns, which is
+ *    Copyright (C) 1997-2000 Ian Jackson <ian@davenant.greenend.org.uk>
+ *    Copyright (C) 1999-2000 Tony Finch <dot@dotat.at>
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software Foundation,
+ *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+ */
+
+#include <stdlib.h>
+
+#include "internal.h"
+    
+void adns__procdgram(adns_state ads, const byte *dgram, int dglen,
+		     int serv, int viatcp, struct timeval now) {
+  int cbyte, rrstart, wantedrrs, rri, foundsoa, foundns, cname_here;
+  int id, f1, f2, qdcount, ancount, nscount, arcount;
+  int flg_ra, flg_rd, flg_tc, flg_qr, opcode;
+  int rrtype, rrclass, rdlength, rdstart;
+  int anstart, nsstart, arstart;
+  int ownermatched, l, nrrs;
+  unsigned long ttl, soattl;
+  const typeinfo *typei;
+  adns_query qu, nqu;
+  dns_rcode rcode;
+  adns_status st;
+  vbuf tempvb;
+  byte *newquery, *rrsdata;
+  parseinfo pai;
+  
+  if (dglen<DNS_HDRSIZE) {
+    adns__diag(ads,serv,0,"received datagram too short for message header (%d)",dglen);
+    return;
+  }
+  cbyte= 0;
+  GET_W(cbyte,id);
+  GET_B(cbyte,f1);
+  GET_B(cbyte,f2);
+  GET_W(cbyte,qdcount);
+  GET_W(cbyte,ancount);
+  GET_W(cbyte,nscount);
+  GET_W(cbyte,arcount);
+  assert(cbyte == DNS_HDRSIZE);
+
+  flg_qr= f1&0x80;
+  opcode= (f1&0x78)>>3;
+  flg_tc= f1&0x02;
+  flg_rd= f1&0x01;
+  flg_ra= f2&0x80;
+  rcode= (f2&0x0f);
+
+  cname_here= 0;
+  
+  if (!flg_qr) {
+    adns__diag(ads,serv,0,"server sent us a query, not a response");
+    return;
+  }
+  if (opcode) {
+    adns__diag(ads,serv,0,"server sent us unknown opcode %d (wanted 0=QUERY)",opcode);
+    return;
+  }
+
+  qu= 0;
+  /* See if we can find the relevant query, or leave qu=0 otherwise ... */   
+
+  if (qdcount == 1) {
+    for (qu= viatcp ? ads->tcpw.head : ads->udpw.head; qu; qu= nqu) {
+      nqu= qu->next;
+      if (qu->id != id) continue;
+      if (dglen < qu->query_dglen) continue;
+      if (memcmp(qu->query_dgram+DNS_HDRSIZE,
+		 dgram+DNS_HDRSIZE,
+		 qu->query_dglen-DNS_HDRSIZE))
+	continue;
+      if (viatcp) {
+	assert(qu->state == query_tcpw);
+      } else {
+	assert(qu->state == query_tosend);
+	if (!(qu->udpsent & (1<<serv))) continue;
+      }
+      break;
+    }
+    if (qu) {
+      /* We're definitely going to do something with this query now */
+      if (viatcp) DLIST_UNLINK(ads->tcpw,qu);
+      else DLIST_UNLINK(ads->udpw,qu);
+    }
+  }
+  
+  /* If we're going to ignore the packet, we return as soon as we have
+   * failed the query (if any) and printed the warning message (if
+   * any).
+   */
+  switch (rcode) {
+  case rcode_noerror:
+  case rcode_nxdomain:
+    break;
+  case rcode_formaterror:
+    adns__warn(ads,serv,qu,"server cannot understand our query (Format Error)");
+    if (qu) adns__query_fail(qu,adns_s_rcodeformaterror);
+    return;
+  case rcode_servfail:
+    if (qu) adns__query_fail(qu,adns_s_rcodeservfail);
+    else adns__debug(ads,serv,qu,"server failure on unidentifiable query");
+    return;
+  case rcode_notimp:
+    adns__warn(ads,serv,qu,"server claims not to implement our query");
+    if (qu) adns__query_fail(qu,adns_s_rcodenotimplemented);
+    return;
+  case rcode_refused:
+    adns__debug(ads,serv,qu,"server refused our query");
+    if (qu) adns__query_fail(qu,adns_s_rcoderefused);
+    return;
+  default:
+    adns__warn(ads,serv,qu,"server gave unknown response code %d",rcode);
+    if (qu) adns__query_fail(qu,adns_s_rcodeunknown);
+    return;
+  }
+
+  if (!qu) {
+    if (!qdcount) {
+      adns__diag(ads,serv,0,"server sent reply without quoting our question");
+    } else if (qdcount>1) {
+      adns__diag(ads,serv,0,"server claimed to answer %d questions with one message",
+		 qdcount);
+    } else if (ads->iflags & adns_if_debug) {
+      adns__vbuf_init(&tempvb);
+      adns__debug(ads,serv,0,"reply not found, id %02x, query owner %s",
+		  id, adns__diag_domain(ads,serv,0,&tempvb,dgram,dglen,DNS_HDRSIZE));
+      adns__vbuf_free(&tempvb);
+    }
+    return;
+  }
+
+  /* We're definitely going to do something with this packet and this query now. */
+  
+  anstart= qu->query_dglen;
+  arstart= -1;
+
+  /* Now, take a look at the answer section, and see if it is complete.
+   * If it has any CNAMEs we stuff them in the answer.
+   */
+  wantedrrs= 0;
+  cbyte= anstart;
+  for (rri= 0; rri<ancount; rri++) {
+    rrstart= cbyte;
+    st= adns__findrr(qu,serv, dgram,dglen,&cbyte,
+		     &rrtype,&rrclass,&ttl, &rdlength,&rdstart,
+		     &ownermatched);
+    if (st) { adns__query_fail(qu,st); return; }
+    if (rrtype == -1) goto x_truncated;
+
+    if (rrclass != DNS_CLASS_IN) {
+      adns__diag(ads,serv,qu,"ignoring answer RR with wrong class %d (expected IN=%d)",
+		 rrclass,DNS_CLASS_IN);
+      continue;
+    }
+    if (!ownermatched) {
+      if (ads->iflags & adns_if_debug) {
+	adns__debug(ads,serv,qu,"ignoring RR with an unexpected owner %s",
+		    adns__diag_domain(ads,serv,qu, &qu->vb, dgram,dglen,rrstart));
+      }
+      continue;
+    }
+    if (rrtype == adns_r_cname &&
+	(qu->typei->type & adns__rrt_typemask) != adns_r_cname) {
+      if (qu->flags & adns_qf_cname_forbid) {
+	adns__query_fail(qu,adns_s_prohibitedcname);
+	return;
+      } else if (qu->cname_dgram && ++qu->cname_count >= 2 ) { 
+	adns__debug(ads,serv,qu,"allegedly canonical name %s is actually alias for %s",
+		    qu->answer->cname,
+		    adns__diag_domain(ads,serv,qu, &qu->vb, dgram,dglen,rdstart));
+	adns__query_fail(qu,adns_s_prohibitedcname);
+	return;
+      } else if (wantedrrs) { /* Ignore CNAME(s) after RR(s). */
+	adns__debug(ads,serv,qu,"ignoring CNAME (to %s) coexisting with RR",
+		    adns__diag_domain(ads,serv,qu, &qu->vb, dgram,dglen,rdstart));
+      } else {
+	qu->cname_begin= rdstart;
+	qu->cname_dglen= dglen;
+	st= adns__parse_domain(ads,serv,qu, &qu->vb,
+			       qu->flags & adns_qf_quotefail_cname ? 0 : pdf_quoteok,
+			       dgram,dglen, &rdstart,rdstart+rdlength);
+	if (!qu->vb.used) goto x_truncated;
+	if (st) { adns__query_fail(qu,st); return; }
+	l= strlen(qu->vb.buf)+1;
+	qu->answer->cname= adns__alloc_preserved(qu,l);
+	if (!qu->answer->cname) { adns__query_fail(qu,adns_s_nomemory); return; }
+
+	qu->cname_dgram= adns__alloc_mine(qu,dglen);
+	memcpy(qu->cname_dgram,dgram,dglen);
+
+	memcpy(qu->answer->cname,qu->vb.buf,l);
+	cname_here= 1;
+	adns__update_expires(qu,ttl,now);
+	/* If we find the answer section truncated after this point we restart
+	 * the query at the CNAME; if beforehand then we obviously have to use
+	 * TCP.  If there is no truncation we can use the whole answer if
+	 * it contains the relevant info.
+	 */
+      }
+    } else if (rrtype == (qu->typei->type & adns__rrt_typemask)) {
+      wantedrrs++;
+    } else {
+      adns__debug(ads,serv,qu,"ignoring answer RR with irrelevant type %d",rrtype);
+    }
+  }
+
+  /* We defer handling truncated responses here, in case there was a CNAME
+   * which we could use.
+   */
+  if (flg_tc) goto x_truncated;
+  
+  nsstart= cbyte;
+
+  if (!wantedrrs) {
+    /* Oops, NODATA or NXDOMAIN or perhaps a referral (which would be a problem) */
+
+    /* RFC2308: NODATA has _either_ a SOA _or_ _no_ NS records in authority section */
+    foundsoa= 0; soattl= 0; foundns= 0;
+    for (rri= 0; rri<nscount; rri++) {
+      rrstart= cbyte;
+      st= adns__findrr(qu,serv, dgram,dglen,&cbyte,
+		       &rrtype,&rrclass,&ttl, &rdlength,&rdstart, 0);
+      if (st) { adns__query_fail(qu,st); return; }
+      if (rrtype==-1) goto x_truncated;
+      if (rrclass != DNS_CLASS_IN) {
+	adns__diag(ads,serv,qu,
+		   "ignoring authority RR with wrong class %d (expected IN=%d)",
+		   rrclass,DNS_CLASS_IN);
+	continue;
+      }
+      if (rrtype == adns_r_soa_raw) { foundsoa= 1; soattl= ttl; break; }
+      else if (rrtype == adns_r_ns_raw) { foundns= 1; }
+    }
+    
+    if (rcode == rcode_nxdomain) {
+      /* We still wanted to look for the SOA so we could find the TTL. */
+      adns__update_expires(qu,soattl,now);
+
+      if (qu->flags & adns_qf_search) {
+	adns__search_next(ads,qu,now);
+      } else {
+	adns__query_fail(qu,adns_s_nxdomain);
+      }
+      return;
+    }
+
+    if (foundsoa || !foundns) {
+      /* Aha !  A NODATA response, good. */
+      adns__update_expires(qu,soattl,now);
+      adns__query_fail(qu,adns_s_nodata);
+      return;
+    }
+
+    /* Now what ?  No relevant answers, no SOA, and at least some NS's.
+     * Looks like a referral.  Just one last chance ... if we came across
+     * a CNAME in this datagram then we should probably do our own CNAME
+     * lookup now in the hope that we won't get a referral again.
+     */
+    if (cname_here) goto x_restartquery;
+
+    /* Bloody hell, I thought we asked for recursion ? */
+    if (!flg_ra) {
+      adns__diag(ads,serv,qu,"server is not willing to do recursive lookups for us");
+      adns__query_fail(qu,adns_s_norecurse);
+    } else {
+      if (!flg_rd)
+	adns__diag(ads,serv,qu,"server thinks we didn't ask for recursive lookup");
+      else
+	adns__debug(ads,serv,qu,"server claims to do recursion, but gave us a referral");
+      adns__query_fail(qu,adns_s_invalidresponse);
+    }
+    return;
+  }
+
+  /* Now, we have some RRs which we wanted. */
+
+  qu->answer->rrs.untyped= adns__alloc_interim(qu,qu->typei->rrsz*wantedrrs);
+  if (!qu->answer->rrs.untyped) { adns__query_fail(qu,adns_s_nomemory); return; }
+
+  typei= qu->typei;
+  cbyte= anstart;
+  rrsdata= qu->answer->rrs.bytes;
+
+  pai.ads= qu->ads;
+  pai.qu= qu;
+  pai.serv= serv;
+  pai.dgram= dgram;
+  pai.dglen= dglen;
+  pai.nsstart= nsstart;
+  pai.nscount= nscount;
+  pai.arcount= arcount;
+  pai.now= now;
+
+  for (rri=0, nrrs=0; rri<ancount; rri++) {
+    st= adns__findrr(qu,serv, dgram,dglen,&cbyte,
+		     &rrtype,&rrclass,&ttl, &rdlength,&rdstart,
+		     &ownermatched);
+    assert(!st); assert(rrtype != -1);
+    if (rrclass != DNS_CLASS_IN ||
+	rrtype != (qu->typei->type & adns__rrt_typemask) ||
+	!ownermatched)
+      continue;
+    adns__update_expires(qu,ttl,now);
+    st= typei->parse(&pai, rdstart,rdstart+rdlength, rrsdata+nrrs*typei->rrsz);
+    if (st) { adns__query_fail(qu,st); return; }
+    if (rdstart==-1) goto x_truncated;
+    nrrs++;
+  }
+  assert(nrrs==wantedrrs);
+  qu->answer->nrrs= nrrs;
+
+  /* This may have generated some child queries ... */
+  if (qu->children.head) {
+    qu->state= query_childw;
+    DLIST_LINK_TAIL(ads->childw,qu);
+    return;
+  }
+  adns__query_done(qu);
+  return;
+
+ x_truncated:
+  
+  if (!flg_tc) {
+    adns__diag(ads,serv,qu,"server sent datagram which points outside itself");
+    adns__query_fail(qu,adns_s_invalidresponse);
+    return;
+  }
+  qu->flags |= adns_qf_usevc;
+  
+ x_restartquery:
+  if (qu->cname_dgram) {
+    st= adns__mkquery_frdgram(qu->ads,&qu->vb,&qu->id,
+			      qu->cname_dgram, qu->cname_dglen, qu->cname_begin,
+			      qu->typei->type, qu->flags);
+    if (st) { adns__query_fail(qu,st); return; }
+    
+    newquery= MyRealloc(qu->query_dgram,qu->vb.used);
+    if (!newquery) { adns__query_fail(qu,adns_s_nomemory); return; }
+    
+    qu->query_dgram= newquery;
+    qu->query_dglen= qu->vb.used;
+    memcpy(newquery,qu->vb.buf,qu->vb.used);
+  }
+  
+  if (qu->state == query_tcpw) qu->state= query_tosend;
+  qu->retries= 0;
+  adns__reset_preserved(qu);
+  adns__query_send(qu,now);
+}
Index: adns/README.ircd
===================================================================
--- adns/README.ircd	(revision 0)
+++ adns/README.ircd	(revision 0)
@@ -0,0 +1,10 @@
+
+The files in adns/ were borrowed from the ADNS library and modified quite
+heavily.  The original code's copyright notices are in adns/README and
+adns/COPYING.  
+
+The modified portions are Copyright 2001 Aaron Sethman <androsyn@ratbox.org>
+
+Further modifications were done for hyperion-ircd. These modifications are
+copyright (c) 2005 Peer Directed Projects Center.
+
Index: patches/Makefile.in
===================================================================
--- patches/Makefile.in	(revision 183)
+++ patches/Makefile.in	(working copy)
@@ -94,11 +94,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
Index: src/Makefile.in
===================================================================
--- src/Makefile.in	(revision 183)
+++ src/Makefile.in	(working copy)
@@ -55,33 +55,33 @@
 am__installdirs = "$(DESTDIR)$(sbindir)"
 sbinPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
 PROGRAMS = $(sbin_PROGRAMS)
-am_hyperion_ircd_OBJECTS = ircd.$(OBJEXT) blalloc.$(OBJEXT) \
-	channel.$(OBJEXT) class.$(OBJEXT) client.$(OBJEXT) \
-	dbuf.$(OBJEXT) dline_conf.$(OBJEXT) m_dump.$(OBJEXT) \
-	fdlist.$(OBJEXT) feature.$(OBJEXT) fileio.$(OBJEXT) \
-	flud.$(OBJEXT) hash.$(OBJEXT) irc_string.$(OBJEXT) \
-	ircd_signal.$(OBJEXT) list.$(OBJEXT) listener.$(OBJEXT) \
-	m_admin.$(OBJEXT) m_away.$(OBJEXT) m_burst.$(OBJEXT) \
-	m_capab.$(OBJEXT) m_chall.$(OBJEXT) m_close.$(OBJEXT) \
-	m_collide.$(OBJEXT) m_connect.$(OBJEXT) md5.$(OBJEXT) \
-	md5crypt.$(OBJEXT) m_die.$(OBJEXT) m_error.$(OBJEXT) \
-	m_htm.$(OBJEXT) m_info.$(OBJEXT) m_ison.$(OBJEXT) \
-	m_help.$(OBJEXT) m_kill.$(OBJEXT) m_kline.$(OBJEXT) \
-	m_links.$(OBJEXT) m_list.$(OBJEXT) m_ltrace.$(OBJEXT) \
-	m_lusers.$(OBJEXT) m_makepass.$(OBJEXT) m_map.$(OBJEXT) \
-	m_message.$(OBJEXT) m_mode.$(OBJEXT) m_operwall.$(OBJEXT) \
-	m_oper.$(OBJEXT) m_pass.$(OBJEXT) m_ping.$(OBJEXT) \
-	m_pong.$(OBJEXT) m_quit.$(OBJEXT) m_rehash.$(OBJEXT) \
-	m_resp.$(OBJEXT) m_restart.$(OBJEXT) m_scan.$(OBJEXT) \
-	m_services.$(OBJEXT) m_server.$(OBJEXT) m_set.$(OBJEXT) \
-	m_setname.$(OBJEXT) m_snick.$(OBJEXT) m_spingtime.$(OBJEXT) \
-	m_squit.$(OBJEXT) m_stats.$(OBJEXT) m_stopic.$(OBJEXT) \
-	m_svinfo.$(OBJEXT) m_time.$(OBJEXT) m_trace.$(OBJEXT) \
-	m_unkline.$(OBJEXT) m_userhost.$(OBJEXT) m_users.$(OBJEXT) \
-	m_version.$(OBJEXT) m_wallops.$(OBJEXT) m_who.$(OBJEXT) \
-	m_whois.$(OBJEXT) match.$(OBJEXT) motd.$(OBJEXT) \
-	mtrie_conf.$(OBJEXT) numeric.$(OBJEXT) packet.$(OBJEXT) \
-	paths.$(OBJEXT) parse.$(OBJEXT) res.$(OBJEXT) \
+am_hyperion_ircd_OBJECTS = ircd.$(OBJEXT) adns.$(OBJEXT) \
+	blalloc.$(OBJEXT) channel.$(OBJEXT) class.$(OBJEXT) \
+	client.$(OBJEXT) dbuf.$(OBJEXT) dline_conf.$(OBJEXT) \
+	m_dump.$(OBJEXT) fdlist.$(OBJEXT) feature.$(OBJEXT) \
+	fileio.$(OBJEXT) flud.$(OBJEXT) hash.$(OBJEXT) \
+	irc_string.$(OBJEXT) ircd_signal.$(OBJEXT) list.$(OBJEXT) \
+	listener.$(OBJEXT) m_admin.$(OBJEXT) m_away.$(OBJEXT) \
+	m_burst.$(OBJEXT) m_capab.$(OBJEXT) m_chall.$(OBJEXT) \
+	m_close.$(OBJEXT) m_collide.$(OBJEXT) m_connect.$(OBJEXT) \
+	md5.$(OBJEXT) md5crypt.$(OBJEXT) m_die.$(OBJEXT) \
+	m_error.$(OBJEXT) m_htm.$(OBJEXT) m_info.$(OBJEXT) \
+	m_ison.$(OBJEXT) m_help.$(OBJEXT) m_kill.$(OBJEXT) \
+	m_kline.$(OBJEXT) m_links.$(OBJEXT) m_list.$(OBJEXT) \
+	m_ltrace.$(OBJEXT) m_lusers.$(OBJEXT) m_makepass.$(OBJEXT) \
+	m_map.$(OBJEXT) m_message.$(OBJEXT) m_mode.$(OBJEXT) \
+	m_operwall.$(OBJEXT) m_oper.$(OBJEXT) m_pass.$(OBJEXT) \
+	m_ping.$(OBJEXT) m_pong.$(OBJEXT) m_quit.$(OBJEXT) \
+	m_rehash.$(OBJEXT) m_resp.$(OBJEXT) m_restart.$(OBJEXT) \
+	m_scan.$(OBJEXT) m_services.$(OBJEXT) m_server.$(OBJEXT) \
+	m_set.$(OBJEXT) m_setname.$(OBJEXT) m_snick.$(OBJEXT) \
+	m_spingtime.$(OBJEXT) m_squit.$(OBJEXT) m_stats.$(OBJEXT) \
+	m_stopic.$(OBJEXT) m_svinfo.$(OBJEXT) m_time.$(OBJEXT) \
+	m_trace.$(OBJEXT) m_unkline.$(OBJEXT) m_userhost.$(OBJEXT) \
+	m_users.$(OBJEXT) m_version.$(OBJEXT) m_wallops.$(OBJEXT) \
+	m_who.$(OBJEXT) m_whois.$(OBJEXT) match.$(OBJEXT) \
+	motd.$(OBJEXT) mtrie_conf.$(OBJEXT) numeric.$(OBJEXT) \
+	packet.$(OBJEXT) paths.$(OBJEXT) parse.$(OBJEXT) \
 	restart.$(OBJEXT) s_auth.$(OBJEXT) s_bsd.$(OBJEXT) \
 	s_cr.$(OBJEXT) s_conf.$(OBJEXT) s_debug.$(OBJEXT) \
 	s_log.$(OBJEXT) s_misc.$(OBJEXT) s_serv.$(OBJEXT) \
@@ -90,7 +90,7 @@
 	svn_version.$(OBJEXT) tsdelta.$(OBJEXT) whowas.$(OBJEXT) \
 	umodes.$(OBJEXT) varparse.$(OBJEXT) version.$(OBJEXT)
 hyperion_ircd_OBJECTS = $(am_hyperion_ircd_OBJECTS)
-hyperion_ircd_LDADD = $(LDADD)
+hyperion_ircd_DEPENDENCIES =
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)/include
 depcomp = $(SHELL) $(top_srcdir)/build-misc/depcomp
 am__depfiles_maybe = depfiles
@@ -146,11 +146,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
@@ -192,6 +194,7 @@
 pkgdocdir = $(datadir)/doc/$(PACKAGE)
 AM_CPPFLAGS = -DPREFIX="\"$(prefix)\""
 hyperion_ircd_SOURCES = ircd.c \
+	adns.c \
 	blalloc.c \
 	channel.c \
 	class.c \
@@ -270,7 +273,6 @@
 	packet.c \
 	paths.c \
 	parse.c \
-	res.c \
 	restart.c \
 	s_auth.c \
 	s_bsd.c \
@@ -293,6 +295,7 @@
 	varparse.c \
 	version.c
 
+hyperion_ircd_LDADD = -L../adns -ladns
 all: all-am
 
 .SUFFIXES:
@@ -359,6 +362,7 @@
 distclean-compile:
 	-rm -f *.tab.c
 
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/adns.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/blalloc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/channel.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/class.Po@am__quote@
@@ -438,7 +442,6 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/packet.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parse.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/paths.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/res.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/restart.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/s_auth.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/s_bsd.Po@am__quote@
Index: src/adns.c
===================================================================
--- src/adns.c	(revision 0)
+++ src/adns.c	(revision 0)
@@ -0,0 +1,220 @@
+/*
+ * $Id: adns.c,v 1.14 2003/06/24 03:57:16 ievil Exp $
+ * adns.c  functions to enter libadns, based on the hybrid-6.4.2 code.
+ *
+ * Written by Aaron Sethman <androsyn@ratbox.org>
+ * Modified for hyperion-ircd by William Pitcock <nenolod@nenolod.net>
+ */
+#include <stdlib.h>
+#include "fileio.h"
+#include "res.h"
+#include "send.h"
+#include "s_conf.h"
+#include "s_bsd.h"
+#include "s_log.h"
+#include "client.h"
+#include "ircd_defs.h"
+#include "numeric.h"
+#include "irc_string.h"
+#include <errno.h>
+#include "../adns/internal.h"
+#define ADNS_MAXFD 2
+
+adns_state dns_state;
+
+static struct timeval SystemTime;
+/* void delete_adns_queries(struct DNSQuery *q)
+ * Input: A pointer to the applicable DNSQuery structure.
+ * Output: None
+ * Side effects: Cancels a DNS query.
+ */
+void
+delete_adns_queries (struct DNSQuery *q)
+{
+  if (q != NULL && q->query != NULL)
+    adns_cancel (q->query);
+}
+
+
+/* void restart_resolver(void)
+ * Input: None
+ * Output: None
+ * Side effects: Tears down any old ADNS sockets..reloads the conf
+ */
+void
+restart_resolver (void)
+{
+  adns__rereadconfig (dns_state);
+}
+
+/* void init_resolver(void)
+ * Input: None
+ * Output: None
+ * Side effects: Reads the ADNS configuration and sets up the ADNS server
+ *               polling and query timeouts.
+ */
+void
+init_resolver (void)
+{
+  int r;
+
+  gettimeofday (&SystemTime, NULL);
+  r = adns_init (&dns_state, adns_if_noautosys, 0);
+  if (dns_state == NULL)
+    {
+      logprintf (L_CRIT, "Error opening /etc/resolv.conf: %s; r = %d",
+	    strerror (errno), r);
+      exit (76);
+    }
+}
+
+/* void timeout_adns(void *ptr);
+ * Input: None used.
+ * Output: None
+ * Side effects: Cancel any old(expired) DNS queries.
+ * Note: Called by the event code.
+ */
+void
+timeout_adns ()
+{
+  gettimeofday (&SystemTime, NULL);
+  adns_processtimeouts (dns_state, &SystemTime);
+}
+
+#if 0
+/* void dns_writeable(int fd, void *ptr)
+ * Input: An fd which has become writeable, ptr not used.
+ * Output: None.
+ * Side effects: Write any queued buffers out.
+ * Note: Called by the fd system.
+ */
+void
+dns_writeable (int fd, void *ptr)
+{
+  gettimeofday (&SystemTime, NULL);
+  adns_processwriteable (dns_state, fd, &SystemTime);
+  dns_select ();
+}
+#endif
+/* void dns_do_callbacks(int fd, void *ptr)
+ * Input: None.
+ * Output: None.
+ * Side effects: Call all the callbacks(into the ircd core) for the
+ *               results of a DNS resolution.
+ */
+void
+dns_do_callbacks (void)
+{
+  adns_query q, r;
+  adns_answer *answer;
+  struct DNSQuery *query;
+  adns_forallqueries_begin (dns_state);
+  while ((q = adns_forallqueries_next (dns_state, (void **) &r)) != NULL)
+    {
+      switch (adns_check (dns_state, &q, &answer, (void **) &query))
+	{
+	case 0:
+	  /* Looks like we got a winner */
+	  assert (query->callback != NULL);
+	  query->query = NULL;
+	  query->callback (query->ptr, answer);
+	  MyFree (query);
+	  break;
+	case EAGAIN:
+	  /* Go into the queue again */
+	  break;
+	default:
+	  assert (query->callback != NULL);
+	  /* Awww we failed, what a shame */
+	  query->query = NULL;
+	  query->callback (query->ptr, NULL);
+	  MyFree (query);
+	  break;
+	}
+    }
+}
+
+
+#ifndef USE_POLL
+static void
+do_adns_select (void)
+{
+  struct timeval tvbuf;
+  int maxfd = 2;
+  fd_set readfds, writefds, exceptfds;
+
+  tvbuf.tv_sec = 0;
+  tvbuf.tv_usec = 0;
+  FD_ZERO (&readfds);
+  FD_ZERO (&writefds);
+  FD_ZERO (&exceptfds);
+  adns_beforeselect (dns_state, &maxfd, &readfds, &writefds, &exceptfds, 0,
+		     &tvbuf, 0);
+  select (maxfd, &readfds, &writefds, &exceptfds, &tvbuf);
+  adns_afterselect (dns_state, maxfd, &readfds, &writefds, &exceptfds,
+		    &tvbuf);
+}
+#else
+static void
+do_adns_poll (void)
+{
+  struct pollfd pfd[MAXFD_POLL];
+  int nfds = MAXFD_POLL;
+  int timeout = 0;
+
+  adns_beforepoll (dns_state, pfd, &nfds, &timeout, &SystemTime);
+  poll (pfd, nfds, timeout);
+  adns_afterpoll (dns_state, pfd, nfds, &SystemTime);
+}
+
+#endif
+
+void
+do_adns_io (void)
+{
+  gettimeofday (&SystemTime, NULL);
+#ifdef USE_POLL
+  do_adns_poll ();
+#else
+  do_adns_select ();
+#endif
+  adns_processany (dns_state);
+  dns_do_callbacks ();
+  timeout_adns ();
+}
+
+/* int adns_gethost(const char *name, struct DNSQuery *req);
+ * Input: A name, an address family, a DNSQuery structure.
+ * Output: None
+ * Side effects: Sets up a query structure and sends off a DNS query to
+ *               the DNS server to resolve an "A"(address) entry by name.
+ */
+int
+adns_gethost (const char *name, struct DNSQuery *req)
+{
+  assert (dns_state->nservers > 0);
+  return (adns_submit (dns_state, name, adns_r_addr, adns_qf_owner, req,
+		       &req->query));
+
+}
+
+/* int adns_getaddr(struct irc_inaddr *addr, int aftype,
+                     struct DNSQuery *req);
+ * Input: An address, an address family, a DNSQuery structure.
+ * Output: None
+ * Side effects: Sets up a query entry and sends it to the DNS server to
+ *               resolve an IP address to a domain name.
+ */
+int
+adns_getaddr (struct in_addr *addr, struct DNSQuery *req)
+{
+  struct sockaddr_in ipn;
+  assert (dns_state->nservers > 0);
+  ipn.sin_family = AF_INET;
+  ipn.sin_port = 0;
+  ipn.sin_addr.s_addr = addr->s_addr;
+  return (adns_submit_reverse (dns_state, (struct sockaddr *) &ipn,
+			       adns_r_ptr,
+			       adns_qf_owner | adns_qf_cname_loose |
+			       adns_qf_quoteok_anshost, req, &req->query));
+}
Index: src/s_bsd.c
===================================================================
--- src/s_bsd.c	(revision 183)
+++ src/s_bsd.c	(working copy)
@@ -19,6 +19,7 @@
  *
  *  
  */
+#include "res.h"
 #include "s_bsd.h"
 #include "class.h"
 #include "client.h"
@@ -31,7 +32,6 @@
 #include "listener.h"
 #include "numeric.h"
 #include "packet.h"
-#include "res.h"
 #include "restart.h"
 #include "s_auth.h"
 #include "s_conf.h"
@@ -182,22 +182,17 @@
  * a non-null pointer, otherwise reply will be null.
  * if successful start the connection, otherwise notify opers
  */
-static void connect_dns_callback(void* vptr, struct DNSReply* reply)
+static void connect_dns_callback(void* vptr, adns_answer* reply)
 {
   struct ConfItem* aconf = (struct ConfItem*) vptr;
   aconf->dns_pending = 0;
-  if (reply) {
-#ifdef IPV6
-    char name[HOSTLEN];
-    inet_ntop(AF_INET, reply->hp->h_addr, name, HOSTLEN);
-	inetpton(AFINET, name, &aconf->ipnum);
-#else
-    memcpy(&aconf->ipnum, reply->hp->h_addr, sizeof(struct in_addr));
-#endif
-    connect_server(aconf, 0, reply);
+  if (reply && reply->status == adns_s_ok) {
+    aconf->ipnum.s_addr = reply->rrs.addr->addr.inet.sin_addr.s_addr;
+    MyFree(reply);
+    connect_server(aconf, 0, NULL);
   }
   else
-    sendto_ops_flag(UMODE_SERVNOTICE, "Connect to %s failed: host lookup", aconf->host);
+    sendto_ops_flag(UMODE_SERVCONNECT, "Connect to %s failed: host lookup", aconf->host);
 }
 
 /*
@@ -510,7 +505,7 @@
  * it's considered an auto connect.
  */
 int connect_server(struct ConfItem* aconf, 
-                   struct Client* by, struct DNSReply* reply)
+                   struct Client* by, struct DNSQuery* reply)
 {
   struct Client* cptr;
 
@@ -563,21 +558,17 @@
 #endif
       struct DNSQuery  query;
       
-      query.vptr     = aconf;
+      query.ptr     = aconf;
       query.callback = connect_dns_callback;
-      reply = gethost_byname(aconf->host, &query);
-
-      if (!reply) {
+      if (!adns_gethost(aconf->host, &query))
+      {
         aconf->dns_pending = 1;
         return 0;
       }
-      memcpy((char*)aconf->ipnum.S_ADDR, reply->hp->h_addr, sizeof(struct IN_ADDR));
     }
   }
   cptr = make_client(NULL);
-  if (reply) 
-    ++reply->ref_count;
-  cptr->dns_reply = reply;
+  cptr->dns_query = reply;
   
   /*
    * Copy these in so we have something for error detection.
@@ -721,9 +712,8 @@
   else
     ServerStats->is_ni++;
   
-  if (cptr->dns_reply) {
-    --cptr->dns_reply->ref_count;
-    cptr->dns_reply = 0;
+  if (cptr->dns_query) {
+    cptr->dns_query = 0;
   }
   if (-1 < cptr->fd) {
     flush_connections(cptr);
@@ -1062,7 +1052,7 @@
         {
           FD_SET(ResolverFileDescriptor, read_set);
         }
-      wait.tv_sec = IRCD_MIN(delay2, delay);
+      wait.tv_sec = IRCD_MIN(delay, delay2);
       wait.tv_usec = usec;
 
       nfds = select(MAXCONNECTIONS, read_set, write_set, 0, &wait);
@@ -1087,15 +1077,6 @@
     }
 
   /*
-   * Check the name resolver
-   */
-
-  if (-1 < ResolverFileDescriptor && 
-      FD_ISSET(ResolverFileDescriptor, read_set)) {
-    get_res();
-    --nfds;
-  }
-  /*
    * Check the auth fd's
    */
   for (auth = AuthPollList; auth; auth = auth_next) {
@@ -1259,13 +1240,6 @@
     auth = 0;
 
     /*
-     * set resolver descriptor
-     */
-    if (ResolverFileDescriptor >= 0) {
-      PFD_SETR(ResolverFileDescriptor);
-      res_pfd = pfd;
-    }
-    /*
      * set auth descriptors
      */
     for (auth = AuthPollList; auth; auth = auth->next) {
@@ -1326,7 +1300,7 @@
         PFD_SETW(i);
     }
 
-    wait.tv_sec = IRCD_MIN(delay2, delay);
+    wait.tv_sec = IRCD_MIN(delay, delay2);
     wait.tv_usec = usec;
     nfds = poll(poll_fdarray, nbr_pfds,
                 wait.tv_sec * 1000 + wait.tv_usec / 1000);
@@ -1345,14 +1319,8 @@
       restart("too many poll errors");
     sleep(10);
   }
+
   /*
-   * check resolver descriptor
-   */
-  if (res_pfd && (res_pfd->revents & (POLLREADFLAGS | POLLERRORS))) {
-    get_res();
-    --nfds;
-  }
-  /*
    * check auth descriptors
    */
   for (auth = AuthPollList; auth; auth = auth_next) {
Index: src/motd.c
===================================================================
--- src/motd.c	(revision 183)
+++ src/motd.c	(working copy)
@@ -24,9 +24,9 @@
  */
 #include "motd.h"
 #include "ircd.h"
+#include "res.h"
 #include "s_bsd.h"
 #include "fileio.h"
-#include "res.h"
 #include "s_conf.h"
 #include "class.h"
 #include "send.h"
Index: src/ircd.c
===================================================================
--- src/ircd.c	(revision 183)
+++ src/ircd.c	(working copy)
@@ -442,11 +442,8 @@
   */
   if (nextconnect && CurrentTime >= nextconnect)
     nextconnect = try_connections(CurrentTime);
+
   /*
-   * DNS checks, use smaller of resolver delay or next ping
-   */
-  delay = IRCD_MIN(timeout_resolver(CurrentTime), nextping);
-  /*
   ** take the smaller of the two 'timed' event times as
   ** the time of next event (stops us being late :) - avalon
   ** WARNING - nextconnect can return 0!
@@ -454,6 +451,7 @@
   if (nextconnect)
     delay = IRCD_MIN(nextping, nextconnect);
   delay -= CurrentTime;
+
   /*
   ** Adjust delay to something reasonable [ad hoc values]
   ** (one might think something more clever here... --msa)
@@ -864,7 +862,11 @@
 
   ServerRunning = 1;
   while (ServerRunning)
+  {
+    do_adns_io();
     delay = io_loop(delay);
+    do_adns_io();
+  }
   return 0;
 }
 
Index: src/res.c
===================================================================
--- src/res.c	(revision 183)
+++ src/res.c	(working copy)
@@ -1,1895 +0,0 @@
-/*
- * src/res.c (C)opyright 1992 Darren Reed. All rights reserved.
- * This file may not be distributed without the author's permission in any
- * shape or form. The author takes no responsibility for any damage or loss
- * of property which results from the use of this software.
- *
- * July 1999 - Rewrote a bunch of stuff here. Change hostent builder code,
- *     added callbacks and reference counting of returned hostents.
- *     --Bleep (Thomas Helvey <tomh@inxpress.net>)
- */
-
-#include "res.h"
-#include "client.h"
-#include "common.h"
-#include "irc_string.h"
-#include "ircd.h"
-#include "numeric.h"
-#include "restart.h"
-#include "s_bsd.h"
-#include "send.h"
-#include "struct.h"
-#include "s_debug.h"
-#include "umodes.h"
-#include "m_commands.h"
-#include "s_log.h"
-
-#include <assert.h>
-#include <string.h>
-#include <stdlib.h>
-#include <sys/time.h>
-#include <sys/socket.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <errno.h>
-
-#include <arpa/nameser.h>
-#include <resolv.h>
-#include <netdb.h>
-#include <arpa/inet.h>
-
-#ifdef DEBUGMODE
-#include <errno.h>
-#endif
-
-#include <limits.h>
-#if (CHAR_BIT != 8)
-#error this code needs to be able to address individual octets 
-#endif
-
-#undef  DEBUG  /* because there is a lot of debug code in here :-) */
-
-/*
- * Some systems do not define INADDR_NONE (255.255.255.255)
- * INADDR_NONE is actually a valid address, but it should never
- * be returned from any nameserver.
- * NOTE: The bit pattern for INADDR_NONE and INADDR_ANY (0.0.0.0) should be 
- * the same on all hosts so we shouldn't need to use htonl or ntohl to
- * compare or set the values.
- */ 
-#ifndef INADDR_NONE
-#define INADDR_NONE ((unsigned int) 0xffffffff)
-#endif
-
-#define MAXPACKET       1024  /* rfc sez 512 but we expand names so ... */
-#define RES_MAXALIASES  35    /* maximum aliases allowed */
-#define RES_MAXADDRS    35    /* maximum addresses allowed */
-
-/*
- * macros used to calulate offsets into fixed query buffer
- */
-#define ALIAS_BLEN (size_t) ((RES_MAXALIASES + 1) * sizeof(char*))
-#define ADDRS_BLEN (size_t) ((RES_MAXADDRS + 1) * sizeof(struct IN_ADDR*))
-
-#define ADDRS_OFFSET  (size_t) (ALIAS_BLEN + ADDRS_BLEN)
-#define ADDRS_DLEN    (size_t) (RES_MAXADDRS * sizeof(struct IN_ADDR))
-#define NAMES_OFFSET  (size_t) (ADDRS_OFFSET + ADDRS_DLEN)
-#define MAXGETHOSTLEN (size_t) (NAMES_OFFSET + MAXPACKET)
-
-#define AR_TTL          600   /* minimum TTL in seconds for dns cache entries */
-
-/*
- * the following values should be prime
- */
-#define ARES_CACSIZE    307
-#define MAXCACHED       281
-
-/*
- * RFC 1104/1105 wasn't very helpful about what these fields
- * should be named, so for now, we'll just name them this way.
- * we probably should look at what named calls them or something.
- */
-#define TYPE_SIZE       (size_t) 2
-#define CLASS_SIZE      (size_t) 2
-#define TTL_SIZE        (size_t) 4
-#define RDLENGTH_SIZE   (size_t) 2
-#define ANSWER_FIXED_SIZE (TYPE_SIZE + CLASS_SIZE + TTL_SIZE + RDLENGTH_SIZE)
-
-/*
- * Building the Hostent
- * The Hostent struct is arranged like this:
- *          +-------------------------------+
- * Hostent: | struct hostent h              |
- *          |-------------------------------|
- *          | char *buf                     |
- *          +-------------------------------+
- *
- * allocated:
- *
- *          +-------------------------------+
- * buf:     | h_aliases pointer array       | Max size: ALIAS_BLEN;
- *          | NULL                          | contains `char *'s
- *          |-------------------------------|
- *          | h_addr_list pointer array     | Max size: ADDRS_BLEN;
- *          | NULL                          | contains `struct in_addr *'s
- *          |-------------------------------|
- *          | h_addr_list addresses         | Max size: ADDRS_DLEN;
- *          |                               | contains `struct in_addr's
- *          |-------------------------------|
- *          | storage for hostname strings  | Max size: ALIAS_DLEN;
- *          +-------------------------------+ contains `char's
- *
- *  For requests the size of the h_aliases, and h_addr_list pointer
- *  array sizes are set to MAXALISES and MAXADDRS respectively, and
- *  buf is a fixed size with enough space to hold the largest expected
- *  reply from a nameserver, see RFC 1034 and RFC 1035.
- *  For cached entries the sizes are dependent on the actual number
- *  of aliases and addresses. If new aliases and addresses are found
- *  for cached entries, the buffer is grown and the new entries are added.
- *  The hostent struct is filled in with the addresses of the entries in
- *  the Hostent buf as follows:
- *  h_name      - contains a pointer to the start of the hostname string area,
- *                or NULL if none is set.  The h_name is followed by the
- *                aliases, in the storage for hostname strings area.
- *  h_aliases   - contains a pointer to the start of h_aliases pointer array.
- *                This array contains pointers to the storage for hostname
- *                strings area and is terminated with a NULL.  The first alias
- *                is stored directly after the h_name.
- *  h_addr_list - contains a pointer to the start of h_addr_list pointer array.
- *                This array contains pointers to in_addr structures in the
- *                h_addr_list addresses area and is terminated with a NULL.
- *
- *  Filling the buffer this way allows for proper alignment of the h_addr_list
- *  addresses.
- *
- *  This arrangement allows us to alias a Hostent struct pointer as a
- *  real struct hostent* without lying. It also allows us to change the
- *  values contained in the cached entries and requests without changing
- *  the actual hostent pointer, which is saved in a client struct and can't
- *  be changed without blowing things up or a lot more fiddling around.
- *  It also allows for defered allocation of the fixed size buffers until
- *  they are really needed.
- *  Nov. 17, 1997 --Bleep
- */
-
-typedef struct Hostent {
-  struct hostent h;      /* the hostent struct we are passing around */
-  char*          buf;    /* buffer for data pointed to from hostent */
-} aHostent;
-
-typedef struct reslist {
-  int             id;
-  int             sent;              /* number of requests sent */
-  time_t          ttl;
-  char            type;
-  char            retries;           /* retry counter */
-  char            sends;             /* number of sends (>1 means resent) */
-  char            resend;            /* send flag. 0 == dont resend */
-  time_t          sentat;
-  time_t          timeout;
-  struct IN_ADDR  addr;
-  char*           name;
-  struct reslist* next;
-  struct DNSQuery query;             /* query callback for this request */
-  aHostent        he;
-} ResRQ;
-
-typedef struct cache {
-  struct cache*   hname_next;
-  struct cache*   hnum_next;
-  struct cache*   list_next;
-  time_t          expireat;
-  time_t          ttl;
-  struct Hostent  he;
-  struct DNSReply reply;
-} aCache;
-
-typedef struct cachetable {
-  aCache* num_list;
-  aCache* name_list;
-} CacheTable;
-
-
-int    ResolverFileDescriptor = -1;   /* GLOBAL - used in s_bsd.c */
-
-static time_t nextDNSCheck    = 0;
-static time_t nextCacheExpire = 1;
-
-/*
- * Keep a spare file descriptor open. res_init calls fopen to read the
- * resolv.conf file. If ircd is hogging all the file descriptors below 256,
- * on systems with crippled FILE structures this will cause wierd bugs.
- * This is definitely needed for Solaris which uses an unsigned char to
- * hold the file descriptor.
- */ 
-static int         spare_fd = -1;
-
-static int         cachedCount = 0;
-static CacheTable  hashtable[ARES_CACSIZE];
-static aCache*     cacheTop = NULL;
-static ResRQ*      requestListHead;     /* head of resolver request list */
-static ResRQ*      requestListTail;     /* tail of resolver request list */
-
-
-static void     add_request(ResRQ* request);
-static void     rem_request(ResRQ* request);
-static ResRQ*   make_request(const struct DNSQuery* query);
-static void     rem_cache(aCache*);
-static void     do_query_name(const struct DNSQuery* query, 
-                              const char* name, 
-                              ResRQ* request,
-                              int type);
-static void     do_query_number(const struct DNSQuery* query,
-                                const struct IN_ADDR*, 
-                                ResRQ* request);
-static void     query_name(const char* name, 
-                           int query_class, 
-                           int query_type, 
-                           ResRQ* request);
-static int      send_res_msg(const char* buf, int len, int count);
-static void     resend_query(ResRQ* request);
-static int      proc_answer(ResRQ* request, HEADER* header, 
-                                    char*, char *);
-static aCache*  make_cache(ResRQ* request);
-static aCache*  find_cache_name(const char* name);
-static aCache*  find_cache_number(ResRQ* request, const char* addr);
-static ResRQ*   find_id(int);
-static int      hash_number(const unsigned char *);
-static void     update_list(ResRQ *, aCache *);
-static int      hash_name(const char* name);
-
-static  struct cacheinfo {
-  int  ca_adds;
-  int  ca_dels;
-  int  ca_expires;
-  int  ca_lookups;
-  int  ca_na_hits;
-  int  ca_nu_hits;
-  int  ca_updates;
-} cainfo;
-
-static  struct  resinfo {
-  int  re_errors;
-  int  re_nu_look;
-  int  re_na_look;
-  int  re_replies;
-  int  re_requests;
-  int  re_resends;
-  int  re_sent;
-  int  re_timeouts;
-  int  re_shortttl;
-  int  re_unkrep;
-} reinfo;
-
-
-/* From bind 8.3, these aren't in earlier versions of bind */
-/* FreeBSD 5.x/6.x declare these in the .h file, suppress warnings.
- * This is an ugly method but my autoconf-fu is insufficient -- jilles */
-#if !defined(__FreeBSD__) || __FreeBSD_version < 500000
-extern u_short  _getshort(const u_char *);
-extern u_int    _getlong(const u_char *);
-#endif
-/*
- * int
- * res_isourserver(ina)
- *      looks up "ina" in _res.ns_addr_list[]
- * returns:
- *      0  : not found
- *      >0 : found
- * author:
- *      paul vixie, 29may94
- */
-static int
-res_ourserver(const struct __res_state* statp, const struct sockaddr_in *inp) 
-{
-  struct sockaddr_in ina;
-  int ns;
-
-  ina = *inp;
-  for (ns = 0;  ns < statp->nscount;  ns++) {
-    const struct sockaddr_in *srv = &statp->nsaddr_list[ns];
-
-    if (srv->sin_family == ina.sin_family &&
-         srv->sin_port == ina.sin_port &&
-         (srv->sin_addr.s_addr == INADDR_ANY ||
-          srv->sin_addr.s_addr == ina.sin_addr.s_addr))
-             return (1);
-  }
-  return (0);
-}
-
-/*
- * start_resolver - do everything we need to read the resolv.conf file
- * and initialize the resolver file descriptor if needed
- */
-static void start_resolver(void)
-{
-  char sparemsg[80];
-
-  /*
-   * close the spare file descriptor so res_init can read resolv.conf
-   * successfully. Needed on Solaris
-   */
-  if (spare_fd > -1)
-    close(spare_fd);
-
-  res_init();      /* res_init always returns 0 */
-  /*
-   * make sure we have a valid file descriptor below 256 so we can
-   * do this again. Needed on Solaris
-   */
-  spare_fd = open("/dev/null",O_RDONLY,0);
-  if ((spare_fd < 0) || (spare_fd > 255)) {
-    ircsnprintf(sparemsg, 80, "invalid spare_fd %d", spare_fd);
-    restart(sparemsg);
-  }
-
-  if (!_res.nscount) {
-    _res.nscount = 1;
-    _res.nsaddr_list[0].sin_addr.s_addr = inet_addr("127.0.0.1");
-  }
-  _res.options |= RES_NOALIASES;
-#ifdef DEBUG
-  _res.options |= RES_DEBUG;
-#endif
-#ifdef IPV6
-  /* only do this if ipv6 is enabled, duh! -- jilles */
-  _res.options |= RES_USE_INET6;
-#endif
-  if (ResolverFileDescriptor < 0) {
-    ResolverFileDescriptor = socket(AF_INET, SOCK_DGRAM, 0);
-    set_non_blocking(ResolverFileDescriptor);
-  }
-}
-
-/*
- * init_resolver - initialize resolver and resolver library
- */
-int init_resolver(void)
-{
-
-#ifdef  LRAND48
-  srand48(CurrentTime);
-#endif
-  /*
-   * XXX - we don't really need to do this, all of these are static
-   */
-  memset((void*) &cainfo,   0, sizeof(cainfo));
-  memset((void*) hashtable, 0, sizeof(hashtable));
-  memset((void*) &reinfo,   0, sizeof(reinfo));
-
-  requestListHead = requestListTail = NULL;
-  start_resolver();
-  return ResolverFileDescriptor;
-}
-
-/*
- * restart_resolver - flush the cache, reread resolv.conf, reopen socket
- */
-void restart_resolver(void)
-{
-  /* flush_cache();  flush the dns cache */
-  start_resolver();
-}
-
-/*
- * add_local_domain - Add the domain to hostname, if it is missing
- * (as suggested by eps@TOASTER.SFSU.EDU)
- */
-void add_local_domain(char* hname, size_t size)
-{
-  assert(0 != hname);
-  /* 
-   * try to fix up unqualified names 
-   */
-  if ((_res.options & RES_DEFNAMES) && !strchr(hname, '.')) {
-#if 0
-    /*
-     * XXX - resolver should already be initialized
-     */
-    if (0 == (_res.options & RES_INIT))
-      init_resolver();
-#endif 
-    if (_res.defdname[0]) {
-      size_t len = strlen(hname);
-      if ((strlen(_res.defdname) + len + 2) < size) {
-        hname[len++] = '.';
-        strcpy(hname + len, _res.defdname);
-      }
-    }
-  }
-}
-
-/*
- * add_request - place a new request in the request list
- */
-static void add_request(ResRQ* request)
-{
-  assert(0 != request);
-  if (!requestListHead)
-    requestListHead = requestListTail = request;
-  else {
-    requestListTail->next = request;
-    requestListTail = request;
-  }
-  request->next = NULL;
-  reinfo.re_requests++;
-}
-
-/*
- * rem_request - remove a request from the list. 
- * This must also free any memory that has been allocated for 
- * temporary storage of DNS results.
- */
-static void rem_request(ResRQ* request)
-{
-  ResRQ** current;
-  ResRQ*  prev = NULL;
-
-  assert(0 != request);
-  for (current = &requestListHead; *current; ) {
-    if (*current == request) {
-      *current = request->next;
-      if (requestListTail == request)
-        requestListTail = prev;
-      break;
-    } 
-    prev    = *current;
-    current = &(*current)->next;
-  }
-#ifdef  DEBUG
-  Debug((DEBUG_DNS, "rem_request:Remove %#x at %#x %#x",
-         old, *current, prev));
-#endif
-  MyFree(request->he.buf);
-  MyFree(request->name);
-  MyFree(request);
-}
-
-/*
- * make_request - Create a DNS request record for the server.
- */
-static ResRQ* make_request(const struct DNSQuery* query)
-{
-  ResRQ* request;
-  assert(0 != query);
-  expect_malloc;
-  request = (ResRQ*) MyMalloc(sizeof(ResRQ));
-  malloc_log("make_request() allocating ResRQ (%zd bytes) at %p",
-             sizeof(ResRQ), (void *)request);
-  memset(request, 0, sizeof(ResRQ));
-
-  request->sentat  = CurrentTime;
-  request->retries = 3;
-  request->resend  = 1;
-  request->timeout = 2;    /* start at 2 and exponential inc. */
-#ifndef IPV6
-  request->addr.s_addr      = INADDR_NONE;
-#endif
-  request->he.h.h_addrtype  = AFINET;
-  request->he.h.h_length    = sizeof(struct IN_ADDR);
-  request->query.vptr       = query->vptr;
-  request->query.callback   = query->callback;
-
-#if defined(NULL_POINTER_NOT_ZERO)
-  request->next             = NULL;
-  request->he.buf           = NULL;
-  request->he.h.h_name      = NULL;
-  request->he.h.h_aliases   = NULL;
-  request->he.h.h_addr_list = NULL;
-#endif
-  add_request(request);
-  return request;
-}
-
-/*
- * timeout_query_list - Remove queries from the list which have been 
- * there too long without being resolved.
- */
-static time_t timeout_query_list(time_t now)
-{
-  ResRQ*   request;
-  ResRQ*   next_request = 0;
-  time_t   next_time    = 0;
-  time_t   timeout      = 0;
-
-  Debug((DEBUG_DNS, "timeout_query_list at %s", myctime(now)));
-  for (request = requestListHead; request; request = next_request) {
-    next_request = request->next;
-    timeout = request->sentat + request->timeout;
-    if (now >= timeout) {
-      if (--request->retries <= 0) {
-#ifdef DEBUG
-        Debug((DEBUG_ERROR, "timeout %x now %d cptr %x",
-               request, now, request->cinfo.value.cptr));
-#endif
-        reinfo.re_timeouts++;
-        (*request->query.callback)(request->query.vptr, 0);
-        rem_request(request);
-        continue;
-      }
-      else {
-        request->sentat = now;
-        request->timeout += request->timeout / 2;
-        logprintf(L_WARN, "DNS lookup timed out, new timeout %lu, retries %d", (long unsigned)request->timeout, request->retries);
-        resend_query(request);
-#ifdef DEBUG
-        Debug((DEBUG_INFO,"r %x now %d retry %d c %x",
-               request, now, request->retries,
-               request->cinfo.value.cptr));
-#endif
-      }
-    }
-    if (!next_time || timeout < next_time) {
-      next_time = timeout;
-    }
-  }
-  return (next_time > now) ? next_time : (now + AR_TTL);
-}
-
-/*
- * expire_cache - removes entries from the cache which are older 
- * than their expiry times. returns the time at which the server 
- * should next poll the cache.
- */
-static time_t expire_cache(time_t now)
-{
-  aCache* cp;
-  aCache* cp2;
-  time_t  next = 0;
-
-  for (cp = cacheTop; cp; cp = cp2) {
-    cp2 = cp->list_next;
-    if (cp->expireat < now) {
-      cainfo.ca_expires++;
-      rem_cache(cp);
-    }
-    else if (!next || next > cp->expireat)
-      next = cp->expireat;
-  }
-  return (next > now) ? next : (now + AR_TTL);
-}
-
-/*
- * timeout_resolver - check request list and cache for expired entries
- */
-time_t timeout_resolver(time_t now)
-{
-  if (nextDNSCheck < now)
-    nextDNSCheck = timeout_query_list(now);
-  if (nextCacheExpire < now)
-    nextCacheExpire = expire_cache(now);
-  return IRCD_MIN(nextDNSCheck, nextCacheExpire);
-}
-
-
-/*
- * delete_resolver_queries - cleanup outstanding queries 
- * for which there no longer exist clients or conf lines.
- */
-void delete_resolver_queries(const void* vptr)
-{
-  ResRQ* request;
-  ResRQ* next_request;
-
-  for (request = requestListHead; request; request = next_request) {
-    next_request = request->next;
-    if (vptr == request->query.vptr)
-      rem_request(request);
-  }
-}
-
-/*
- * send_res_msg - sends msg to all nameservers found in the "_res" structure.
- * This should reflect /etc/resolv.conf. We will get responses
- * which arent needed but is easier than checking to see if nameserver
- * isnt present. Returns number of messages successfully sent to 
- * nameservers or -1 if no successful sends.
- */
-static int send_res_msg(const char* msg, int len, int rcount)
-{
-  int i;
-  int sent = 0;
-  int max_queries = IRCD_MIN(_res.nscount, rcount);
-
-  assert(0 != msg);
-  /*
-   * RES_PRIMARY option is not implemented
-   * if (_res.options & RES_PRIMARY || 0 == max_queries)
-   */
-  if (0 == max_queries)
-    max_queries = 1;
-
-  for (i = 0; i < max_queries; i++) {
-    /*
-     * XXX - this should already have been done by res_init
-     */
-    _res.nsaddr_list[i].sin_family = AF_INET;
-    if (sendto(ResolverFileDescriptor, msg, len, 0, 
-               (struct sockaddr*) &(_res.nsaddr_list[i]),
-               sizeof(struct sockaddr_in)) == len) {
-      ++reinfo.re_sent;
-      ++sent;
-    }
-    else
-      {
-        Debug((DEBUG_ERROR,"s_r_m:sendto: %d on %d", 
-               errno, ResolverFileDescriptor));
-      }
-  }
-  return sent;
-}
-
-/*
- * find_id - find a dns request id (id is determined by dn_mkquery)
- */
-static ResRQ* find_id(int id)
-{
-  ResRQ* request;
-
-  for (request = requestListHead; request; request = request->next) {
-    if (request->id == id)
-      return request;
-  }
-  return NULL;
-}
-
-/*
- * gethost_byname_type - get host address from name
- */
-
-struct DNSReply* gethost_byname_type(const char* name, 
-                               const struct DNSQuery* query,
-                               int type)
-{
-  aCache* cp;
-  assert(0 != name);
-
-  ++reinfo.re_na_look;
-  if ((cp = find_cache_name(name)))
-    return &(cp->reply);
-
-  do_query_name(query, name, NULL, type);
-  nextDNSCheck = 1;
-  return NULL;
-}
-
-/* Try to get a IPv6 address first, un;ess we're not using IPv6; in which case
- * just look up boring old v4 - stu
- */
-struct DNSReply* gethost_byname(const char* name, const struct DNSQuery* query)
-{
-#ifdef IPV6
-  return gethost_byname_type(name, query, T_AAAA);
-#else
-  return gethost_byname_type(name, query, T_A);
-#endif
-}
-/*
- * gethost_byaddr - get host name from address
- */
-struct DNSReply* gethost_byaddr(const char* addr,
-                                const struct DNSQuery* query)
-{
-  aCache *cp;
-
-  assert(0 != addr);
-
-  ++reinfo.re_nu_look;
-  if ((cp = find_cache_number(NULL, addr)))
-    return &(cp->reply);
-
-  do_query_number(query, (const struct IN_ADDR*)addr, NULL);
-  nextDNSCheck = 1;
-  return NULL;
-}
-/*
- * do_query_name - nameserver lookup name
- */
-static void do_query_name(const struct DNSQuery* query, 
-                          const char* name, ResRQ* request, int type)
-{
-  char  hname[HOSTLEN + 1];
-  assert(0 != name);
-
-  strncpy_irc(hname, name, HOSTLEN + 1);
-  hname[HOSTLEN] = '\0';
-  add_local_domain(hname, HOSTLEN);
-
-  if (!request) {
-    request       = make_request(query);
-    request->type = type;
-    DupString(request->name, hname);
-  }
-  query_name(hname, C_IN, type, request);
-}
-
-/*
- * do_query_number - Use this to do reverse IP# lookups.
- */
-static void do_query_number(const struct DNSQuery* query, 
-                            const struct IN_ADDR* addr,
-                            ResRQ* request)
-{
-  char  ipbuf[128];
-  const unsigned char* cp;
-
-#ifdef IPV6
-    cp = (const u_char *)addr->s6_addr;
-    if (cp[0]==0 && cp[1]==0 && cp[2]==0 && cp[3]==0 && cp[4]==0 &&
-        cp[5]==0 && cp[6]==0 && cp[7]==0 && cp[8]==0 && cp[9]==0 &&
-        ((cp[10]==0 && cp[11]==0) || (cp[10]==0xff && cp[11]==0xff)))
-        {
-        (void)sprintf(ipbuf, "%u.%u.%u.%u.in-addr.arpa.",
-                  (u_int)(cp[15]), (u_int)(cp[14]),
-                  (u_int)(cp[13]), (u_int)(cp[12]));
-        }
-    else
-        {
-        (void)sprintf(ipbuf,
-"%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.ip6.%s.",
-        (u_int)(cp[15]&0xf), (u_int)(cp[15]>>4),
-        (u_int)(cp[14]&0xf), (u_int)(cp[14]>>4),
-        (u_int)(cp[13]&0xf), (u_int)(cp[13]>>4),
-        (u_int)(cp[12]&0xf), (u_int)(cp[12]>>4),
-        (u_int)(cp[11]&0xf), (u_int)(cp[11]>>4),
-        (u_int)(cp[10]&0xf), (u_int)(cp[10]>>4),
-        (u_int)(cp[9]&0xf), (u_int)(cp[9]>>4),
-        (u_int)(cp[8]&0xf), (u_int)(cp[8]>>4),
-        (u_int)(cp[7]&0xf), (u_int)(cp[7]>>4),
-        (u_int)(cp[6]&0xf), (u_int)(cp[6]>>4),
-        (u_int)(cp[5]&0xf), (u_int)(cp[5]>>4),
-        (u_int)(cp[4]&0xf), (u_int)(cp[4]>>4),
-        (u_int)(cp[3]&0xf), (u_int)(cp[3]>>4),
-        (u_int)(cp[2]&0xf), (u_int)(cp[2]>>4),
-        (u_int)(cp[1]&0xf), (u_int)(cp[1]>>4),
-        (u_int)(cp[0]&0xf), (u_int)(cp[0]>>4),
-        /* use ip6.arpa for the first request */
-        (request == NULL ? "arpa" : "int")
-        );
-        }
-#else
-    cp = (const u_char *)&addr->s_addr;
-    (void)sprintf(ipbuf, "%u.%u.%u.%u.in-addr.arpa.",
-              (u_int)(cp[3]), (u_int)(cp[2]),
-              (u_int)(cp[1]), (u_int)(cp[0]));
-#endif
-
-  assert(0 != addr);
-
-  if (!request) {
-    request              = make_request(query);
-    request->type        = T_PTR;
-#ifdef IPV6
-        memcpy((char *)&request->addr.s6_addr, (const char *)addr->s6_addr,
-            sizeof(struct in6_addr));
-#else
-        memcpy((char *)&request->addr.s_addr, (const char *)&addr->s_addr,
-            sizeof(struct in_addr));
-#endif
-  }
-  query_name(ipbuf, C_IN, T_PTR, request);
-}
-
-/*
- * query_name - generate a query based on class, type and name.
- */
-static void query_name(const char* name, int query_class,
-                       int type, ResRQ* request)
-{
-  char buf[MAXPACKET];
-  int  request_len = 0;
-
-  assert(0 != name);
-  assert(0 != request);
-
-  memset(buf, 0, sizeof(buf));
-  if ((request_len = res_mkquery(QUERY, name, query_class, type, 
-                                 NULL, 0, NULL, (u_char *) buf, sizeof(buf))) > 0) {
-    HEADER* header = (HEADER*) buf;
-#ifndef LRAND48
-    int            k = 0;
-    struct timeval tv;
-#endif
-    /*
-     * generate a unique id
-     * NOTE: we don't have to worry about converting this to and from
-     * network byte order, the nameserver does not interpret this value
-     * and returns it unchanged
-     */
-#ifdef LRAND48
-    do {
-      header->id = (header->id + lrand48()) & 0xffff;
-    } while (find_id(header->id));
-#else
-    gettimeofday(&tv, NULL);
-    do {
-      header->id = (header->id + k + tv.tv_usec) & 0xffff;
-      k++;
-    } while (find_id(header->id));
-#endif /* LRAND48 */
-    request->id = header->id;
-    ++request->sends;
-
-    request->sent += send_res_msg(buf, request_len, request->sends);
-  }
-}
-
-static void resend_query(ResRQ* request)
-{
-  assert(0 != request);
-
-  if (request->resend == 0)
-    return;
-  ++reinfo.re_resends;
-  switch(request->type) {
-  case T_PTR:
-    do_query_number(NULL, &request->addr, request);
-    break;
-#ifdef IPV6
-  case T_AAAA:
-#endif
-  case T_A:
-    do_query_name(NULL, request->name, request, request->type);
-    break;
-  default:
-    break;
-  }
-}
-
-/*
- * proc_answer - process name server reply
- * build a hostent struct in the passed request
- */
-static int proc_answer(ResRQ* request, HEADER* header,
-                       char* buf, char* eob)
-{
-  char   hostbuf[HOSTLEN+1+100]; /* working buffer */
-  unsigned char*  current;              /* current position in buf */
-  char** alias;                /* alias list */
-  char** addr;                 /* address list */
-  char*  name;                 /* pointer to name string */
-  char*  address;              /* pointer to address */
-  char*  endp;                 /* end of our buffer */
-  int    query_class;          /* answer class */
-  int    type;                 /* answer type */
-  unsigned int    rd_length;            /* record data length */
-  int    answer_count = 0;     /* answer counter */
-  int    n;                    /* temp count */
-  int    addr_count  = 0;      /* number of addresses in hostent */
-  int    alias_count = 0;      /* number of aliases in hostent */
-  struct hostent* hp;          /* hostent getting filled */
-
-  assert(0 != request);
-  assert(0 != header);
-  assert(0 != buf);
-  assert(0 != eob);
-  
-  current = (unsigned char *) buf + sizeof(HEADER);
-  hp = &(request->he.h);
-  /*
-   * lazy allocation of request->he.buf, we don't allocate a buffer
-   * unless there is something to put in it.
-   */
-  if (!request->he.buf) {
-    expect_malloc;
-    request->he.buf = (char*) MyMalloc(MAXGETHOSTLEN + 1);
-    malloc_log("proc_answer() allocating request->he.buf (%zd bytes) at %p",
-               MAXGETHOSTLEN + 1, request->he.buf);
-    request->he.buf[MAXGETHOSTLEN] = '\0';
-    /*
-     * array of alias list pointers starts at beginning of buf
-     */
-    hp->h_aliases = (char**) request->he.buf;
-    hp->h_aliases[0] = NULL;
-    /*
-     * array of address list pointers starts after alias list pointers
-     * the actual addresses follow the the address list pointers
-     */ 
-    hp->h_addr_list = (char**)(request->he.buf + ALIAS_BLEN);
-    /*
-     * don't copy the host address to the beginning of h_addr_list
-     */
-    hp->h_addr_list[0] = NULL;
-  }
-  endp = request->he.buf + MAXGETHOSTLEN;
-  /*
-   * find the end of the address list
-   */
-  addr = hp->h_addr_list;
-  while (*addr) {
-    ++addr;
-    ++addr_count;
-  }
-  /*
-   * make address point to first available address slot
-   */
-  address = request->he.buf + ADDRS_OFFSET +
-                     (sizeof(struct IN_ADDR) * addr_count);
-
-  /*
-   * find the end of the alias list
-   */
-  alias = hp->h_aliases;
-  while (*alias) {
-    ++alias;
-    ++alias_count;
-  }
-  /*
-   * make name point to first available space in request->buf
-   */
-  if (alias_count > 0) {
-    name = hp->h_aliases[alias_count - 1];
-    name += (strlen(name) + 1);
-  }
-  else if (hp->h_name)
-    name = hp->h_name + strlen(hp->h_name) + 1;
-  else
-    name = request->he.buf + ADDRS_OFFSET + ADDRS_DLEN;
- 
-  /*
-   * skip past queries
-   */ 
-  for (; header->qdcount > 0; --header->qdcount) {
-    if ((n = dn_skipname(current, (u_char *) eob)) < 0)
-      break;
-    current += (size_t) n + QFIXEDSZ;
-  }
-  /*
-   * process each answer sent to us blech.
-   */
-  while (header->ancount-- > 0 && (char *) current < eob && name < endp) {
-    n = dn_expand((u_char *) buf, (u_char *) eob, current, hostbuf, sizeof(hostbuf));
-    if (n < 0) {
-      /*
-       * broken message
-       */
-      return 0;
-    }
-    else if (n == 0) {
-      /*
-       * no more answers left
-       */
-      return answer_count;
-    }
-    hostbuf[HOSTLEN] = '\0';
-    /* 
-     * With Address arithmetic you have to be very anal
-     * this code was not working on alpha due to that
-     * (spotted by rodder/jailbird/dianora)
-     */
-    current += (size_t) n;
-
-    if (!(((char *)current + ANSWER_FIXED_SIZE) < eob))
-      break;
-
-    type = _getshort(current);
-    current += TYPE_SIZE;
-
-    query_class = _getshort(current);
-    current += CLASS_SIZE;
-
-    request->ttl = _getlong(current);
-    current += TTL_SIZE;
-
-    rd_length = _getshort(current);
-    current += RDLENGTH_SIZE;
-
-    /* 
-     * Wait to set request->type until we verify this structure 
-     */
-    /* add_local_domain(hostbuf, HOSTLEN); */
-
-    switch(type) {
-#ifdef IPV6
-      case T_AAAA:
-#endif
-    case T_A:
-      /*
-       * check for invalid rd_length or too many addresses
-       */
-      if (rd_length != ((type==T_AAAA) ? sizeof(struct in6_addr) :
-          sizeof(struct in_addr)))
-        return answer_count;
-      if (++addr_count < RES_MAXADDRS) {
-        if (answer_count == 1)
-          hp->h_addrtype = (query_class == C_IN) ?  AF_INET : AF_UNSPEC;
-
-
-#ifdef IPV6
-        if (type == T_AAAA)
-          memcpy(address, (const char*)current, rd_length);
-        else {
-          struct in6_addr tmp;
-          char nam[HOSTLEN];
-          memcpy((char*)tmp.s6_addr, address, sizeof(struct in6_addr));
-          inetntop(AFINET, &tmp, nam, HOSTLEN);
-          
-          /* ugly hack */
-          memset(tmp.s6_addr, 0, 10);
-          tmp.s6_addr[10] = tmp.s6_addr[11] = 0xff;
-          memcpy(tmp.s6_addr+12, current, 4);
-          memcpy(address, (const char*)tmp.s6_addr, sizeof(struct in6_addr));
-        }
-#else
-        memcpy(address, current, rd_length);
-#endif
-
-        *addr++ = address;
-        *addr = 0;
-        address += sizeof(struct IN_ADDR);
-        if (!hp->h_name) {
-          strcpy(name, hostbuf);
-          hp->h_name = name;
-          name += strlen(name) + 1;
-        }
-        Debug((DEBUG_INFO,"got ip # %s for %s", 
-              inetntoa((char*) hp->h_addr_list[addr_count - 1]), hostbuf));
-      }
-      current += rd_length;
-      ++answer_count;
-      break;
-    case T_PTR:
-      n = dn_expand((u_char *) buf, (u_char *) eob, current, hostbuf, sizeof(hostbuf));
-      if (n < 0) {
-        /*
-         * broken message
-         */
-        return 0;
-      }
-      else if (n == 0) {
-        /*
-         * no more answers left
-         */
-        return answer_count;
-      }
-      /*
-       * This comment is based on analysis by Shadowfax, Wohali and johan, 
-       * not me.  (Dianora) I am only commenting it.
-       *
-       * dn_expand is guaranteed to not return more than sizeof(hostbuf)
-       * but do all implementations of dn_expand also guarantee
-       * buffer is terminated with null byte? Lets not take chances.
-       *  -Dianora
-       */
-      hostbuf[HOSTLEN] = '\0';
-      current += (size_t) n;
-
-      Debug((DEBUG_INFO,"got host %s",hostbuf));
-      /*
-       * copy the returned hostname into the host name
-       * ignore duplicate ptr records
-       */
-      if (!hp->h_name) {
-        strcpy(name, hostbuf);
-        hp->h_name = name;
-        name += strlen(name) + 1;
-      }
-      ++answer_count;
-      break;
-    case T_CNAME:
-      Debug((DEBUG_INFO,"got cname %s", hostbuf));
-      if (++alias_count < RES_MAXALIASES) {
-        strncpy_irc(name, hostbuf, endp - name);
-        *alias++ = name;
-        *alias   = 0;
-        name += strlen(name) + 1;
-      }
-      current += rd_length;
-      ++answer_count;
-      break;
-    default :
-#ifdef DEBUG
-      Debug((DEBUG_INFO,"proc_answer: type:%d for:%s", type, hostbuf));
-#endif
-      break;
-    }
-  }
-  return answer_count;
-}
-
-/*
- * get_res - read a dns reply from the nameserver and process it.
- */
-void get_res(void)
-{
-  char               buf[sizeof(HEADER) + MAXPACKET];
-  HEADER*            header;
-  ResRQ*             request = NULL;
-  aCache*            cp = NULL;
-  size_t             rc;
-  int                answer_count;
-  int                type;
-  socklen_t          len = sizeof(struct sockaddr_in);
-  struct sockaddr_in res_sin;
-#ifdef IPV6
-  struct IN_ADDR     mapped; /* Temp struct to test for a v4 mapped address */
-#endif
-
-  rc = recvfrom(ResolverFileDescriptor, buf, sizeof(buf), 0, 
-                (struct sockaddr*) &res_sin, &len);
-  if (rc <= sizeof(HEADER))
-    return;
-  /*
-   * convert DNS reply reader from Network byte order to CPU byte order.
-   */
-  header = (HEADER*) buf;
-  /* header->id = ntohs(header->id); */
-  header->ancount = ntohs(header->ancount);
-  header->qdcount = ntohs(header->qdcount);
-  header->nscount = ntohs(header->nscount);
-  header->arcount = ntohs(header->arcount);
-#ifdef  DEBUG
-  Debug((DEBUG_NOTICE, "get_res:id = %d rcode = %d ancount = %d",
-         header->id, header->rcode, header->ancount));
-#endif
-  ++reinfo.re_replies;
-  /*
-   * response for an id which we have already received an answer for
-   * just ignore this response.
-   */
-  if (0 == (request = find_id(header->id)))
-    return;
-  /*
-   * check against possibly fake replies
-   */
-  if (!res_ourserver(&_res, &res_sin)) {
-    ++reinfo.re_unkrep;
-    return;
-  }
-
-  if ((header->rcode != NOERROR) || (header->ancount == 0)) {
-    ++reinfo.re_errors;
-    if (SERVFAIL == header->rcode)
-      resend_query(request);
-	else if(request->type == T_AAAA)
-	{
-      request->type = T_A;
-      resend_query(request);
-	}
-    else {
-      /*
-       * If a bad error was returned, we stop here and dont send
-       * send any more (no retries granted).
-       */
-      Debug((DEBUG_DNS, "Fatal DNS error: %d", header->rcode));
-      (*request->query.callback)(request->query.vptr, 0);
-      rem_request(request);
-    } 
-    return;
-  }
-  /*
-   * If this fails there was an error decoding the received packet, 
-   * try it again and hope it works the next time.
-   */
-  answer_count = proc_answer(request, header, buf, buf + rc);
-#ifdef DEBUG
-  Debug((DEBUG_INFO,"get_res:Proc answer = %d",a));
-#endif
-  if (answer_count) {
-    if (request->type == T_PTR) {
-      struct DNSReply* reply = NULL;
-      if (0 == request->he.h.h_name) {
-        /*
-         * got a PTR response with no name, something bogus is happening
-         * don't bother trying again, the client address doesn't resolve
-         */
-        (*request->query.callback)(request->query.vptr, reply);
-        rem_request(request);
-        return;
-      }
-      
-      Debug((DEBUG_DNS, "relookup %s <-> %s",
-             request->he.h.h_name, inetntoa((char*) &request->he.h.h_addr)));
-      /*
-       * Lookup the 'authoritive' name that we were given for the
-       * ip#.  By using this call rather than regenerating the
-       * type we automatically gain the use of the cache with no
-       * extra kludges.
-       */
-#ifdef  IPV6
-      memcpy((char*)&mapped.S_ADDR, (const char*)request->addr.S_ADDR, sizeof(struct IN_ADDR));
-      if (IN6_IS_ADDR_V4MAPPED(&mapped))
-      {
-        type = T_A;
-      }
-      else
-      {
-        type = T_AAAA;
-      }
-#else
-      type = T_A;
-#endif
-
-      reply = gethost_byname_type(request->he.h.h_name, &request->query, type);
-      if (0 == reply) {
-        /*
-         * If name wasn't found, a request has been queued and it will
-         * be the last one queued.  This is rather nasty way to keep
-         * a host alias with the query. -avalon
-         */
-        MyFree(requestListTail->he.buf);
-        requestListTail->he.buf = request->he.buf;
-        request->he.buf = 0;
-        memcpy(&requestListTail->he.h, &request->he.h, sizeof(struct hostent));
-      }
-      else
-        (*request->query.callback)(request->query.vptr, reply);
-      rem_request(request);
-    }
-    else {
-      /*
-       * got a name and address response, client resolved
-       */
-      cp = make_cache(request);
-
-      /* if cp is NULL then don't try to use it...&cp->reply will be 0x2c
-       * in this case btw.
-       * make_cache can return NULL if hp->h_name and hp->h_addr_list[0]
-       * are NULL -Dianora
-       */
-
-      if(cp)
-        {        
-          (*request->query.callback)(request->query.vptr, &cp->reply);
-        }
-      else
-        {
-          (*request->query.callback)(request->query.vptr, 0 );
-        }
-
-#ifdef  DEBUG
-      Debug((DEBUG_INFO,"get_res:cp=%#x request=%#x (made)",cp,request));
-#endif
-      rem_request(request);
-    }
-  }
-  else if (!request->sent) {
-    /*
-     * XXX - we got a response for a query we didn't send with a valid id?
-     * this should never happen, bail here and leave the client unresolved
-     */
-    (*request->query.callback)(request->query.vptr, 0);
-    rem_request(request);
-  }
-}
-
-
-/*
- * dup_hostent - Duplicate a hostent struct, allocate only enough memory for
- * the data we're putting in it.
- */
-static void dup_hostent(aHostent* new_hp, struct hostent* hp)
-{
-  char*  p;
-  char** ap;
-  char** pp;
-  int    alias_count = 0;
-  int    addr_count = 0;
-  size_t bytes_needed = 0;
-
-  assert(0 != new_hp);
-  assert(0 != hp);
-
-  /* how much buffer do we need? */
-  bytes_needed += (strlen(hp->h_name) + 1);
-
-  pp = hp->h_aliases;
-  while (*pp) {
-    bytes_needed += (strlen(*pp++) + 1 + sizeof(void*));
-    ++alias_count;
-  }
-  pp = hp->h_addr_list;
-  while (*pp++) {
-    bytes_needed += (hp->h_length + sizeof(void*));
-    ++addr_count;
-  }
-  /* Reserve space for 2 nulls to terminate h_aliases and h_addr_list */
-  bytes_needed += (2 * sizeof(void*));
-
-  /* Allocate memory */
-  expect_malloc;
-  new_hp->buf = (char*) MyMalloc(bytes_needed);
-  malloc_log("dup_hostent() allocating new_hp->buf (%zd bytes) at %p",
-             bytes_needed, new_hp->buf);
-
-  new_hp->h.h_addrtype = hp->h_addrtype;
-  new_hp->h.h_length = hp->h_length;
-
-  /* first write the address list */
-  pp = hp->h_addr_list;
-  ap = new_hp->h.h_addr_list =
-      (char**)(new_hp->buf + ((alias_count + 1) * sizeof(void*)));
-  p = (char*)ap + ((addr_count + 1) * sizeof(void*));
-  while (*pp)
-  {
-    *ap++ = p;
-    memcpy(p, *pp++, hp->h_length);
-    p += hp->h_length;
-  }
-  *ap = 0;
-  /* next write the name */
-  new_hp->h.h_name = p;
-  strcpy(p, hp->h_name);
-  p += (strlen(p) + 1);
-
-  /* last write the alias list */
-  pp = hp->h_aliases;
-  ap = new_hp->h.h_aliases = (char**) new_hp->buf;
-  while (*pp) {
-    *ap++ = p;
-    strcpy(p, *pp++);
-    p += (strlen(p) + 1);
-  }
-  *ap = 0;
-}
-
-/*
- * update_hostent - Add records to a Hostent struct in place.
- */
-static int update_hostent(aHostent* hp, char** addr, char** alias)
-{
-  char*  p;
-  char** ap;
-  char** pp;
-  int    alias_count = 0;
-  int    addr_count = 0;
-  char*  buf = NULL;
-  size_t bytes_needed = 0;
-
-  if (!hp || !hp->buf)
-    return -1;
-
-  /* how much buffer do we need? */
-  bytes_needed = strlen(hp->h.h_name) + 1;
-  pp = hp->h.h_aliases;
-  while (*pp) {
-    bytes_needed += (strlen(*pp++) + 1 + sizeof(void*));
-    ++alias_count;
-  }
-  if (alias) {
-    pp = alias;
-    while (*pp) {
-      bytes_needed += (strlen(*pp++) + 1 + sizeof(void*));
-      ++alias_count;
-    }
-  }
-  pp = hp->h.h_addr_list;
-  while (*pp++) {
-    bytes_needed += (hp->h.h_length + sizeof(void*));
-    ++addr_count;
-  }
-  if (addr) {
-    pp = addr;
-    while (*pp++) {
-      bytes_needed += (hp->h.h_length + sizeof(void*));
-      ++addr_count;
-    }
-  }
-  /* Reserve space for 2 nulls to terminate h_aliases and h_addr_list */
-  bytes_needed += 2 * sizeof(void*);
-
-  /* Allocate memory */
-  expect_malloc;
-  buf = (char*) MyMalloc(bytes_needed);
-  malloc_log("update_hostent() allocating buf (%zd bytes) at %p",
-             bytes_needed, buf);
-
-  /* first write the address list */
-  pp = hp->h.h_addr_list;
-  ap = hp->h.h_addr_list =
-      (char**)(buf + ((alias_count + 1) * sizeof(void*)));
-  p = (char*)ap + ((addr_count + 1) * sizeof(void*));
-  while (*pp) {
-    memcpy(p, *pp++, hp->h.h_length);
-    *ap++ = p;
-    p += hp->h.h_length;
-  }
-  if (addr) {
-    while (*addr) {
-      memcpy(p, *addr++, hp->h.h_length);
-      *ap++ = p;
-      p += hp->h.h_length;
-    }
-  }
-  *ap = 0;
-
-  /* next write the name */
-  strcpy(p, hp->h.h_name);
-  hp->h.h_name = p;
-  p += (strlen(p) + 1);
-
-  /* last write the alias list */
-  pp = hp->h.h_aliases;
-  ap = hp->h.h_aliases = (char**) buf;
-  while (*pp) {
-    strcpy(p, *pp++);
-    *ap++ = p;
-    p += (strlen(p) + 1);
-  }
-  if (alias) {
-    while (*alias) {
-      strcpy(p, *alias++);
-      *ap++ = p;
-      p += (strlen(p) + 1);
-    }
-  }
-  *ap = 0;
-  /* release the old buffer */
-  p = hp->buf;
-  hp->buf = buf;
-  MyFree(p);
-  return 0;
-}
-
-/*
- * hash_number - IP address hash function
- */
-static int hash_number(const unsigned char* ip)
-{
-  /* could use loop but slower */
-  unsigned int hashv = (unsigned int) *ip++;
-  hashv += hashv + (unsigned int) *ip++;
-  hashv += hashv + (unsigned int) *ip++;
-  hashv += hashv + (unsigned int) *ip;
-  hashv %= ARES_CACSIZE;
-  return (hashv);
-}
-
-/*
- * hash_name - hostname hash function
- */
-static int hash_name(const char* name)
-{
-  unsigned int hashv = 0;
-
-  for (; *name && *name != '.'; name++)
-    hashv += *name;
-  hashv %= ARES_CACSIZE;
-  return (hashv);
-}
-
-/*
- * add_to_cache - Add a new cache item to the queue and hash table.
- */
-static aCache* add_to_cache(aCache* ocp)
-{
-  aCache  *cp = NULL;
-  int  hashv;
-
-#ifdef DEBUG
-  Debug((DEBUG_INFO, "add_to_cache:ocp %#x he %#x name %#x addrl %#x 0 %#x",
-         ocp, &ocp->he, ocp->he.h.h_name, ocp->he.h.h_addr_list,
-         ocp->he.h.h_addr_list[0]));
-#endif
-  ocp->list_next = cacheTop;
-  cacheTop = ocp;
-
-  /*
-   * Make sure non-bind resolvers don't blow up (Thanks to Yves)
-   */
-  if (!ocp) return NULL;
-  if (!(ocp->he.h.h_name)) return NULL;
-  if (!(ocp->he.h.h_addr)) return NULL;
-  
-  hashv = hash_name(ocp->he.h.h_name);
-
-  ocp->hname_next = hashtable[hashv].name_list;
-  hashtable[hashv].name_list = ocp;
-
-  hashv = hash_number((unsigned char *)ocp->he.h.h_addr);
-
-  ocp->hnum_next = hashtable[hashv].num_list;
-  hashtable[hashv].num_list = ocp;
-
-#ifdef  DEBUG
-  Debug((DEBUG_INFO, "add_to_cache:added %s[%08x] cache %#x.",
-         ocp->he.h.h_name, ocp->he.h.h_addr_list[0], ocp));
-  Debug((DEBUG_INFO,
-         "add_to_cache:h1 %d h2 %x lnext %#x namnext %#x numnext %#x",
-         hash_name(ocp->he.h.h_name), hashv, ocp->list_next,
-         ocp->hname_next, ocp->hnum_next));
-#endif
-
-  /*
-   * LRU deletion of excessive cache entries.
-   */
-  if (++cachedCount > MAXCACHED) {
-    for (cp = cacheTop; cp->list_next; cp = cp->list_next)
-      ;
-    rem_cache(cp);
-  }
-  ++cainfo.ca_adds;
-  return ocp;
-}
-
-/*
- * update_list - does not alter the cache structure passed. It is assumed that
- * it already contains the correct expire time, if it is a new entry. Old
- * entries have the expirey time updated.
-*/
-static void update_list(ResRQ* request, aCache* cachep)
-{
-  aCache** cpp;
-  aCache*  cp = cachep;
-  char*    s;
-  char*    t;
-  int      i;
-  int      j;
-  char**   ap;
-  char*    addrs[RES_MAXADDRS + 1];
-  char*    aliases[RES_MAXALIASES + 1];
-
-  /*
-   * search for the new cache item in the cache list by hostname.
-   * If found, move the entry to the top of the list and return.
-   */
-  ++cainfo.ca_updates;
-
-  for (cpp = &cacheTop; *cpp; cpp = &((*cpp)->list_next)) {
-    if (cp == *cpp)
-      break;
-  }
-  if (!*cpp)
-    return;
-  *cpp = cp->list_next;
-  cp->list_next = cacheTop;
-  cacheTop = cp;
-  if (!request)
-    return;
-
-#ifdef  DEBUG
-  Debug((DEBUG_DEBUG,"u_l:cp %#x na %#x al %#x ad %#x",
-         cp, cp->he.h.h_name, cp->he.h.h_aliases, cp->he.h.h_addr));
-  Debug((DEBUG_DEBUG,"u_l:request %#x h_n %#x", 
-         request, request->he.h.h_name));
-#endif
-  /*
-   * Compare the cache entry against the new record.  Add any
-   * previously missing names for this entry.
-   */
-  *aliases = 0;
-  ap = aliases;
-  for (i = 0, s = request->he.h.h_name; s; s = request->he.h.h_aliases[i++]) {
-    for (j = 0, t = cp->he.h.h_name; t; t = cp->he.h.h_aliases[j++]) {
-      if (0 == irccmp(t, s))
-        break;
-    }
-    if (!t) {
-      *ap++ = s;
-      *ap = 0;
-    }
-  }
-  /*
-   * Do the same again for IP#'s.
-   */
-  *addrs = 0;
-  ap = addrs;
-  for (i = 0; (s = request->he.h.h_addr_list[i]); i++) {
-    for (j = 0; (t = cp->he.h.h_addr_list[j]); j++) {
-      if (!memcmp(t, s, sizeof(struct IN_ADDR)))
-        break;
-    }
-    if (!t) {
-      *ap++ = s;
-      *ap = 0;
-    }
-  }
-  if (*addrs || *aliases)
-    update_hostent(&cp->he, addrs, aliases);
-}
-
-/*
- * find_cache_name - find name in nameserver cache
- */
-static aCache* find_cache_name(const char* name)
-{
-  aCache* cp;
-  char*   s;
-  int     hashv;
-  int     i;
-
-  assert(0 != name);
-  hashv = hash_name(name);
-
-  cp = hashtable[hashv].name_list;
-#ifdef  DEBUG
-  Debug((DEBUG_DNS,"find_cache_name:find %s : hashv = %d",name,hashv));
-#endif
-
-  for (; cp; cp = cp->hname_next) {
-    for (i = 0, s = cp->he.h.h_name; s; s = cp->he.h.h_aliases[i++]) {
-      if (irccmp(s, name) == 0) {
-        ++cainfo.ca_na_hits;
-        update_list(NULL, cp);
-        return cp;
-      }
-    }
-  }
-
-  for (cp = cacheTop; cp; cp = cp->list_next) {
-    /*
-     * if no aliases or the hash value matches, we've already
-     * done this entry and all possiblilities concerning it.
-     */
-    if (!*cp->he.h.h_aliases)
-      continue;
-    if (!cp->he.h.h_name)   /* don't trust anything -Dianora */
-      continue;
-    if (hashv == hash_name(cp->he.h.h_name))
-      continue;
-    for (i = 0, s = cp->he.h.h_aliases[i]; s && i < RES_MAXALIASES; i++) {
-      if (!irccmp(name, s)) {
-        cainfo.ca_na_hits++;
-        update_list(NULL, cp);
-        return cp;
-      }
-    }
-  }
-  return NULL;
-}
-
-/*
- * find_cache_number - find a cache entry by ip# and update its expire time
- */
-static aCache* find_cache_number(ResRQ* request, const char* addr)
-{
-  aCache* cp;
-  int     hashv;
-  int     i;
-#ifdef  DEBUG
-  struct IN_ADDR* ip = (struct IN_ADDR*) addr;
-#endif
-
-  assert(0 != addr);
-  hashv = hash_number((unsigned const char*) addr);
-  cp = hashtable[hashv].num_list;
-#ifdef DEBUG
-  Debug((DEBUG_DNS,"find_cache_number:find %s[%08x]: hashv = %d",
-         inetntoa(addr), ntohl(ip->s_addr), hashv));
-#endif
-
-  for (; cp; cp = cp->hnum_next) {
-    for (i = 0; cp->he.h.h_addr_list[i]; i++) {
-      if (!memcmp(cp->he.h.h_addr_list[i], addr, sizeof(struct IN_ADDR))) {
-        cainfo.ca_nu_hits++;
-        update_list(NULL, cp);
-        return cp;
-      }
-    }
-  }
-  for (cp = cacheTop; cp; cp = cp->list_next) {
-    /*
-     * single address entry...would have been done by hashed
-     * search above...
-     */
-    if (!cp->he.h.h_addr_list[1])
-      continue;
-    /*
-     * if the first IP# has the same hashnumber as the IP# we
-     * are looking for, its been done already.
-     */
-    if (hashv == hash_number((unsigned char*)cp->he.h.h_addr_list[0]))
-      continue;
-    for (i = 1; cp->he.h.h_addr_list[i]; i++) {
-      if (!memcmp(cp->he.h.h_addr_list[i], addr, sizeof(struct IN_ADDR))) {
-        cainfo.ca_nu_hits++;
-        update_list(NULL, cp);
-        return cp;
-      }
-    }
-  }
-  return NULL;
-}
-
-static aCache* make_cache(ResRQ* request)
-{
-  aCache* cp;
-  int     i;
-  struct hostent* hp;
-  assert(0 != request);
-
-  hp = &request->he.h;
-  /*
-   * shouldn't happen but it just might...
-   */
-  if (!hp->h_name || !hp->h_addr_list[0])
-    return NULL;
-  /*
-   * Make cache entry.  First check to see if the cache already exists
-   * and if so, return a pointer to it.
-   */
-  for (i = 0; hp->h_addr_list[i]; ++i) {
-    if ((cp = find_cache_number(request, hp->h_addr_list[i])))
-      return cp;
-  }
-  /*
-   * a matching entry wasnt found in the cache so go and make one up.
-   */
-  expect_malloc;
-  cp = (aCache*) MyMalloc(sizeof(aCache));
-  malloc_log("make_cache() allocating aCache (%zd bytes) at %p",
-             sizeof(aCache), (void *)cp);
-  memset(cp, 0, sizeof(aCache));
-  dup_hostent(&cp->he, hp);
-  cp->reply.hp = &cp->he.h;
-
-  if (request->ttl < 600) {
-    ++reinfo.re_shortttl;
-    cp->ttl = 600;
-  }
-  else
-    cp->ttl = request->ttl;
-  cp->expireat = CurrentTime + cp->ttl;
-#ifdef DEBUG
-  Debug((DEBUG_INFO,"make_cache:made cache %#x", cp));
-#endif
-  return add_to_cache(cp);
-}
-
-/*
- * rem_cache - delete a cache entry from the cache structures 
- * and lists and return all memory used for the cache back to the memory pool.
- */
-static void rem_cache(aCache* ocp)
-{
-  aCache**        cp;
-  int             hashv;
-  struct hostent* hp;
-  assert(0 != ocp);
-
-  if (0 < ocp->reply.ref_count) {
-    ocp->expireat = CurrentTime + AR_TTL;
-    return;
-  }
-  hp = &ocp->he.h;
-
-#ifdef  DEBUG
-  Debug((DEBUG_DNS, "rem_cache: ocp %#x hp %#x l_n %#x aliases %#x",
-         ocp, hp, ocp->list_next, hp->h_aliases));
-#endif
-  /*
-   * remove cache entry from linked list
-   */
-  for (cp = &cacheTop; *cp; cp = &((*cp)->list_next)) {
-    if (*cp == ocp) {
-      *cp = ocp->list_next;
-      break;
-    }
-  }
-  /*
-   * XXX - memory leak!!!?
-   * remove cache entry from hashed name lists
-   */
-  assert(0 != hp->h_name);
-  if (hp->h_name == 0)
-    return;
-  hashv = hash_name(hp->h_name);
-
-#ifdef  DEBUG
-  Debug((DEBUG_DEBUG,"rem_cache: h_name %s hashv %d next %#x first %#x",
-        hp->h_name, hashv, ocp->hname_next, hashtable[hashv].name_list));
-#endif
-  for (cp = &hashtable[hashv].name_list; *cp; cp = &((*cp)->hname_next)) {
-    if (*cp == ocp) {
-      *cp = ocp->hname_next;
-      break;
-    }
-  }
-  /*
-   * remove cache entry from hashed number list
-   */
-  hashv = hash_number((unsigned char *)hp->h_addr);
-  /*
-   * XXX - memory leak!!!?
-   */
-  assert(-1 < hashv);
-  if (hashv < 0)
-    return;
-#ifdef  DEBUG
-  Debug((DEBUG_DEBUG,"rem_cache: h_addr %s hashv %d next %#x first %#x",
-         inetntoa(hp->h_addr), hashv, ocp->hnum_next,
-         hashtable[hashv].num_list));
-#endif
-  for (cp = &hashtable[hashv].num_list; *cp; cp = &((*cp)->hnum_next)) {
-    if (*cp == ocp) {
-      *cp = ocp->hnum_next;
-      break;
-    }
-  }
-  /*
-   * free memory used to hold the various host names and the array
-   * of alias pointers.
-   */
-  MyFree(ocp->he.buf);
-  MyFree(ocp);
-  --cachedCount;
-  ++cainfo.ca_dels;
-}
-
-/*
- * m_dns - dns status query
- */
-int m_dns(aClient *cptr, aClient *sptr, int parc, char *parv[])
-{
-  aCache* cp;
-  int     i;
-  struct hostent* hp;
-
-  if (!HasUmode(sptr,UMODE_DEBUG))
-    {
-      if (!SeesOperMessages(sptr))
-        sendto_one(sptr, form_str(ERR_NOPRIVILEGES), me.name, parv[0]);
-      else
-        sendto_one(sptr,":%s NOTICE %s :You have no d umode",me.name,parv[0]);
-      return 0;
-    }
-
-  if (parv[1] && *parv[1] == 'l') {
-    for(cp = cacheTop; cp; cp = cp->list_next) {
-      hp = &cp->he.h;
-      sendto_one(sptr, "NOTICE %s :Ex %.1ld ttl %.1ld host %s(%s)",
-                 parv[0], cp->expireat - CurrentTime, cp->ttl,
-                 hp->h_name, inetntoa(hp->h_addr));
-      for (i = 0; hp->h_aliases[i]; i++)
-        sendto_one(sptr,"NOTICE %s : %s = %s (CN)",
-                   parv[0], hp->h_name, hp->h_aliases[i]);
-      for (i = 1; hp->h_addr_list[i]; i++)
-        sendto_one(sptr,"NOTICE %s : %s = %s (IP)",
-                   parv[0], hp->h_name, inetntoa(hp->h_addr_list[i]));
-    }
-    return 0;
-  }
-  if (parv[1] && *parv[1] == 'd') {
-    sendto_one(sptr, "NOTICE %s :ResolverFileDescriptor = %d", parv[0], ResolverFileDescriptor);
-    return 0;
-  }
-  sendto_one(sptr,"NOTICE %s :Ca %d Cd %d Ce %d Cl %d Ch %d:%d Cu %d",
-             sptr->name,
-             cainfo.ca_adds, cainfo.ca_dels, cainfo.ca_expires,
-             cainfo.ca_lookups, cainfo.ca_na_hits, cainfo.ca_nu_hits, 
-             cainfo.ca_updates);
-  
-  sendto_one(sptr,"NOTICE %s :Re %d Rl %d/%d Rp %d Rq %d",
-             sptr->name, reinfo.re_errors, reinfo.re_nu_look,
-             reinfo.re_na_look, reinfo.re_replies, reinfo.re_requests);
-  sendto_one(sptr,"NOTICE %s :Ru %d Rsh %d Rs %d(%d) Rt %d", sptr->name,
-             reinfo.re_unkrep, reinfo.re_shortttl, reinfo.re_sent,
-             reinfo.re_resends, reinfo.re_timeouts);
-  return 0;
-}
-
-unsigned long cres_mem(aClient *sptr)
-{
-  aCache*          c = cacheTop;
-  struct  hostent* h;
-  int              i;
-  unsigned long    nm = 0;
-  unsigned long    im = 0;
-  unsigned long    sm = 0;
-  unsigned long    ts = 0;
-
-  for ( ;c ; c = c->list_next) {
-    sm += sizeof(*c);
-    h = &c->he.h;
-    for (i = 0; h->h_addr_list[i]; i++) {
-      im += sizeof(char *);
-      im += sizeof(struct IN_ADDR);
-    }
-    im += sizeof(char *);
-    for (i = 0; h->h_aliases[i]; i++) {
-      nm += sizeof(char *);
-      nm += strlen(h->h_aliases[i]);
-    }
-    nm += i - 1;
-    nm += sizeof(char *);
-    if (h->h_name)
-      nm += strlen(h->h_name);
-  }
-  ts = ARES_CACSIZE * sizeof(CacheTable);
-  sendto_one(sptr, ":%s %d %s :RES table %.1ld",
-             me.name, RPL_STATSDEBUG, sptr->name, ts);
-  sendto_one(sptr, ":%s %d %s :Structs %.1ld IP storage %.1ld Name storage %.1ld",
-             me.name, RPL_STATSDEBUG, sptr->name, sm, im, nm);
-  return ts + sm + im + nm;
-}
Index: src/s_conf.c
===================================================================
--- src/s_conf.c	(revision 183)
+++ src/s_conf.c	(working copy)
@@ -35,7 +35,7 @@
 #include "listener.h"
 #include "mtrie_conf.h"
 #include "numeric.h"
-#include "res.h"    /* gethost_byname, gethost_byaddr */
+#include "res.h"    /* hot new adns stuff */
 #include "s_bsd.h"
 #include "s_log.h"
 #include "send.h"
@@ -142,18 +142,13 @@
  * a non-null pointer, otherwise hp will be null.
  * if successful save hp in the conf item it was called with
  */
-static void conf_dns_callback(void* vptr, struct DNSReply* reply)
+static void conf_dns_callback(void* vptr, adns_answer *reply)
 {
   struct ConfItem* aconf = (struct ConfItem*) vptr;
   aconf->dns_pending = 0;
-  if (reply)
-  {
-#ifdef IPV6
-	memcpy((char*)aconf->ipnum.S_ADDR, reply->hp->h_addr, sizeof(struct in6_addr));
-#else
-    memcpy(&aconf->ipnum, reply->hp->h_addr, sizeof(struct in_addr));
-#endif
-  }
+  if (reply && (reply->status == adns_s_ok))
+    aconf->ipnum.s_addr = reply->rrs.addr->addr.inet.sin_addr.s_addr;
+  MyFree(reply);
 }
 
 /*
@@ -161,17 +156,16 @@
  * if the conf entry is currently doing a ns lookup do nothing, otherwise
  * if the lookup returns a null pointer, set the conf dns_pending flag
  */
-struct DNSReply* conf_dns_lookup(struct ConfItem* aconf)
+void conf_dns_lookup(struct ConfItem* aconf)
 {
-  struct DNSReply* dns_reply = 0;
-  if (!aconf->dns_pending) {
-    struct DNSQuery query;
-    query.vptr     = aconf;
-    query.callback = conf_dns_callback;
-    if (0 == (dns_reply = gethost_byname(aconf->host, &query)))
-      aconf->dns_pending = 1;
+  if (!aconf->dns_pending)
+  {
+    struct DNSQuery *query = MyMalloc(sizeof(struct DNSQuery));
+    query->ptr     = aconf;
+    query->callback = conf_dns_callback;
+    adns_gethost(aconf->host, query);
+    aconf->dns_pending = 1;
   }
-  return dns_reply;
 }
 
 /*
@@ -226,8 +220,6 @@
 {
   assert(0 != aconf);
 
-  if (aconf->dns_pending)
-    delete_resolver_queries(aconf);
   MyFree(aconf->host);
   if (aconf->passwd)
     memset(aconf->passwd, 0, strlen(aconf->passwd));
@@ -2762,7 +2754,8 @@
  */
 static void lookup_confhost(struct ConfItem* aconf)
 {
-  struct DNSReply* dns_reply;
+  unsigned long    ip;
+  unsigned long    mask;
 
   if (BadPtr(aconf->host) || BadPtr(aconf->name))
     {
@@ -2775,16 +2768,12 @@
   ** Do name lookup now on hostnames given and store the
   ** ip numbers in conf structure.
   */
-#ifdef IPV6
-  if(inetpton(AFINET, aconf->host, &aconf->ipnum))
-    ;
-#else
-  if (isdigit(*aconf->host))
-    aconf->ipnum.s_addr = inet_addr(aconf->host);
-#endif
-  else if (0 != (dns_reply = conf_dns_lookup(aconf)))
-    memcpy(&aconf->ipnum, dns_reply->hp->h_addr, sizeof(struct IN_ADDR));
-  
+  if (is_address(aconf->host, &ip, &mask))
+    {
+      aconf->ipnum.s_addr = htonl(ip);
+    }
+  else
+     conf_dns_lookup(aconf);
 }
 
 /*
Index: src/client.c
===================================================================
--- src/client.c	(revision 183)
+++ src/client.c	(working copy)
@@ -157,7 +157,7 @@
       cptr->listener  = NULL;
       cptr->confs     = NULL;
 
-      cptr->dns_reply = NULL;
+      cptr->dns_query = NULL;
       cptr->allownicks = NULL;
 #endif /* NULL_POINTER_NOT_ZERO */
     }
@@ -219,9 +219,6 @@
     if (-1 < cptr->fd)
       close(cptr->fd);
 
-    if (cptr->dns_reply)
-      --cptr->dns_reply->ref_count;
-
     BlockHeapFree(localClientFreeList, cptr);
   }
   else
@@ -1025,9 +1022,8 @@
 void release_client_dns_reply(struct Client* client)
 {
   assert(0 != client);
-  if (client->dns_reply) {
-    --client->dns_reply->ref_count;
-    client->dns_reply = 0;
+  if (client->dns_query) {
+    client->dns_query = 0;
   }
 }
 
@@ -1107,7 +1103,7 @@
 
   if (!MyConnect(client))
     return client->name;
-  if (!client->dns_reply)
+  if (!client->dns_query)
     return get_client_name(client, HIDE_IP);
   else
     {
@@ -1894,7 +1890,7 @@
     case 33: if (!slink_conf_dumper(output, cptr->confs)) {ircsnprintf(output, 1024, "*!* No content"); line++;} break;
       /* If we don't have any text, execute the next step instead (and increment line so we don't get it twice) */
     case 34: if (slink_conf_dumper(output, NULL)) {line--; break;} else line++;
-    case 35: ircsnprintf(output, 1024, "dns_reply %p", cptr->dns_reply); break;
+    case 35: ircsnprintf(output, 1024, "dns_query %p", cptr->dns_query); break;
     case 36: ircsnprintf(output, 1024, "passwd '%s', response '%s'", cptr->passwd, cptr->response); break;
     default:
       cptr = NULL;
Index: src/s_auth.c
===================================================================
--- src/s_auth.c	(revision 183)
+++ src/s_auth.c	(working copy)
@@ -179,59 +179,33 @@
  * a non-null pointer, otherwise hp will be null.
  * set the client on it's way to a connection completion, regardless
  * of success of failure
+ *
+ * ADNS allows us to seriously simplify this stuff --nenolod
  */
-static void auth_dns_callback(void* vptr, struct DNSReply* reply)
+static void auth_dns_callback(void* vptr, adns_answer* reply)
 {
   struct AuthRequest* auth = (struct AuthRequest*) vptr;
 
   ClearDNSPending(auth);
-  if (reply)
-    {
-      struct hostent* hp = reply->hp;
-#ifdef IPV6
-      struct in6_addr temp;
-      char name[HOSTLEN];
-#endif
-      int i;
-      /*
-       * Verify that the host to ip mapping is correct both ways and that
-       * the ip#(s) for the socket is listed for the host.
-       */
-      for (i = 0; hp->h_addr_list[i]; ++i)
-	{
-#ifdef IPV6
-        inetntop(AFINET, hp->h_addr_list[i], name, HOSTLEN);
-        inetpton(AFINET, name, &temp);
-        if (!memcmp((char*)&temp, (char*)&auth->client->ip, sizeof(struct IN_ADDR)))
-#else
-        if (!memcmp(hp->h_addr_list[i], (char *)&auth->client->ip,
-            sizeof(struct IN_ADDR)))
-#endif
-	    break;
-	}
-      if (!hp->h_addr_list[i])
-	{
-	  sendheader(auth->client, REPORT_IP_MISMATCH);
-	}
-      else
-	{
-	  ++reply->ref_count;
-	  auth->client->dns_reply = reply;
-	  strncpy_irc(auth->client->host, hp->h_name, HOSTLEN + 1);
-	  strip_colour(auth->client->host);
-	  strncpy_irc(auth->client->dnshost, auth->client->host, HOSTLEN + 1);
-	  sendheader(auth->client, REPORT_FIN_DNS);
-	}
-    }
+  if (reply && (reply->status == adns_s_ok))
+  {
+      if(strlen(*reply->rrs.str) < HOSTLEN)
+      {
+        strncpy_irc(auth->client->host, *reply->rrs.str, HOSTLEN + 1);
+        sendheader(auth->client, REPORT_FIN_DNS);
+      } else {
+        sendheader(auth->client, REPORT_FAIL_DNS);
+      }
+  }
   else
-    {
-      /*
-       * this should have already been done by s_bsd.c in add_connection
-       */
-      strncpy_irc(auth->client->host, auth->client->sockhost, HOSTLEN + 1);
-      strncpy_irc(auth->client->dnshost, auth->client->sockhost, HOSTLEN + 1);
-      sendheader(auth->client, REPORT_FAIL_DNS);
-    }
+  {
+     strncpy_irc(auth->client->host, auth->client->sockhost, HOSTLEN + 1);
+     strncpy_irc(auth->client->dnshost, auth->client->sockhost, HOSTLEN + 1);     
+     sendheader(auth->client, REPORT_FAIL_DNS);
+  }
+  MyFree(reply);
+
+  auth->client->dns_query = NULL;
   auth->client->host[HOSTLEN] = '\0';
   if (!IsDoingAuth(auth))
     {
@@ -430,33 +404,19 @@
  */
 void start_auth(struct Client* client)
 {
-  struct DNSQuery     query;
   struct AuthRequest* auth = 0;
 
   assert(0 != client);
 
   auth = make_auth_request(client);
 
-  query.vptr     = auth;
-  query.callback = auth_dns_callback;
+  client->dns_query = MyMalloc(sizeof(struct DNSQuery));
+  client->dns_query->ptr     = auth;
+  client->dns_query->callback = auth_dns_callback;
 
   sendheader(client, REPORT_DO_DNS);
 
-/*#ifdef IPV6
-  inet_ntop(AF_INET, &client->ip, encoded, HOSTLEN);
-  client->dns_reply = gethost_byaddr((const char*) , &query);
-#else
-  client->dns_reply = gethost_byaddr((const char*) &client->ip, &query);
-#endif
-*/
-  client->dns_reply = gethost_byaddr((const char*) &client->ip, &query);
-  if (client->dns_reply)
-    {
-      ++client->dns_reply->ref_count;
-      strncpy_irc(client->host, client->dns_reply->hp->h_name, HOSTLEN + 1);
-      sendheader(client, REPORT_FIN_DNSC);
-    }
-  else
+  if(!adns_getaddr(&client->ip, client->dns_query))
     SetDNSPending(auth);
 
   if (start_auth_query(auth))
@@ -479,39 +439,46 @@
   struct AuthRequest* auth;
   struct AuthRequest* auth_next = 0;
 
-  for (auth = AuthPollList; auth; auth = auth_next) {
-    auth_next = auth->next;
-    if (auth->timeout < CurrentTime) {
-      if (-1 < auth->fd)
-        close(auth->fd);
+  for (auth = AuthPollList; auth; auth = auth_next)
+    {
+      auth_next = auth->next;
+      if (auth->timeout < CurrentTime)
+        {
+          if (-1 < auth->fd)
+            close(auth->fd);
 
-      sendheader(auth->client, REPORT_FAIL_ID);
-      if (IsDNSPending(auth)) {
-        delete_resolver_queries(auth);
-        sendheader(auth->client, REPORT_FAIL_DNS);
-      }
-      logprintf(L_INFO, "DNS/AUTH timeout %s",
-          get_client_name(auth->client, HIDE_IP));
+          sendheader(auth->client, REPORT_FAIL_ID);
+          if (IsDNSPending(auth))
+            {
+              delete_adns_queries(auth->client->dns_query);
+              auth->client->dns_query->query = NULL;
+              sendheader(auth->client, REPORT_FAIL_DNS);
+            }
+          logprintf(L_INFO, "DNS/AUTH timeout %s",
+              get_client_name(auth->client, SHOW_IP));
 
-      auth->client->since = now;
-      release_auth_client(auth->client);
-      unlink_auth_request(auth, &AuthPollList);
-      free_auth_request(auth);
+          auth->client->since = now;
+          release_auth_client(auth->client);
+          unlink_auth_request(auth, &AuthPollList);
+          free_auth_request(auth);
+        }
     }
-  }
-  for (auth = AuthIncompleteList; auth; auth = auth_next) {
-    auth_next = auth->next;
-    if (auth->timeout < CurrentTime) {
-      delete_resolver_queries(auth);
-      sendheader(auth->client, REPORT_FAIL_DNS);
-      logprintf(L_INFO, "DNS timeout %s", get_client_name(auth->client, HIDE_IP));
+  for (auth = AuthIncompleteList; auth; auth = auth_next)
+    {
+      auth_next = auth->next;
+      if (auth->timeout < CurrentTime)
+        {
+          delete_adns_queries(auth->client->dns_query);
+          auth->client->dns_query->query = NULL;
+          sendheader(auth->client, REPORT_FAIL_DNS);
+          logprintf(L_INFO, "DNS timeout %s", get_client_name(auth->client, SHOW_IP));
 
-      auth->client->since = now;
-      release_auth_client(auth->client);
-      unlink_auth_request(auth, &AuthIncompleteList);
-      free_auth_request(auth);
+          auth->client->since = now;
+          release_auth_client(auth->client);
+          unlink_auth_request(auth, &AuthIncompleteList);
+          free_auth_request(auth);
+        }
     }
-  }
 }
 
 /*
Index: src/s_serv.c
===================================================================
--- src/s_serv.c	(revision 183)
+++ src/s_serv.c	(working copy)
@@ -365,10 +365,13 @@
       return 0;
     }
   lp = cptr->confs;
-  if (cptr->dns_reply)
+
+/* XXX this code is useless anyway, do we *really* need to fix it? --nenolod */
+#if 0
+  if (cptr->dns_query)
     {
       int             i;
-      struct hostent* hp   = cptr->dns_reply->hp;
+      struct hostent* hp   = cptr->dns_query->hp;
       char*           name = hp->h_name;
       /*
        * if we are missing a C or N line from above, search for
@@ -396,6 +399,7 @@
                                   cptr->username, CONF_NOCONNECT_SERVER);
         }
     }
+#endif
   /*
    * Check for C and N lines with the hostname portion the ip number
    * of the host the server runs on. This also checks the case where
Index: src/Makefile.am
===================================================================
--- src/Makefile.am	(revision 183)
+++ src/Makefile.am	(working copy)
@@ -7,6 +7,7 @@
 AM_CPPFLAGS = -DPREFIX="\"$(prefix)\""
 
 hyperion_ircd_SOURCES = ircd.c \
+	adns.c \
 	blalloc.c \
 	channel.c \
 	class.c \
@@ -85,7 +86,6 @@
 	packet.c \
 	paths.c \
 	parse.c \
-	res.c \
 	restart.c \
 	s_auth.c \
 	s_bsd.c \
@@ -108,6 +108,8 @@
 	varparse.c \
 	version.c
 
+hyperion_ircd_LDADD = -L../adns -ladns
+
 .PHONY: svn_version.c
 
 svn_version.c:
Index: build-misc/Makefile.in
===================================================================
--- build-misc/Makefile.in	(revision 183)
+++ build-misc/Makefile.in	(working copy)
@@ -36,8 +36,8 @@
 build_triplet = @build@
 host_triplet = @host@
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/build-misc/common.mk config.guess config.sub \
-	depcomp install-sh missing mkinstalldirs
+	$(top_srcdir)/build-misc/common.mk compile config.guess \
+	config.sub depcomp install-sh missing mkinstalldirs
 subdir = build-misc
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/autoconf/hyperion-c.m4 \
@@ -95,11 +95,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
Index: build-misc/compile
===================================================================
--- build-misc/compile	(revision 0)
+++ build-misc/compile	(revision 0)
@@ -0,0 +1,136 @@
+#! /bin/sh
+# Wrapper for compilers which do not understand `-c -o'.
+# $Id: compile 18957 2005-04-09 23:57:45Z androsyn $
+scriptversion=2003-11-09.00
+
+# Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.
+# Written by Tom Tromey <tromey@cygnus.com>.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# This file is maintained in Automake, please report
+# bugs to <bug-automake@gnu.org> or send patches to
+# <automake-patches@gnu.org>.
+
+case $1 in
+  '')
+     echo "$0: No command.  Try \`$0 --help' for more information." 1>&2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat <<\EOF
+Usage: compile [--help] [--version] PROGRAM [ARGS]
+
+Wrapper for compilers which do not understand `-c -o'.
+Remove `-o dest.o' from ARGS, run PROGRAM with the remaining
+arguments, and rename the output as expected.
+
+If you are trying to build a whole package this is not the
+right script to run: please start by reading the file `INSTALL'.
+
+Report bugs to <bug-automake@gnu.org>.
+EOF
+    exit 0
+    ;;
+  -v | --v*)
+    echo "compile $scriptversion"
+    exit 0
+    ;;
+esac
+
+
+prog=$1
+shift
+
+ofile=
+cfile=
+args=
+while test $# -gt 0; do
+  case "$1" in
+    -o)
+      # configure might choose to run compile as `compile cc -o foo foo.c'.
+      # So we do something ugly here.
+      ofile=$2
+      shift
+      case "$ofile" in
+	*.o | *.obj)
+	  ;;
+	*)
+	  args="$args -o $ofile"
+	  ofile=
+	  ;;
+      esac
+       ;;
+    *.c)
+      cfile=$1
+      args="$args $1"
+      ;;
+    *)
+      args="$args $1"
+      ;;
+  esac
+  shift
+done
+
+if test -z "$ofile" || test -z "$cfile"; then
+  # If no `-o' option was seen then we might have been invoked from a
+  # pattern rule where we don't need one.  That is ok -- this is a
+  # normal compilation that the losing compiler can handle.  If no
+  # `.c' file was seen then we are probably linking.  That is also
+  # ok.
+  exec "$prog" $args
+fi
+
+# Name of file we expect compiler to create.
+cofile=`echo $cfile | sed -e 's|^.*/||' -e 's/\.c$/.o/'`
+
+# Create the lock directory.
+# Note: use `[/.-]' here to ensure that we don't use the same name
+# that we are using for the .o file.  Also, base the name on the expected
+# object file name, since that is what matters with a parallel build.
+lockdir=`echo $cofile | sed -e 's|[/.-]|_|g'`.d
+while true; do
+  if mkdir $lockdir > /dev/null 2>&1; then
+    break
+  fi
+  sleep 1
+done
+# FIXME: race condition here if user kills between mkdir and trap.
+trap "rmdir $lockdir; exit 1" 1 2 15
+
+# Run the compile.
+"$prog" $args
+status=$?
+
+if test -f "$cofile"; then
+  mv "$cofile" "$ofile"
+fi
+
+rmdir $lockdir
+exit $status
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
Index: tools/Makefile.in
===================================================================
--- tools/Makefile.in	(revision 183)
+++ tools/Makefile.in	(working copy)
@@ -94,11 +94,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
Index: configure.ac
===================================================================
--- configure.ac	(revision 183)
+++ configure.ac	(working copy)
@@ -33,6 +33,7 @@
 dnl Checks for programs.
 
 AC_PROG_CC
+AC_PROG_RANLIB
 AC_ISC_POSIX
 AC_PROG_INSTALL
 
@@ -358,6 +359,7 @@
 
 AC_CONFIG_FILES(
 Makefile
+adns/Makefile
 autoconf/Makefile
 build-misc/Makefile
 doc/Makefile
Index: doc/sgml/Makefile.in
===================================================================
--- doc/sgml/Makefile.in	(revision 183)
+++ doc/sgml/Makefile.in	(working copy)
@@ -103,11 +103,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
Index: doc/sgml/dancer-user-guide/Makefile.in
===================================================================
--- doc/sgml/dancer-user-guide/Makefile.in	(revision 183)
+++ doc/sgml/dancer-user-guide/Makefile.in	(working copy)
@@ -106,11 +106,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
Index: doc/sgml/dancer-oper-guide/Makefile.in
===================================================================
--- doc/sgml/dancer-oper-guide/Makefile.in	(revision 183)
+++ doc/sgml/dancer-oper-guide/Makefile.in	(working copy)
@@ -106,11 +106,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
Index: doc/Makefile.in
===================================================================
--- doc/Makefile.in	(revision 183)
+++ doc/Makefile.in	(working copy)
@@ -113,11 +113,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
Index: lib/Makefile.in
===================================================================
--- lib/Makefile.in	(revision 183)
+++ lib/Makefile.in	(working copy)
@@ -103,11 +103,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
Index: lib/Dancer/Proxy/Makefile.in
===================================================================
--- lib/Dancer/Proxy/Makefile.in	(revision 183)
+++ lib/Dancer/Proxy/Makefile.in	(working copy)
@@ -94,11 +94,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
Index: lib/Dancer/Makefile.in
===================================================================
--- lib/Dancer/Makefile.in	(revision 183)
+++ lib/Dancer/Makefile.in	(working copy)
@@ -103,11 +103,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 183)
+++ Makefile.am	(working copy)
@@ -9,7 +9,7 @@
 
 ## This one just recurses into the subdirectories
 
-SUBDIRS = autoconf build-misc include src lib tools doc patches
+SUBDIRS = adns autoconf build-misc include src lib tools doc patches
 
 EXTRA_DIST = AUTHORS NEWS README
 
Index: autoconf/Makefile.in
===================================================================
--- autoconf/Makefile.in	(revision 183)
+++ autoconf/Makefile.in	(working copy)
@@ -94,11 +94,13 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
 ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
 am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
 am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
